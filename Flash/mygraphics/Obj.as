package mygraphics{	import flash.display.BitmapData		import flash.display.DisplayObject	import flash.display.DisplayObjectContainer	import flash.geom.Matrix	import flash.geom.ColorTransform		public class Obj {			public static function xyIn(obj1:DisplayObject, container:DisplayObjectContainer):Array{			var xIn = (obj1.transform.concatenatedMatrix.tx - container.transform.concatenatedMatrix.tx) / container.transform.concatenatedMatrix.a			var yIn = (obj1.transform.concatenatedMatrix.ty - container.transform.concatenatedMatrix.ty) / container.transform.concatenatedMatrix.d						return([xIn,yIn])		}		public static function edgePointAtAngle(obj:DisplayObject,angleRadians:Number, searchRadius:Number,...args):Array{			//Mat rotates the object by negative angleRadians to get an edgePoint +angle from the +x axis			if(args.length ==0){var offset = [0,0]} else { offset = args[0]}			var mat = new Matrix()			mat.a = Math.cos(angleRadians)			mat.d = Math.cos(angleRadians)			mat.b = Math.sin(angleRadians)			mat.c =-Math.sin(angleRadians)			mat.tx = -1 *(Math.cos(angleRadians) * offset[0] - Math.sin(angleRadians) * offset[1])			mat.ty = -1 *(Math.cos(angleRadians) * offset[1] + Math.sin(angleRadians) * offset[0])						var d= new BitmapData(searchRadius,1,false, 0x000000)			 d.draw(obj,mat,new ColorTransform(1,1,1,1,255,-255,-255,255))			var bounds = d.getColorBoundsRect(0xFF0000,0x000000)			var firstX = bounds.x			var xyInObject = [firstX * Math.cos(angleRadians), firstX * Math.sin(angleRadians)]			xyInObject = [xyInObject[0] + offset[0], xyInObject[1] + offset[1]]			return xyInObject																					}					}	}