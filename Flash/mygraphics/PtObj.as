package mygraphics{	import flash.display.Shape	import flash.display.Sprite	import flash.display.Bitmap	import flash.display.BitmapData	import flash.display.DisplayObject		import flash.utils.ByteArray		import flash.geom.Rectangle	import flash.geom.ColorTransform	import flash.display.InterpolationMethod	import flash.geom.Matrix	import flash.display.BlendMode	import flash.display.DisplayObjectContainer	import flash.utils.getTimer				public class PtObj {		public static var s:Sprite/*		public static function vectorToSurface(obj1XY:Array,obj2XY:Array,obj2:DisplayObject,container:DisplayObjectContainer,... args):Array{					//Section to identify which object to treat as an object and which to treat as a point:			var b2 = obj2.getBounds(container)				var xyP = obj1XY				var objL = obj2; var xyL = obj2XY					//uses Input args or a pair of searches to define the window.			var windowRect:Rectangle			var window:Rectangle			if(args.length > 0){windowRect = args[0]}else{windowRect = null}			if(windowRect == null){				 b2 = objL.getBounds(container)				var left = Math.floor(b2.left)				var top  = Math.floor(b2.top)				var right= Math.floor(b2.right)				var bottom= Math.floor(b2.bottom)				var h = bottom - top				var w = right - left				var margin = 10				window = new Rectangle(left,top,w,h)			} else { window = windowRect }									var search = true, nSearches = 0			var isInside = false,noEdge = false, noZoom = false,foundNativeZoom = false			var bestIDXLeastBlue:Array			var depth:Number,leastOfAllBlue:Number,leastGoodBlue:Number,leastIDX:Number			var dLandWindow:Array, dL:BitmapData, bits:ByteArray						var windowDiagonal:Number						while(search){								windowDiagonal = Math.sqrt(Math.pow(window.width,2) +  Math.pow(window.height,2))				if((windowDiagonal < 50 ) || (nSearches >= 3)){					search = false					foundNativeZoom = true					noZoom = true				}								nSearches ++				dLandWindow = getLowResData(xyP,objL,xyL,window,30,noZoom)				dL = dLandWindow[0]				bits = dL.getPixels(new Rectangle(0,0,dL.width,dL.height))				bestIDXLeastBlue = searchRedBlue(bits,!isInside)								leastOfAllBlue = bestIDXLeastBlue[2]				leastGoodBlue = bestIDXLeastBlue[1]				leastIDX =  bestIDXLeastBlue[0]				if(leastOfAllBlue == leastGoodBlue){					isInside = !isInside					bestIDXLeastBlue = searchRedBlue(bits,!isInside)					leastOfAllBlue = bestIDXLeastBlue[2]					leastGoodBlue = bestIDXLeastBlue[1]					leastIDX = bestIDXLeastBlue[0]				}				if(leastIDX == -1){return null}				var rowBestLow = Math.floor(leastIDX / 4 /   dL.width)				var colBestLow = Math.floor((leastIDX / 4) % dL.width)				var lowScaleX  = dL.width/ window.width				var lowScaleY  = dL.height/window.height					var rowBestFull =Math.floor( rowBestLow / lowScaleY )				var colBestFull =Math.floor( colBestLow / lowScaleX )				var xBest = colBestFull + window.x				var yBest = rowBestFull + window.y							var searchOffsetX =Math.floor( 1 / lowScaleX ) * 3				var searchOffsetY =Math.floor( 1 / lowScaleY ) * 3				window = new Rectangle(window.x + colBestFull - searchOffsetX, window.y + rowBestFull - searchOffsetX,searchOffsetX*2, searchOffsetY *2)			}						var bestFromPtX = xBest - xyP[0]			var bestFromPtY = yBest - xyP[1]			var vectorToSurface = [ bestFromPtX, bestFromPtY,isInside]			return vectorToSurface			}*/				public static function closestPoint(xyP:Array,xyL:Array,objL:DisplayObject,container:DisplayObjectContainer,window:Rectangle):Array{											var search = true, nSearches = 0			var isInside = false,noEdge = false, noZoom = false,foundNativeZoom = false			var bestIDXLeastBlue:Array			var depth:Number,leastOfAllBlue:Number,leastGoodBlue:Number,leastIDX:Number			var dLandWindow:Array, dL:BitmapData, bits:ByteArray						var windowDiagonal:Number						while(search){								windowDiagonal = Math.sqrt(Math.pow(window.width,2) +  Math.pow(window.height,2))				if((windowDiagonal < 50 ) || (nSearches >= 3)){					search = false					foundNativeZoom = true					noZoom = true				}								nSearches ++				dLandWindow = getLowResData(xyP,objL,xyL,window,30,noZoom)				dL = dLandWindow[0]				bits = dL.getPixels(new Rectangle(0,0,dL.width,dL.height))				bestIDXLeastBlue = searchRedBlue(bits,!isInside)								leastOfAllBlue = bestIDXLeastBlue[2]				leastGoodBlue = bestIDXLeastBlue[1]				leastIDX =  bestIDXLeastBlue[0]				var searchingSecond = false				var leastOrig = leastIDX				if(leastOfAllBlue == leastGoodBlue){					searchingSecond = true					isInside = !isInside					bestIDXLeastBlue = searchRedBlue(bits,!isInside)					leastOfAllBlue = bestIDXLeastBlue[2]					leastGoodBlue = bestIDXLeastBlue[1]					leastIDX = bestIDXLeastBlue[0]				}							if(leastIDX == -1){			return null}				var rowBestLow = Math.floor(leastIDX / 4 /   dL.width)				var colBestLow = Math.floor((leastIDX / 4) % dL.width)				var lowScaleX  = dL.width/ window.width				var lowScaleY  = dL.height/window.height					var rowBestFull =Math.floor( rowBestLow / lowScaleY )				var colBestFull =Math.floor( colBestLow / lowScaleX )				var xBest = colBestFull + window.x				var yBest = rowBestFull + window.y							var searchOffsetX =Math.floor( 1 / lowScaleX ) * 2				var searchOffsetY =Math.floor( 1 / lowScaleY ) * 2				window = new Rectangle(window.x + colBestFull - searchOffsetX, window.y + rowBestFull - searchOffsetX,searchOffsetX*2, searchOffsetY *2)			}						var vectorToSurface = [ [xBest,yBest], isInside]			return vectorToSurface			}						public static function searchRedBlue(bits:ByteArray,highRed:Boolean):Array{			var red = uint, blue = uint			var leastGoodBlue = -1			var leastIDX = -1			var thisDistance:Number			var minOfAllBlue = -1						for(var i:uint =0;i<bits.length;i+=4){				red = bits[i+1]				blue= bits[i+3]				 				if(i==0){					minOfAllBlue = 256					leastGoodBlue = 256				}				if((blue < minOfAllBlue)  ){					minOfAllBlue = blue				}				if(highRed){					if(red >= 125){						if((blue < leastGoodBlue) ){							leastGoodBlue = blue							leastIDX = i						}					}				} else {					if(red <= 125){						if((blue < leastGoodBlue) ){							leastGoodBlue = blue							leastIDX = i						}					}					}			}			return([leastIDX, leastGoodBlue, minOfAllBlue])		}					public static function getLowResData(xyP:Array,objL:DisplayObject,xyL:Array,window:Rectangle,attemptedDiagonal:Number,noZoom:Boolean):Array{						var xyPInWindow = [xyP[0] - window.x, xyP[1] - window.y]			var xyLInWindow = [xyL[0] - window.x, xyL[1] - window.y]						var windowMaxDistance = Math.sqrt(Math.pow(window.height,2) + Math.pow(window.width,2))			var maxDistancePToWindow = windowMaxDistance + Math.sqrt(Math.pow(xyPInWindow[0],2) + Math.pow(xyPInWindow[1],2))						var attemptedRescaleX:Number, attemptedRescaleY:Number			if(!noZoom){				attemptedRescaleX = attemptedDiagonal / windowMaxDistance				attemptedRescaleY = attemptedDiagonal / windowMaxDistance			} else {				attemptedRescaleX = 1				attemptedRescaleY = 1			}									var rescaledWindow = new Rectangle(window.x,window.y,Math.floor(attemptedRescaleX * window.width), Math.floor(attemptedRescaleY * window.height))			var rescaleX = rescaledWindow.width/window.width			var rescaleY = rescaledWindow.height/window.height						var xyPInWindowRescaled = [xyPInWindow[0] * rescaleX, xyPInWindow[1] * rescaleY]			var xyLInWindowRescaled = [xyLInWindow[0] * rescaleX, xyLInWindow[1] * rescaleY]						var metric = new Shape()			var gradientSize  = maxDistancePToWindow* 2			var gradientLength= gradientSize/2			var gradientMatrix = new Matrix()			gradientMatrix.createGradientBox(gradientSize,gradientSize,0,xyPInWindow[0] - gradientSize/2 ,xyPInWindow[1] -gradientSize/2 )						metric.graphics.beginGradientFill("radial",[0x000000,0x0000FF],[1,1],[1,255],gradientMatrix,'pad',InterpolationMethod.LINEAR_RGB)			metric.graphics.drawRect(0,0,window.width,window.height)							var objLMat = new Matrix(rescaleX,0,0,rescaleY,xyLInWindowRescaled[0],xyLInWindowRescaled[1])			var metricMat = new Matrix(rescaleX,0,0,rescaleY,0,0)						var d = new BitmapData(rescaledWindow.width,rescaledWindow.height,false,0x000000)			d.draw(objL,objLMat,new ColorTransform(1,1,1,1,255,-255,-255,255),BlendMode.NORMAL)			d.draw(metric,metricMat ,new ColorTransform(1,1,1,1,0,0,0,255),BlendMode.ADD)								return [d,rescaledWindow]					}	}	}