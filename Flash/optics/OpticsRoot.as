package optics{	import flash.display.MovieClip	import flash.display.Shape	import flash.display.Sprite	import flash.display.DisplayObject	import flash.geom.ColorTransform	import flash.geom.Rectangle	import flash.events.MouseEvent	import flash.events.Event		import flash.display.Bitmap	import flash.display.BitmapData	import flash.geom.Matrix		import flash.display.BlendMode	import mygraphics.ObjObj	import mygraphics.PtObj	import mygraphics.Obj		import math.VectorMath2D		public class OpticsRoot extends MovieClip{		public var incidentLines:Sprite = new Sprite()	public var refractedLines:Sprite = new Sprite()	public var transmittedLines:Sprite = new Sprite()	public var transmittedLines2:Sprite = new Sprite()		public var lensS1:Sprite	public var lensS2:Sprite	public var lensAllSprite:Sprite	public var r1:Number	public var r2:Number	public var c1:Number	public var c2:Number	public var mouseXY:Array = [0,0]		public var lensMiddle:Array		var i1:Shape= new Shape()	var i2:Shape= new Shape()	var ref1:Shape= new Shape()	var ref2:Shape= new Shape()	var trans1:Shape = new Shape()	var trans2:Shape = new Shape()	var t21:Shape = new Shape()	var t22:Shape = new Shape()			public function OpticsRoot(){						r1 = 10000			r2 = 10000			c1 = - 9975			c2 = 9975						lensAllSprite = new Sprite()						lensS1 = new Sprite()			lensS1.graphics.beginFill(0xAAAAFF)			lensS1.graphics.drawCircle(0,0,r1)			lensAllSprite.addChild(lensS1)			lensS1.x = c1			lensS2 = new Sprite()			lensS2.graphics.beginFill(0xAAAAFF)			lensS2.graphics.drawCircle(0,0,r1)			lensS2.x = c2			lensAllSprite.addChild(lensS2)			lensS1.mask = lensS2			lensAllSprite.addChild(lensS1)			var mx = 200			var my = 200			lensAllSprite.y = mx			lensAllSprite.x = my			lensMiddle = [mx,my]			incidentLines.addChild(i1)			incidentLines.addChild(i2)			refractedLines.addChild(ref1)			refractedLines.addChild(ref2)			transmittedLines.addChild(trans1)			transmittedLines.addChild(trans2)			transmittedLines2.addChild(t21)			transmittedLines2.addChild(t22)						addChild(lensAllSprite)			addChild(incidentLines)			addChild(refractedLines)			addChild(transmittedLines)			addChild(transmittedLines2)												stage.addEventListener(MouseEvent.MOUSE_MOVE,orMouseDown)			stage.addEventListener(Event.ENTER_FRAME,orEnterFrame)									var s1 = new Shape()			s1.graphics.beginFill(0x55FF55)			s1.graphics.drawRect(5,5,100,100)														}		public function orMouseDown(event:MouseEvent){			mouseXY = [event.localX,event.localY]		}				public function orEnterFrame(event:Event){			var m1 = 0			var m2 = ( lensMiddle[1] - mouseXY[1]) /(  lensMiddle[0] - mouseXY[0])			var b1 = (-1 * mouseXY[0] * m1) +mouseXY[1]			var b2 = (-1 * mouseXY[0] * m2) +mouseXY[1]						i1.graphics.clear()			i1.graphics.lineStyle(2)			i1.graphics.moveTo(0,b1)			i1.graphics.lineTo(stage.stageWidth,b1 + stage.stageWidth* m1)			i2.graphics.clear()			i2.graphics.lineStyle(2)			i2.graphics.moveTo(0,b2)			i2.graphics.lineTo(stage.stageWidth,b2 +stage.stageWidth* m2)												var shapeXY = Obj.xyIn(lensAllSprite,this)			var intersect:Rectangle			var obj:DisplayObject			var units:Array			var angleIncident:Number			var angleNormal:Number,angleOut:Number,angleOutOffNormal:Number,slopeNormal:Number						var shiftDist = 10			var m:Number			var xHit:Number			var yHit:Number						var slope:Number			var b:Number			var ref:Shape,trans:Shape,toDraw:Shape, t2:Shape			var s0:Array, s1: Array			var n1:Number, n2:Number, hitX:Number, hitY:Number,shiftX:Number,shiftY:Number						for(var i = 0 ; i < 2 ; i++) {				if(i ==0){					obj = i1					m = m1					ref=ref1					trans = trans1					t2= t21				} else{					obj = i2					m = m2					ref=ref2					trans = trans2					t2 = t22}					intersect = ObjObj.findIntersect(obj,lensAllSprite, this)								for(var j = 0; j <3 ; j++){									shiftX = shiftDist * ( 1 / Math.sqrt(Math.pow(m,2) + 1))					shiftY = shiftDist * ( m / Math.sqrt(Math.pow(m,2) + 1))					if( j ==0 ){						shiftX = -1 * shiftX						shiftY = -1 * shiftY						toDraw = ref						n1 = 1						n2 = 2					} else {if (j ==1) {						shiftX = -1 * shiftX						shiftY = -1 * shiftY						toDraw = trans						n1 = 1						n2 = 2					}else {						toDraw = t2						n1 = 2						n2 = 1					}}					if(intersect != null){						if(j <2 ){hitX = intersect.x; if(m>0){hitY = intersect.y} else {hitY =intersect.y + intersect.height} }						else { hitX = intersect.x +intersect.width ; if(m<0){hitY = intersect.y} else{hitY = intersect.y +intersect.height}}						units = PtObj.unitsAtClosestPt(lensAllSprite,shapeXY,[hitX + shiftX, hitY + shiftY],50,[5,2],true)						if(units != null){														if(j<2){angleIncident = Math.atan(m)} else{angleIncident = Math.atan(slope)}							slopeNormal = Math.atan(units[3]/units[2])							angleNormal = slopeNormal							if(j == 0) {								angleOutOffNormal = ( angleNormal - angleIncident)							} else {if ( (j== 1) ||(j ==2))  {								angleOutOffNormal = Math.asin(  n1 / n2*  Math.sin(angleIncident - angleNormal))								}}								//trace(angleNormal)							angleOut = angleNormal + angleOutOffNormal/*							if(i ==1){								trace(angleOut)								trace(j)}*/							slope= Math.tan(angleOut)							b = (-1 * hitX * slope) + hitY							//trace(["hitX,hitY",hitX,hitY,slope])							toDraw.graphics.clear()							toDraw.graphics.lineStyle(1, 255*Math.pow(256,j))							if(j ==0){s0 = [0,b] ; s1 = [hitX,hitY] } else { s0 = [hitX,hitY]; s1 = [stage.stageWidth,hitY + stage.stageWidth * slope]}							toDraw.graphics.moveTo(s0[0],s0[1])							toDraw.graphics.lineTo(s1[0],s1[1])													}					}				}			}		}	}	}