package physics.twobody{	import math.VectorMath2D	import math.VectorMath3D	import flash.display.Sprite	import physics.PhysUniverse	public class TwoBodyCollision{		public static function elasticCollideObjs(objs:Array,pt:Array,units:Array,nextVel:Boolean):Array{			if(nextVel){				var vs = [objs[0].getNextVel(),objs[1].getNextVel()]			}else{				vs = [objs[0].getVel(),objs[1].getVel()]			}			return(elasticCollision([objs[0].getMass(),objs[1].getMass()],[objs[0].getMomentOfInertia(),objs[1].getMomentOfInertia()],[objs[0].getCOM(),objs[1].getCOM()],vs,[objs[0].getOmega(),objs[1].getOmega()],pt,units))		}		public static function inelasticCollideObjs(objs:Array,pt:Array,units:Array,nextVel:Boolean):Array{			if(nextVel){				var vs = [objs[0].getNextVel(),objs[1].getNextVel()]			}else{				vs = [objs[0].getVel(),objs[1].getVel()]			}			return(inelasticCollision([objs[0].getMass(),objs[1].getMass()],[objs[0].getMomentOfInertia(),objs[1].getMomentOfInertia()],[objs[0].getCOM(),objs[1].getCOM()],vs,[objs[0].getOmega(),objs[1].getOmega()],pt,units))		}		public static function inelasticSimpleObjs(objs:Array,units:Array,nextVel:Boolean):Array{			if(nextVel){				var vs = [objs[0].getNextVel(),objs[1].getNextVel()]			}else{				vs = [objs[0].getVel(),objs[1].getVel()]			}			return(inelasticSimple([objs[0].getMass(),objs[1].getMass()],vs,units))		}				public static function twoPtInelasticObjs(objs:Array,pts:Array,unitsToward1:Array){			var s = new Sprite()			var obj1 = objs[0]			var obj2 = objs[1]			var vec12 = [pts[1][0] - pts[0][0],pts[1][1] - pts[0][1]]						var v10 = obj1.getVel(pts[0])			var u10 = obj2.getVel(pts[0])			var v20 = obj1.getVel(pts[1])			var u20 = obj2.getVel(pts[1])			var iHat11 = [unitsToward1[0][0],unitsToward1[0][1]]			var iHat21 = [-iHat11[0],-iHat11[1]]			var iHat12 = [unitsToward1[1][0],unitsToward1[1][1]]			var iHat22 = [-iHat12[0],-iHat12[1]]			var r11 = obj1.getCOMRadius(pts[0])			var r12 = obj1.getCOMRadius(pts[1])			var r21 = obj2.getCOMRadius(pts[0])			var r22 = obj2.getCOMRadius(pts[1])						var v21 = obj2.getCOMRadius(obj1.getCOM())			v21.push(0)						r11.push(0)			r12.push(0)			r21.push(0)			r22.push(0)			iHat11.push(0)			iHat21.push(0)			iHat12.push(0)			iHat22.push(0)									var k11Vec = VectorMath3D.crossMultiply3D(VectorMath3D.crossMultiply3D(r11,iHat11),r11)			k11Vec = [k11Vec[0] / obj1.getMomentOfInertia(), k11Vec[1] / obj1.getMomentOfInertia()]			var k12Vec = VectorMath3D.crossMultiply3D(VectorMath3D.crossMultiply3D(r11,iHat11),r12)			k12Vec = [k12Vec[0] / obj1.getMomentOfInertia(), k12Vec[1] / obj1.getMomentOfInertia()]			var k21Vec = VectorMath3D.crossMultiply3D(VectorMath3D.crossMultiply3D(r12,iHat12),r11)			k21Vec = [k21Vec[0] / obj1.getMomentOfInertia(), k21Vec[1] / obj1.getMomentOfInertia()]			var k22Vec = VectorMath3D.crossMultiply3D(VectorMath3D.crossMultiply3D(r12,iHat12),r12)			k22Vec = [k22Vec[0] / obj1.getMomentOfInertia(), k22Vec[1] / obj1.getMomentOfInertia()]			var c11Vec = VectorMath3D.crossMultiply3D(VectorMath3D.crossMultiply3D(r21,iHat11),r21)			c11Vec = [c11Vec[0] / obj2.getMomentOfInertia(), c11Vec[1] / obj2.getMomentOfInertia()]			var c12Vec = VectorMath3D.crossMultiply3D(VectorMath3D.crossMultiply3D(r21,iHat11),r22)			c12Vec = [c12Vec[0] / obj2.getMomentOfInertia(), c12Vec[1] / obj2.getMomentOfInertia()]			var c21Vec = VectorMath3D.crossMultiply3D(VectorMath3D.crossMultiply3D(r22,iHat12),r21)			c21Vec = [c21Vec[0] / obj2.getMomentOfInertia(), c21Vec[1] / obj2.getMomentOfInertia()]			var c22Vec = VectorMath3D.crossMultiply3D(VectorMath3D.crossMultiply3D(r22,iHat12),r22)			c22Vec = [c22Vec[0] / obj2.getMomentOfInertia(), c22Vec[1] / obj2.getMomentOfInertia()]			//now the "c" coefficients describe change in motion of pts on object2 caused by a unit push along the direction iHat1			var m0 = (1/obj1.getMass() + 1/ obj2.getMass())			var a1 = VectorMath2D.dotMultiply2D([ v10[0] - u10[0],v10[1] - u10[1]],iHat11)			var a2 = VectorMath2D.dotMultiply2D([ v20[0] - u20[0],v20[1] - u20[1]],iHat12)			var b1 = VectorMath2D.dotMultiply2D([ k21Vec[0] + c21Vec[0] , k21Vec[1] + c21Vec[1]] , iHat11) + m0 * VectorMath2D.dotMultiply2D(iHat11,iHat12)			var	b2 = VectorMath2D.dotMultiply2D([ k22Vec[0] + c22Vec[0] , k22Vec[1] + c22Vec[1]] , iHat12) + m0			var c1 = VectorMath2D.dotMultiply2D([ k11Vec[0] + c11Vec[0] , k11Vec[1] + c11Vec[1]] , iHat11) + m0			var c2 = VectorMath2D.dotMultiply2D([ k12Vec[0] + c12Vec[0] , k12Vec[1] + c12Vec[1]] , iHat12) + m0 * VectorMath2D.dotMultiply2D(iHat11,iHat12)			var i2 = ( - a2 / c2 + a1 / c1) / (b2 / c2 - b1 / c1)			var i1 = ( - a1 - b1 * i2 ) / c1														//if(i1 > 0 && i2 >0){													var impulse1 = [i1 * unitsToward1[0][0],i1 * unitsToward1[0][1]]				var impulse2 = [i2 * unitsToward1[1][0],i2 * unitsToward1[1][1]]				/*				obj1.exertImpulseAt(impulse1,pts[0])				obj1.exertImpulseAt(impulse2,pts[1])				//trace(i1,i2)*/				return([impulse1,impulse2])					}		public static function onePtInelasticObjs(objs:Array,pt:Array,unitTo1:Array):Array{							var obj1 = objs[0]				var obj2 = objs[1]				var m1 = obj1.getEMassAtAlong(pt,unitTo1)				var m2 = obj2.getEMassAtAlong(pt,unitTo1)				var v1A = VectorMath2D.dotMultiply2D(obj1.getVel(pt),unitTo1)				var v2A = VectorMath2D.dotMultiply2D(obj2.getVel(pt),unitTo1)				var vC = (v1A * m1 + v2A * m2)/(m1 + m2)				var v1A2 = v1A - vC				var v2A2 = v2A - vC				var eI1 = -m1 * v1A2				var eI2 = -m2 * v2A2				var impulse1 = [eI1 * unitTo1[0], eI1 * unitTo1[1]]				var impulse2 = [eI2 * unitTo1[0], eI2 * unitTo1[1]]				return([impulse1,impulse2])									}		public static function twoPtInelastic(){					}				public static function elasticCollision(masses:Array,moments:Array,COMs:Array,velocities:Array,omegas:Array,pt:Array,units:Array):Array{			var eMasses = new Array(2)			var vPerps = new Array(2)			var unitAlong = [units[0],units[1]]			var unitPerp = [units[2],units[3]]						for( var i = 0; i < 2 ; i++ ){				var colRad = [pt[0] - COMs[i][0],pt[1] - COMs[i][1]]				var radiusParallel = VectorMath2D.dotMultiply2D(unitAlong,colRad)				eMasses[i] =  1 / (Math.pow(radiusParallel , 2) / moments[i] + 1 / masses[i])				var vBig = velocities[i]				var vSpin = VectorMath3D.crossMultiply3D([0,0,omegas[i]], [unitAlong[0] *radiusParallel,unitAlong[1]*radiusParallel,0])				vPerps[i] = VectorMath2D.dotMultiply2D([vBig[0] + vSpin[0],vBig[1] + vSpin[1]],unitPerp)			}											var vCom = (vPerps[0]*eMasses[0] + vPerps[1]*eMasses[1])/(eMasses[0] + eMasses[1])			var vIns = [vPerps[0] - vCom, vPerps[1] - vCom]			var energyIn = .5 * eMasses[0]*Math.pow(vIns[0],2)+ .5 * eMasses[1]*Math.pow(vIns[1],2)			var magVOuts = new Array(2)			magVOuts[0] = Math.sqrt(energyIn * 2 * eMasses[1]/eMasses[0] * 1/(eMasses[0] + eMasses[1]))			magVOuts[1] = Math.sqrt(energyIn * 2 * eMasses[0]/eMasses[1] * 1/(eMasses[0] + eMasses[1]))			var vOuts = new Array(2)			if(vIns[0] < 0){				vOuts[0] = magVOuts[0]				vOuts[1] = magVOuts[1] * -1			} else {				vOuts[0] = magVOuts[0] * -1				vOuts[1] = magVOuts[1] 			}			var magImpulse1 = (vOuts[0] - vIns[0]) * eMasses[0]			var magImpulse2 = (vOuts[1] - vIns[1]) * eMasses[1]			var impulse1 = [magImpulse1 * unitPerp[0],magImpulse1 * unitPerp[1]]			var impulse2 = [magImpulse2 * unitPerp[0],magImpulse2 * unitPerp[1]]			return([impulse1,impulse2])										}		public static function inelasticCollision(masses:Array,moments:Array,COMs:Array,velocities:Array,omegas:Array,pt:Array,units:Array):Array{			var eMasses = new Array(2)			var vPerps = new Array(2)			var unitAlong = [units[0],units[1]]			var unitPerp = [units[2],units[3]]						for( var i = 0; i < 2 ; i++ ){				var colRad = [pt[0] - COMs[i][0],pt[1] - COMs[i][1]]				var radiusParallel = VectorMath2D.dotMultiply2D(unitAlong,colRad)				eMasses[i] =  1 / (Math.pow(radiusParallel , 2) / moments[i] + 1 / masses[i])				var vBig = velocities[i]				var vSpin = VectorMath3D.crossMultiply3D([0,0,omegas[i]], [unitAlong[0] *radiusParallel,unitAlong[1]*radiusParallel,0])				vPerps[i] = VectorMath2D.dotMultiply2D([vBig[0] + vSpin[0],vBig[1] + vSpin[1]],unitPerp)							}											var vCom = (vPerps[0]*eMasses[0] + vPerps[1]*eMasses[1])/(eMasses[0] + eMasses[1])			var vIns = [vPerps[0] - vCom, vPerps[1] - vCom]			var vOuts = [0,0]			var magImpulse1 = (vOuts[0] - vIns[0]) * eMasses[0]			var magImpulse2 = (vOuts[1] - vIns[1]) * eMasses[1]			var impulse1 = [magImpulse1 * unitPerp[0],magImpulse1 * unitPerp[1]]			var impulse2 = [magImpulse2 * unitPerp[0],magImpulse2 * unitPerp[1]]			return([impulse1,impulse2])				}				public static function inelasticSimple(masses:Array,velocities:Array,units:Array):Array{			var vPerps = new Array(2)			var unitAlong = [units[0],units[1]]			var unitPerp = [units[2],units[3]]						for( var i = 0; i < 2 ; i++ ){				var vBig = velocities[i]				vPerps[i] = VectorMath2D.dotMultiply2D(vBig,unitPerp)			}											var vCom = (vPerps[0]*masses[0] + vPerps[1]*masses[1])/(masses[0] + masses[1])			var vIns = [vPerps[0] - vCom, vPerps[1] - vCom]			var vOuts = [0,0]			var magImpulse1 = (vOuts[0] - vIns[0]) * masses[0]			var magV0 =Math.sqrt(Math.pow( velocities[0][0],2) + Math.pow(velocities[0][1],2))			var magVChange = vIns[0]			var magImpulse2 = (vOuts[1] - vIns[1]) * masses[1]			var impulse1 = [magImpulse1 * unitPerp[0],magImpulse1 * unitPerp[1]]			var impulse2 = [magImpulse2 * unitPerp[0],magImpulse2 * unitPerp[1]]			return([impulse1,impulse2])				}	}}