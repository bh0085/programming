package physics {	import Math	import flash.display.Shape	import math.VectorMath2D		public class PhysEquipotentialLines extends Shape {						public var potential:PhysPotential				public static var deltaVPerLine:Number = 10000		public static var steplength:Number = 10		public static var firststep:Number = 35 		public static var numsteps:Number =25		public var seg0xs:Array		public var seg1xs:Array		public var seg0ys:Array		public var seg1ys:Array				public function PhysEquipotentialLines(system:PhysPotential){//Create a physFieldLines object associated with a particular field			potential = system			clearSegments()		}						public function clearSegments():void{			seg0xs = new Array()			seg1xs = new Array()			seg0ys = new Array()			seg1ys = new Array()		}				public function addSegment(seg0:Array,seg1:Array):void{			seg0xs.push(seg0[0])			seg1xs.push(seg1[0])			seg0ys.push(seg0[1])			seg1ys.push(seg1[1])		}		public function redrawLines():void{			clearLines()			for(var i:Number = 0 ;  i < seg0xs.length ; i++){				var seg0 = [seg0xs[i], seg0ys[i]]				var seg1 = [seg1xs[i], seg1ys[i]]				linesAlongSegment( seg0,seg1, 5)			}		}				public function lineAtPoint(xat:Number,yat:Number){			//Draws lines around the object specified for this field									var currx:Number = xat			var curry:Number = yat			var gradient:Array			var gradMag:Number			var gradientUnit:Array			var unitPar:Array								graphics.lineStyle(1)			graphics.moveTo(currx,curry)			for ( var i:Number = 0 ; i < numsteps ; i ++) {				 gradient = VectorMath2D.gradientAt(potential,currx,curry)				 gradMag = VectorMath2D.length(gradient)				 gradientUnit = [gradient[0]/gradMag,gradient[1]/gradMag]				 unitPar = [ -1 * gradientUnit[1],  gradientUnit[0]]				 currx += steplength * unitPar[0]				 curry += steplength * unitPar[1]				 graphics.lineTo(currx,curry)			}			currx = xat			curry = yat			graphics.moveTo(currx,curry)			for (i = 0 ; i < numsteps ; i++ ) {				 gradient = VectorMath2D.gradientAt(potential,currx,curry)				 gradMag = VectorMath2D.length(gradient)				 gradientUnit = [gradient[0]/gradMag,gradient[1]/gradMag]				 unitPar = [ gradientUnit[1], -1 * gradientUnit[0]]					 currx += steplength * unitPar[0]				 curry += steplength * unitPar[1]				 graphics.lineTo(currx,curry)			}		}						var resamplingDistance:Number = 10					public function linesAlongSegment(seg0:Array,seg1:Array, ... args) {					var unitAlongSeg:Array = [seg1[0] - seg0[0], seg1[1] - seg0[1]]			var totalDistance = VectorMath2D.length([seg1[0] - seg0[0],seg1[1] - seg0[1]])			unitAlongSeg = [unitAlongSeg[0]/totalDistance,unitAlongSeg[1]/totalDistance]//Args contains the total number of equipotential lines to draw along the segment									if (args.length != 0) {				var potentialChange:Number =potential.valueAt(seg1[0],seg1[1]) - potential.valueAt(seg0[0],seg0[1])				deltaVPerLine = potentialChange / args[0]			}						var gradient:Array			var gradAlong:Number			var distNext:Number			var currx:Number			var curry:Number			graphics.moveTo(seg0[0],seg0[1])			currx = seg0[0]			curry = seg0[1]			var drawMore:Boolean = true			var distanceSoFar:Number = 0				var xSample:Number 				var ySample:Number 				var distanceFromResample:Number				var sampleMore:Boolean			var i:Number = 0			while(drawMore){				sampleMore = true				i++				//trace(drawMore)				gradient = VectorMath2D.gradientAt(potential,currx,curry)				gradAlong = Math.abs(VectorMath2D.dotMultiply2D(unitAlongSeg, gradient))				distNext = deltaVPerLine/gradAlong								var j:Number = 0				if (distNext > resamplingDistance) { 				xSample = currx				ySample = curry				while(sampleMore){				j++				xSample += unitAlongSeg[0] * resamplingDistance				ySample += unitAlongSeg[1] * resamplingDistance				gradient = VectorMath2D.gradientAt(potential,xSample,ySample)				gradAlong = Math.abs(VectorMath2D.dotMultiply2D(unitAlongSeg, gradient))				distanceFromResample = deltaVPerLine/gradAlong - (j*resamplingDistance)				if (distanceFromResample < resamplingDistance){sampleMore = false}				}				distNext = j * resamplingDistance - distanceFromResample				}								//trace(distNext)								distanceSoFar += distNext				//trace(unitAlongSeg[0] * distNext)				graphics.moveTo(currx,curry) 				currx += unitAlongSeg[0] * distNext				curry += unitAlongSeg[1] * distNext				graphics.lineTo(currx,curry)				lineAtPoint(currx,curry)				if (distanceSoFar >= totalDistance) {drawMore = false}				if (i>20) {drawMore = false}				//trace(distanceSoFar)				//trace(totalDistance)															}		}						public function clearLines(){			//Clears all lines...			graphics.clear()		}					}}