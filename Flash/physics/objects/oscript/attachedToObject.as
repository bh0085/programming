package physics.objects.oscript{	import physics.twobody.TwoBodyCollision	import physics.PhysUniverse	import physics.objects.PhysObject	import flash.geom.Rectangle	import math.graphs.MovingGraph	import flash.display.Sprite	import flash.display.Shape	import flash.display.BitmapData	import flash.display.Bitmap	import flash.geom.Matrix		import math.VectorMath2D	import math.VectorMath3D	import flash.utils.getTimer	import paths.Node	import paths.CtdOutline	import tanks.TankSuper			public class attachedToObject extends ObjectScript{				public static var s:Shape				public var objAttachedTo		public var nodesAttached		public var bindingForceConstant = 1		var kOut = 10, kIn = 5, kOn = .05				var bindingMaxDistance = 20		var bindingMaxForceConstant = 3		var bindingMaxVelocity = 800					public var surfaceUnits:Array		public var surfacePoints:Array			public var sfcPtAvg:Array		public var sfcUnitsAvg:Array				public var isInside = false		public var wasInside:Boolean					public var mGraph:MovingGraph				public var ptsGrabbedLocal = new Array()		public var stickSlideBounce = 0		public var ptStuckFast = true				public function friction():void{			thisObject.dampen([.8,.8,1])		}		public function testDetach():Boolean{			var d = false			if(thisObject.mustDetach()){				d = true				thisObject.setDetachPronto(false)			}			return d		}		public function detach():void{				thisObject.constraint = null				scriptDone = true				spawnDetached()		}			override public function advance(...args):void{			if(objAttachedTo.isDestroyed){				detach()				return			}						var step = args[0]			if(step == 0 || step == 1){				if(testDetach()){					thisObject.constraint = null					detach()				}			}			if(step == 2&& !scriptDone) {				thisObject.constraint = [objAttachedTo.thisOutline.outline, nodesAttached[0]]				var outlines = [thisObject.thisOutline.outline, objAttachedTo.thisOutline.outline]				var objs = [thisObject,objAttachedTo]															if(stickSlideBounce == 0){					if(ptsGrabbedLocal.length == 0){						var extra = new Array()						var time =  CtdOutline.getDeepestPair(outlines[0],outlines[1],extra)							var depth = extra[1]						path = extra[3]								var bestPair = extra[0]						var v1 = objs[0].getVel(bestPair[0])						var v2 = objs[1].getVel(bestPair[1])						var vToSfc = [bestPair[1][0] - bestPair[0][0],bestPair[1][1] - bestPair[0][1]]						var mToSfc = Math.sqrt(Math.pow(vToSfc[0],2) + Math.pow(vToSfc[1],2))						var uToSfc = [vToSfc[0] / mToSfc, vToSfc[1] / mToSfc]												var d1 = VectorMath2D.dotMultiply2D(v1,uToSfc)						var d2 = VectorMath2D.dotMultiply2D(v2,uToSfc)						var netVIn = d2 - d1						if(netVIn <0){trace(netVIn,"motion out") ; return}						var t = mToSfc / netVIn																	var bPLocal = [objs[0].localCoords(bestPair[0]),objs[1].localCoords(bestPair[1])]						ptsGrabbedLocal.push(bPLocal)							objs[0].timeTravel(-t)						objs[1].timeTravel(-t)						timeIn += t						var lastExtra = extra						var bPFinal = [objs[0].externalCoords(bPLocal[0]),objs[1].externalCoords(bPLocal[1])]						var vecToSfc = [bPFinal[1][0] - bPFinal[0][0],bPFinal[1][1] - bPFinal[0][1]]						var magToSfc = Math.sqrt(Math.pow(vecToSfc[0],2) + Math.pow(vecToSfc[1],2))						var unitToSfc =[vecToSfc[0] / magToSfc, vecToSfc[1] / magToSfc]														thisObject.haltPt(bPFinal[0])						thisObject.applyForces()						objs[0].timeTravel(t)						objs[1].timeTravel(t)						} else {						var pairGrabbedExt = [objs[0].externalCoords(ptsGrabbedLocal[0][0]), objs[1].externalCoords(ptsGrabbedLocal[0][1])]						var closestNodeOnSurface =objs[1].thisOutline.outline.closest(pairGrabbedExt[0])						var closestPtOnSurface = closestNodeOnSurface.ptBitClosest(closestNodeOnSurface.thisCtdOutline.localCoords(pairGrabbedExt[0]),true)						var vecToClosestPt = [closestPtOnSurface[0] - pairGrabbedExt[0][0], closestPtOnSurface[1] - pairGrabbedExt[0][1]]						var closestSurfaceUnits= closestNodeOnSurface.getUnitsExt(true)						var surfaceOut = [closestSurfaceUnits[2],closestSurfaceUnits[3]]						var distIn = VectorMath2D.dotMultiply2D(surfaceOut, vecToClosestPt)						var ptUnstuck = false						if(distIn < 0 ){trace("stuck Point is outside", vecToClosestPt),ptUnstuck = true} else {trace("inside")}						if(!ptUnstuck){																													   							var vecToOldSurfacePoint = [pairGrabbedExt[1][0] - pairGrabbedExt[0][0], pairGrabbedExt[1][1] - pairGrabbedExt[0][1]]							var mag = Math.sqrt(Math.pow(vecToOldSurfacePoint[0],2) + Math.pow(vecToOldSurfacePoint[1],2))							var uToSfc = [vecToOldSurfacePoint[0] /mag, vecToOldSurfacePoint[1] / mag]							var v1 = objs[0].getVel(pairGrabbedExt[0])							var v2 = objs[1].getVel(pairGrabbedExt[1])							var d1 = VectorMath2D.dotMultiply2D(v1,uToSfc)							var d2 = VectorMath2D.dotMultiply2D(v2,uToSfc)							var netVIn = d2 - d1							if(netVIn > 0){								thisObject.timeTravel(-PhysUniverse.timestep)								var objPtFinalExt = objs[0].externalCoords(ptsGrabbedLocal[0][0])								thisObject.haltPt(objPtFinalExt)								thisObject.applyForces()								thisObject.timeTravel(PhysUniverse.timestep)							}						}					}									}																				if(lastExtra != null){					var path = lastExtra[3]									/*					if(timeIn <= .5){						var bplocal = thisObject.localCoords(bestPair[0])						var bpext = thisObject.externalCoords(bplocal)						var units = objAttachedTo.thisOutline.outline.closest(bpext).getUnitsExt(false)						var impulses = TwoBodyCollision.onePtInelasticObjs([thisObject,objAttachedTo],bpext,[units[2],units[3]])						for(var i = 0 ; i< 2 ; i++){							objs[i].timeTravel(-1*timeIn)						}						var impulses = TwoBodyCollision.onePtInelasticObjs([thisObject,objAttachedTo],bpext,[units[2],units[3]])						for(var i = 0 ; i < 2 ; i++){														var obj = objs[i]							obj.exertImpulseAt(impulses[i],bpext)							obj.applyForces()							obj.timeTravel(timeIn)						}					} else {						var outlineEdgesPair = extra[2]						var vec = [outlineEdgesPair[1][0] - outlineEdgesPair[0][0],outlineEdgesPair[1][1] - outlineEdgesPair[0][1]]												var magAcross = Math.sqrt(Math.pow(vec[0],2) + Math.pow(vec[1],2))						var unitAlong = [vec[0] / magAcross , vec[1] / magAcross]						var magPerp = extra[1]						trace(magPerp,magAcross)						if(magPerp/magAcross > .2){							trace("one")							var oPtLocal = thisObject.localCoords(bestPair[0])							for(var i = 0 ; i < 2 ; i++){objs[i].timeTravel(-.05)}							var ptExtAfterMove = thisObject.externalCoords(oPtLocal)							var unitsOfAttached = objs[1].thisOutline.outline.closest(ptExtAfterMove).getUnitsExt(false)							var unitOut = [unitsOfAttached[2],unitsOfAttached[3]]							var pt = ptExtAfterMove							var impulses = TwoBodyCollision.onePtInelasticObjs(objs,pt,unitOut)							for(var i = 0 ; i < 2 ; i++){								objs[i].exertImpulseAt(impulses[i],pt)								objs[i].applyForces()								objs[i].timeTravel(.05)							}						} else {							trace("two")							var pts = outlineEdgesPair							var uOA1 = objs[1].thisOutline.outline.closest(outlineEdgesPair[0]).getUnitsExt(false)							var uOA2 = objs[1].thisOutline.outline.closest(outlineEdgesPair[0]).getUnitsExt(false)							var unitsOut= [[uOA1[2],uOA1[3]],[uOA1[2],uOA1[3]]]							var impulses = TwoBodyCollision.twoPtInelasticObjs(objs,pts,unitsOut)							thisObject.exertImpulseAt(impulses[0],pts[0])							thisObject.exertImpulseAt(impulses[1],pts[1])							objAttachedTo.exertImpulseAt([-impulses[0][0],-impulses[0][1]],pts[0])							objAttachedTo.exertImpulseAt([-impulses[1][0],-impulses[1][1]],pts[1])							for(var i = 0 ; i < 2 ; i++){								objs[i].applyForces()							}						}					}*/				}				var extra = new Array()				var timeIn = CtdOutline.getDeepestPair(outlines[0],outlines[1],extra)						var t1 = timeIn				var bestPair = extra[0]				var depth2 = extra[1]				//trace(depth1,depth2)				//if(t0 > .045){trace("stuck")}				if(bestPair != null){					var bplocal = thisObject.localCoords(bestPair[0])					//thisObject.timeTravel(-1 * timeIn)					//objAttachedTo.timeTravel(-1* timeIn)					var bpext = thisObject.externalCoords(bplocal)					var units = objAttachedTo.thisOutline.outline.closest(bpext).getUnitsExt(false)					//var impulses = TwoBodyCollision.onePtInelasticObjs([thisObject,objAttachedTo],bpext,[units[2],units[3]])					//thisObject.applyForces()					//thisObject.timeTravel(timeIn/3)				}			}		}		public function spawnDetached():void{			var newScript = new detachFromObj()			newScript.setAttachedTo(objAttachedTo)			thisObject.addObjectScript(newScript)		}		public function setAttachedTo(obj:PhysObject):void{			objAttachedTo = obj			multiPriorities = true		}		public function setWhichAttached(nodes:Array):void{			nodesAttached = nodes		}			}}