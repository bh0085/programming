package physics.objects.oscript{	import physics.objects.PhysObject	import physics.PhysUniverse	import math.VectorMath2D	import math.VectorMath3D		public class bounceOffObj extends ObjectScript{						public var objAttachedTo		public var nodesAttached		public var surfaceNodes:Array				public var surfaceUnits:Array		public var surfacePoints:Array			public var sfcPtAvg:Array		public var sfcUnitsAvg:Array				public var nodeBounced = null									override public function advance(...args):void{					thisObject.cancelAppliedForces()					thisObject.sleep()					if(frame ==1){						 surfacePoints = new Array()						 surfaceUnits = new Array()						 surfaceNodes = new Array()						 sfcPtAvg = [0,0]						 sfcUnitsAvg = [0,0,0,0]						for(var i = 0; i < nodesAttached.length ; i ++){							var outline = objAttachedTo.thisOutline.outline							var pt = nodesAttached[i].thisCtdOutline.nodeExternalCoords(nodesAttached[i])														var surfaceBit = outline.closest(pt)							surfaceNodes.push(surfaceBit)							var localXY = outline.localCoords(pt)							var sfcXY = surfaceBit.ptBitClosest(localXY,true) 							surfacePoints.push(sfcXY)							sfcPtAvg[0] += sfcXY[0]/nodesAttached.length							sfcPtAvg[1] += sfcXY[1]/nodesAttached.length							var sfcUnits = outline.getUnits(surfaceBit)								surfaceUnits.push(sfcUnits)							sfcUnitsAvg = [sfcUnitsAvg[0] + sfcUnits[0],sfcUnitsAvg[1] +sfcUnits[1], sfcUnitsAvg[2] + sfcUnits[2],sfcUnitsAvg[3] + sfcUnits[3]]							}						var sfcMag1 = Math.sqrt(Math.pow(sfcUnitsAvg[0], 2) + Math.pow(sfcUnitsAvg[1],2))						sfcUnitsAvg = [sfcUnitsAvg[0] / sfcMag1, sfcUnitsAvg[1]/sfcMag1,-sfcUnitsAvg[1]/sfcMag1,sfcUnitsAvg[0]/sfcMag1]						exertImpulses()					}					var objUnit = thisObject.unitUp()					var objAngle = Math.asin(objUnit[1])					if(objUnit[0] < 0){ objAngle = Math.PI - objAngle }										var sfcUnit = [sfcUnitsAvg[2],sfcUnitsAvg[3]]					var sfcAngle = Math.asin(sfcUnit[1])					if(sfcUnit[0] < 0){ sfcAngle = Math.PI - sfcAngle }															var angleDelta = sfcAngle - objAngle					if(isFinite(angleDelta) && !isNaN(angleDelta)){						var search = true							 while( search ){								if(angleDelta < -1 * Math.PI) { angleDelta += Math.PI * 2 }								if(angleDelta > Math.PI) {angleDelta -= Math.PI*2 }								if(Math.abs(angleDelta) <= Math.PI) {search = false}							}					thisObject.dampen([.8,.8,.4])					thisObject.exertTorqueImpulseOn([0,0,thisObject.getMomentOfInertia() * angleDelta * 5])													}									if(frame == 5){						thisObject.dampen([.8,.8,.4])						scriptDone = true						thisObject.wake()					}												}		public function exertImpulses():void{			var xy1 = nodesAttached[0].thisCtdOutline.nodeExternalCoords(nodesAttached[0])			var xy2 = surfaceNodes[0].thisCtdOutline.nodeExternalCoords(surfaceNodes[0])						var obj1 = thisObject			var obj2 = objAttachedTo			var rChild1 = [xy1[0] - obj1.getCOMX(), xy1[1] - obj1.getCOMY()]			var rChild2 = [xy2[0] - obj2.getCOMX(), xy2[1] - obj2.getCOMY()]						var units = sfcUnitsAvg						var altitude =surfaceNodes[0].ptBitAltitude(objAttachedTo.thisOutline.outline.localCoords(xy1))			var dot = math.VectorMath2D.dotMultiply2D([surfaceUnits[0][2] , surfaceUnits[0][3]], altitude)			if(dot <0){obj1.moveBy([-altitude[0],-altitude[1]])}						var unitPar = [units[0],units[1]];			var unitPerp= [units[2],units[3]];								var eMasses = new Array(2)			var vPerps  = new Array(2)								var vParent:Array, vChild:Array, vPerp:Number			var distanceParalellToWall:Number						if(nodeBounced != nodesAttached[0] ){				for( var i:Number = 0; i < 2 ; i++ ){									if(i ==0) {var object = obj1; var xy = xy1; var rChild = rChild1} else { object = obj2 ; xy = xy2; rChild = rChild2}						distanceParalellToWall = VectorMath2D.dotMultiply2D(unitPar,rChild);						eMasses[i] = 1 / (Math.pow(distanceParalellToWall , 2) / object.getMomentOfInertia() + 1 / object.getMass());						vParent = object.getVel();						vChild  = VectorMath3D.crossMultiply3D([0,0,object.getOmega()], [unitPar[0] *distanceParalellToWall,unitPar[1]*distanceParalellToWall,0]);						vPerp   = VectorMath2D.dotMultiply2D([vParent[0] + vChild[0],vParent[1] + vChild[1]],unitPerp)						vPerps[i] = vPerp										}												var vCom = (vPerps[0]*eMasses[0] + vPerps[1]*eMasses[1])/(eMasses[0] + eMasses[1])				var vIns = [vPerps[0] - vCom, vPerps[1] - vCom]				var energyIn = .5 * eMasses[0]*Math.pow(vIns[0],2)+ .5 * eMasses[1]*Math.pow(vIns[1],2)				var magVOuts = new Array(2)				magVOuts[0] = Math.sqrt(energyIn * 2 * eMasses[1]/eMasses[0] * 1/(eMasses[0] + eMasses[1]))				magVOuts[1] = Math.sqrt(energyIn * 2 * eMasses[0]/eMasses[1] * 1/(eMasses[0] + eMasses[1]))				var vOuts = new Array(2)				if(vIns[0] < 0){					vOuts[0] = magVOuts[0]					vOuts[1] = magVOuts[1] * -1				} else {					vOuts[0] = magVOuts[0] * -1					vOuts[1] = magVOuts[1] 				}				var impulse1 = (vOuts[0] - vIns[0]) * eMasses[0]				var impulse2 = (vOuts[1] - vIns[1]) * eMasses[1]								var i1 = [impulse1 * unitPerp[0],impulse1 * unitPerp[1]]				var i2 = [impulse2 * unitPerp[0],impulse2 * unitPerp[1]]				obj1.exertImpulseAt(i1,xy1)				nodeBounced = nodesAttached[0]							}			}		public function setAttachedTo(obj:PhysObject):void{			objAttachedTo = obj			setPriority(2)		}		public function setWhichAttached(nodes:Array):void{			nodesAttached = nodes		}			}}