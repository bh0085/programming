package physics.objects.oscript{	import physics.PhysObject		public class bounceOffObj extends ObjectScript{				public static var s:Shape				public var objAttachedTo		public var nodesAttached				public var surfaceUnits:Array		public var surfacePoints:Array			public var sfcPtAvg:Array		public var sfcUnitsAvg:Array									override public function advance():void{										 surfacePoints = new Array()					 surfaceUnits = new Array()					 sfcPtAvg = [0,0]					 sfcUnitsAvg = [0,0,0,0]					for(var i = 0; i < nodesAttached.length ; i ++){						var outline = objAttachedTo.thisOutline.outline						var pt = nodesAttached[i].thisCtdOutline.nodeExternalCoords(nodesAttached[i])												var surfaceBit = outline.closest(pt)						var localXY = outline.localCoords(pt)						var sfcXY = surfaceBit.ptBitClosest(localXY,true) 						surfacePoints.push(sfcXY)						sfcPtAvg[0] += sfcXY[0]/nodesAttached.length						sfcPtAvg[1] += sfcXY[1]/nodesAttached.length						var sfcUnits = outline.getUnits(surfaceBit)							surfaceUnits.push(sfcUnits)						sfcUnitsAvg = [sfcUnitsAvg[0] + sfcUnits[0],sfcUnitsAvg[1] +sfcUnits[1], sfcUnitsAvg[2] + sfcUnits[2],sfcUnitsAvg[3] + sfcUnits[3]]					}					var sfcMag1 = Math.sqrt(Math.pow(sfcUnitsAvg[0], 2) + Math.pow(sfcUnitsAvg[1],2))					sfcUnitsAvg = [sfcUnitsAvg[0] / sfcMag1, sfcUnitsAvg[1]/sfcMag1,-sfcUnitsAvg[1]/sfcMag1,sfcUnitsAvg[0]/sfcMag1]					exertImpulses()					scriptDone = true												}		public function exertImpulses():void{									var obj1 = thisObject			var obj2 = objAttachedTo			var units = sfcUnitsAvg						var unitPar = [units[0],units[1]];			var unitPerp= [units[2],units[3]];								var object:PhysObject			var eMasses = new Array(2)			var vPerps  = new Array(2)			var rChild:Array								var vParent:Array, vChild:Array, vPerp:Number			var distanceParalellToWall:Number						if(obj1.getNumCollisions(obj2.getUniverseIndex()) == 0){						for( var i:Number = 0; i < 2 ; i++ ){							if(i ==0) {object = obj1} else { object = obj2}					rChild = object.comRadius();						if (rChild != null){						distanceParalellToWall = VectorMath2D.dotMultiply2D(unitPar,rChild);						eMasses[i] = 1 / (Math.pow(distanceParalellToWall , 2) / object.childOf.momentOfInertia + 1 / object.childOf.mass);								vParent = object.childOf.velocity();						vChild  = VectorMath3D.crossMultiply3D([0,0,object.childOf.omega], [unitPar[0] *distanceParalellToWall,unitPar[1]*distanceParalellToWall,0]);						vPerp   = VectorMath2D.dotMultiply2D([vParent[0] + vChild[0],vParent[1] + vChild[1]],unitPerp)						vPerps[i] = vPerp												} else {						eMasses[i] = object.mass						vChild = object.velocity()						vPerp   = VectorMath2D.dotMultiply2D(vChild,unitPerp)						vPerps[i]=vPerp					}				}												var vCom = (vPerps[0]*eMasses[0] + vPerps[1]*eMasses[1])/(eMasses[0] + eMasses[1])				var vIns = [vPerps[0] - vCom, vPerps[1] - vCom]				var energyIn = .5 * eMasses[0]*Math.pow(vIns[0],2)+ .5 * eMasses[1]*Math.pow(vIns[1],2)				var magVOuts = new Array(2)				magVOuts[0] = Math.sqrt(energyIn * 2 * eMasses[1]/eMasses[0] * 1/(eMasses[0] + eMasses[1]))				magVOuts[1] = Math.sqrt(energyIn * 2 * eMasses[0]/eMasses[1] * 1/(eMasses[0] + eMasses[1]))				var vOuts = new Array(2)				if(vIns[0] < 0){					vOuts[0] = magVOuts[0]					vOuts[1] = magVOuts[1] * -1				} else {					vOuts[0] = magVOuts[0] * -1					vOuts[1] = magVOuts[1] 				}				var impulse1 = (vOuts[0] - vIns[0]) * eMasses[0]				var impulse2 = (vOuts[1] - vIns[1]) * eMasses[1]				obj1.exertImpulseOn([impulse1 * unitPerp[0],impulse1 * unitPerp[1]])				obj2.exertImpulseOn([impulse2 * unitPerp[0],impulse2 * unitPerp[1]])			}			}		public function setAttachedTo(obj:PhysObject):void{			objAttachedTo = obj			setPriority(1)		}		public function setWhichAttached(nodes:Array):void{			nodesAttached = nodes		}			}}