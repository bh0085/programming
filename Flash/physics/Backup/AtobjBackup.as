package physics.objects.oscript{	import physics.PhysUniverse	import physics.PhysObject	import mygraphics.PtObj	import mygraphics.ObjObj		import flash.geom.Rectangle	import flash.display.Sprite	import flash.display.BitmapData	import flash.display.Bitmap	import flash.geom.Matrix	import flash.display.Shape		import flash.utils.getQualifiedClassName	import paths.Path2D	import math.VectorMath2D			public class attachToObj extends ObjectScript{		public var surfacePath = new Path2D()		public static var AttachingSprite				public var objAttachedTo		public var objsAttached		public var bindingForceConstant = 1		public static var pathSprite:Sprite				override public function beginScript():void{			var testAttached = new attachedToObject()			var num = 0			for ( var i = 0 ; i< thisObject.scripts.length ; i ++)				{					var className = flash.utils.getQualifiedClassName(thisObject.scripts[i]);					if (className == flash.utils.getQualifiedClassName(testAttached)){num++ }				}			if(num >0) { scriptDone = true } else {				thisObject.attach(objAttachedTo)			}		}				override public function advance():void{			thisObject.attach(objAttachedTo)			thisObject.sleep()						if(frame == 1){				for(var j = 0; j< objsAttached.length; j++){					objsAttached[j].setSurfaceUnits(null)					objsAttached[j].setSurfacePoint(null)					objsAttached[j].setIsInsideSurface(false)				}			}			setSurfacePointGuesses()			getSetUnits()			var surfaceSegment = objAttachedTo.compoundPath.closestSegmentToPt([thisObject.getX(),thisObject.getY()])			var surfaceUnits = objAttachedTo.compoundPath.myPaths[surfaceSegment[0]].getUnits(surfaceSegment[1])			var sP = objAttachedTo.compoundPath.myPaths[surfaceSegment[0]].getClosestPointOnSegment([thisObject.getX(),thisObject.getY()],surfaceSegment[1])									if(sP!=null){				if(frame ==1){					thisObject.moveTo(sP)				}			}			if(frame == 1){				if(sP != null){					thisObject.dampen([0,0,0])					thisObject.cancelAppliedForces()					thisObject.cancelAppliedTorques()				}			}						var unitUp  = thisObject.unitUp()			var unitAngle=Math.asin(unitUp[1])			if((unitUp[0]) < 0){unitAngle = Math.PI - unitAngle}									if(surfaceUnits != null){				var surfaceUp = [surfaceUnits[2],surfaceUnits[3]]				var surfaceAngle=Math.asin(surfaceUp[1])				if((surfaceUp[0]) < 0){surfaceAngle = Math.PI - surfaceAngle}								var angleDelta = surfaceAngle - unitAngle				if(isFinite(angleDelta) && !isNaN(angleDelta)){					var search = true					while( search ){						if(angleDelta < -1 * Math.PI) { angleDelta += Math.PI * 2 }						if(angleDelta > Math.PI) {angleDelta -= Math.PI*2 }						if(Math.abs(angleDelta) < Math.PI) {search = false}					}					thisObject.dampen([.5,.5,.3])					thisObject.exertTorqueImpulseOn([0,0,angleDelta * thisObject.momentOfInertia / PhysUniverse.timestep ])								}			}						if(frame ==20){				var newScript = new attachedToObject()				newScript.setAttachedTo(objAttachedTo)				newScript.setWhichAttached(objsAttached)				thisObject.addObjectScript(newScript, true)				scriptDone = true			}		}				public function setSurfacePointGuesses():void{						for(var j = 0; j<objsAttached.length ; j++){				var deltaXY = [objsAttached[j].thisXY[0] - objsAttached[j].lastXY[0], objsAttached[j].thisXY[1]  - objsAttached[j].lastXY[1]]				var sP = objsAttached[j].getSurfacePoint() 				if(sP != null){					var sPGuessPoint = [sP[0] + deltaXY[0],sP[1] + deltaXY[1]]					var searchWidth =  Math.sqrt(Math.pow(deltaXY[0],2) + Math.pow(deltaXY[1],2)) + 10					var sPGuessRect = new Rectangle(sPGuessPoint[0] - searchWidth/2,sPGuessPoint[1] - searchWidth/2,searchWidth,searchWidth)				} else {sPGuessRect = null}				objsAttached[j].setSurfacePointSearchRectangle(sPGuessRect)			}		}				public function calcDerivs(pts:Array){			var deltas=new Array()			var unitDeltas =new Array()			var deltaSum = [0,0]			var lp = pts.length			for (var i = 0; i < (lp - 1); i++){				var delta = [pts[i+1][0] - pts[i][0],pts[i+1][1] - pts[i][1]]				var magDelta = Math.sqrt(Math.pow(delta[0],2) + Math.pow(delta[1],2))				if(magDelta >0){					deltas.push(delta)					unitDeltas.push([delta[0]/magDelta,delta[1]/magDelta])																	 				}			}			var netDelta = [pts[lp - 1][0] - pts[0][0] , pts[lp - 1][1] - pts[0][1]]			var magNetDelta = Math.sqrt(Math.pow(netDelta[0],2) + Math.pow(netDelta[1],2))			var unitNetDelta = [netDelta[0]/ magNetDelta, netDelta[1]/magNetDelta]						var delta2s = new Array			var unitDelta2s = new Array			var ld = deltas.length			for( i = 0; i < (ld - 1); i++) {				var delta2 = [unitDeltas[i+1][0] - unitDeltas[i][0],unitDeltas[i+1][1] - unitDeltas[i][1]]				var magDelta2 = Math.sqrt(Math.pow(delta2[0],2) + Math.pow(delta2[1],2))				if(magDelta2 > 0){					delta2s.push(delta2)					unitDelta2s.push([delta2[0]/magDelta2,delta2[1]/magDelta2])							}			}						var ld2 =delta2s.length			var netDelta2= [unitDeltas[ld - 1][0] - unitDeltas[0][0], unitDeltas[ld - 1][1] - unitDeltas[0][1]]			var delta2PerDistance = [netDelta2[0]/magNetDelta, netDelta2[1]/magNetDelta]			var magNetDelta2 = Math.sqrt(Math.pow(netDelta2[0],2) + Math.pow(netDelta2[1],2))			var unitNetDelta2 = [netDelta2[0]/ magNetDelta2, netDelta2[1]/magNetDelta2]						return [[netDelta,unitNetDelta], [delta2PerDistance,unitNetDelta2]]		}				public function getSetUnits():void{				var out:Array				for(var j = 0; j< objsAttached.length; j++){											var thisXY = [objsAttached[j].getX(),objsAttached[j].getY()]					var attachedXY = [objAttachedTo.getX(),objAttachedTo.getY()]					if(objAttachedTo.compoundPath.hasPaths()){						var surfaceSegment = objAttachedTo.compoundPath.closestSegmentToPt(thisXY)						var surfaceUnits = objAttachedTo.compoundPath.myPaths[surfaceSegment[0]].getUnits(surfaceSegment[1])						var sP = objAttachedTo.compoundPath.myPaths[surfaceSegment[0]].getClosestPointOnSegment([thisObject.getX(),thisObject.getY()],surfaceSegment[1])														var delta = [thisXY[0] - sP[0], thisXY[1] - sP[1]]						var dist = Math.sqrt(Math.pow(delta[0], 2 ) + Math.pow(delta[1], 2))						if(dist < 75){							var rectDim =Math.ceil( dist * 1.5 )							var thisSearchRectangle = new Rectangle(Math.floor( sP[0] + delta[0] / 2 - rectDim/2 ),Math.floor( sP[1] + delta[1] / 2 - rectDim/2), rectDim, rectDim)						} else {							thisSearchRectangle = null						}					} else { thisSearchRectangle = null}					out = ObjObj.vectorsToIntersectionWithUnits(thisXY,objsAttached[j].graphic,attachedXY,objAttachedTo.graphic,thisObject.thisUniverse,thisSearchRectangle)										if(out != null){						if(pathSprite != null){							thisObject.thisUniverse.removeChild(pathSprite)							pathSprite = new Sprite()						}												var ptsX = new Array()						var ptsY = new Array()						for( var k = 0; k<out[4].length; k++){							ptsX.push(out[4][k][0])							ptsY.push(out[4][k][1])						}												var tempPath = new Path2D()						tempPath.pushPts(ptsX,ptsY)						var tempOut = tempPath.firstGuessOutPosOrientation()						var surfaceOut =[out[1][2],out[1][3]]						if(VectorMath2D.dotMultiply2D(tempOut,surfaceOut) > 0){							tempPath.pushOrientation(+5)						} else {							tempPath.pushOrientation(-5)						}												objAttachedTo.compoundPath.setMergeDistance(10)						objAttachedTo.pushPath(tempPath)						objAttachedTo.cleanPath()												pathSprite = objAttachedTo.compoundPath.toSprite()						thisObject.thisUniverse.addChild(pathSprite)																		objsAttached[j].setSurfaceUnits(out[1])						objsAttached[j].setSurfacePoint(out[0])						objsAttached[j].setIsInsideSurface(out[2])						objsAttached[j].setSeveralSurfacePoints(out[4])						var derivs = calcDerivs(out[4])						objsAttached[j].setSurfaceSecondDerivative(derivs[1][0])					} else {						objsAttached[j].setSurfaceUnits(null)						objsAttached[j].setSurfacePoint(null)						objsAttached[j].setIsInsideSurface(false)						objsAttached[j].setSeveralSurfacePoints(null)						objsAttached[j].setSurfaceSecondDerivative(null)					}									}				if(objsAttached.length >1){					var numAvg = 0					var thisUnits:Array,thisSfcPt:Array,thisCOMRadius:Array, comParalell:Array, comDot:Number,thisSecondDerivative:Array					var avgUnits =[0,0,0,0],avgSfcPt = [0,0], avgSfcSecondDerivative = [0,0]					for( j = 0; j< objsAttached.length;j++){						if(objsAttached[j].getSurfaceUnits() != null){							numAvg++							thisUnits = objsAttached[j].getSurfaceUnits()							avgUnits[0] += thisUnits[0]							avgUnits[1] += thisUnits[1]								avgUnits[2] += thisUnits[2]								avgUnits[3] += thisUnits[3]							thisSecondDerivative = objsAttached[j].getSurfaceSecondDerivative()							avgSfcSecondDerivative[0] += thisSecondDerivative[0]							avgSfcSecondDerivative[1] += thisSecondDerivative[1]							thisSfcPt = objsAttached[j].getSurfacePoint()							thisCOMRadius = objsAttached[j].comRadius()							comDot = VectorMath2D.dotMultiply2D(thisCOMRadius, [thisUnits[0],thisUnits[1]])							comParalell = [comDot * thisUnits[0], comDot * thisUnits[1]]																					avgSfcPt[0] += thisSfcPt[0] - comParalell[0]							avgSfcPt[1] += thisSfcPt[1] - comParalell[1]						}					}					if(numAvg != 0){						avgSfcSecondDerivative = [avgSfcSecondDerivative[0] / numAvg,avgSfcSecondDerivative[1]/numAvg]						avgSfcPt = [avgSfcPt[0] / numAvg, avgSfcPt[1]/ numAvg]						avgUnits = [avgUnits[0] / numAvg, avgUnits[1]/ numAvg,avgUnits[2]/numAvg, avgUnits[3]/numAvg]						thisObject.setSurfaceSecondDerivative(avgSfcSecondDerivative)						thisObject.setSurfaceUnits(avgUnits)						thisObject.setSurfacePoint(avgSfcPt)					} else {						//thisObject.setSurfaceUnits(null)						//thisObject.setSurfacePoint(null)						thisObject.setSurfaceRecentlyUpdated(false)					}				}					}		public function setAttachedTo(obj:PhysObject):void{			objAttachedTo = obj			setPriority(1)		}		public function setWhichAttached(objects:Array):void{			objsAttached = objects		}	}}