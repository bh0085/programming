package physics{	import flash.display.Shape	import flash.display.Graphics	import math.VectorMath2D	import math.VectorMath3D	import flash.display.Sprite	import flash.display.DisplayObject		public class PhysWallInelastic extends PhysWall{						//Init args describing the collision physics, friction and rebound....								public var perpboost: Number;		public var parboost: Number;				public var xcoord:Array;		public var ycoord:Array;						public var segments:Array		public var color = 0x000000						public static var expelDistance	 = 5						public function PhysWallInelastic(xs:Array, ys:Array, ... args){						//Args contains the parameters color, perpboost, parboost						if (args.length >= 1) (color = args[0])			xcoord = xs			ycoord = ys						segments = new Array()									for (var i:Number = 0 ; i<xcoord.length - 1 ; i++){				segments.push( new PhysWallSegment([xcoord[i],ycoord[i]],[xcoord[i+1],ycoord[i+1]], color))				addChild(segments[i])   			}						if (args.length <= 1) { perpboost = 1 } else { perpboost = args[1] }			if (args.length <= 2) { parboost  = 1 } else { parboost = args[2] }		}					public function collision(object:PhysObject, ... idxhit ):void{			var minidx:Number			var depthHit:Number			var numHits:Number			if (idxhit.length == 0){ minidx = wallGetClosestSegment(object)} else{ minidx = idxhit[0][0]}							if (idxhit.length == 0){depthHit = 1} else{ depthHit = idxhit[0][1]}						if (idxhit.length < 2) {numHits = 0} else{numHits = idxhit[1]}			var units = wallGetUnits(minidx)			var unitpar = units.slice(0,2)			var unitperp = units.slice(2)											if (object.childOf == null){				var velocity = object.velocity()				var xvel = velocity[0]				var yvel = velocity[1]													var velpar = VectorMath2D.dotMultiply2D(unitpar, [xvel, yvel])				var velperp= VectorMath2D.dotMultiply2D(unitperp,[xvel, yvel])			var impulse = [ object.mass * (-1.2 * unitperp[0] * velperp  - .0 * velpar * unitpar[0] ),  object.mass *(-1.2 * unitperp[1] * velperp - .0 * unitpar[1] * velpar) ,0]			object.exertImpulseOn(impulse)			} 			}					public function complexBodyCollision(parent:PhysObject,... children){		if (children.length == 0) {children = [parent]} else {children = children[0]}		var l = children.length		var hasCollided = new Array(l)		var segmentCollided = new Array(l)		var depthCollided = new Array(l)		var anyCollisions = false				var collision:Array		for (var i = 0; i < l ; i++){			collision = hitTestSegments(children[i])			if (collision[0] == -1 ){ hasCollided[i] = false } else {				hasCollided[i] = true				segmentCollided[i] = collision[0]				depthCollided[i] = collision[1]				anyCollisions = true			}		}		if (anyCollisions) {					parent.dampen(.5)										var radius:Array					var distanceParalellToWall					var equivalentMass					var moment = parent.momentOfInertia					var vPerp:Number					var vChild:Array					var vParent:Array					var units:Array					var unitPar:Array					var unitPerp:Array					var theImpulse:Number										var f:Array					var magF:Number					var fUnitPerp:Array					var fUnitPar:Array					var rChildPerp:Number					var fOnChild:Array					var fOnChildAgainst										var cancelDepth = 20					var k:Number								//This Section Conserves Energy									for (i =0 ; i < l ; i++){				if (hasCollided[i]){					units = wallGetUnits(segmentCollided[i])					unitPar = [units[0],units[1]]					unitPerp= [units[2],units[3]]									radius = children[i].comRadius()					distanceParalellToWall = VectorMath2D.dotMultiply2D(unitPar,radius)					equivalentMass = 1 / (Math.pow(distanceParalellToWall , 2) / moment + 1 / parent.mass)					vParent = parent.velocity()					vChild  = VectorMath3D.crossMultiply3D([0,0,parent.omega], [unitPar[0] *distanceParalellToWall,unitPar[1]*distanceParalellToWall,0])					vPerp   = VectorMath2D.dotMultiply2D([vParent[0] + vChild[0],vParent[1] + vChild[1]],unitPerp)														theImpulse = -1 * 2 * equivalentMass  * (vPerp) 					children[i].exertImpulseOn([theImpulse * unitPerp[0], theImpulse * unitPerp[1]])								//This Section Dampens					k = depthCollided[i]/cancelDepth										f = parent.forceOn()					magF = Math.sqrt(Math.pow(f[0],2) + Math.pow(f[1],2))					fUnitPerp = [ -f[1]/ magF,  f[0]/ magF]					fUnitPar =  [ fUnitPerp[1],-fUnitPerp[0]]					rChildPerp = VectorMath2D.dotMultiply2D(fUnitPerp, radius)					equivalentMass = 1 / (Math.pow(rChildPerp , 2) / moment + 1 / parent.mass)					fOnChild = [magF * equivalentMass/parent.mass * fUnitPar[0], magF * equivalentMass/parent.mass * fUnitPar[1]]										fOnChildAgainst = [-1 * unitPerp[0] * fOnChild[0] * k, -1 * unitPerp[1] * fOnChild[1] * k]					children[i].exertImpulseOn(fOnChildAgainst)									}				}					}												}				public function simpleCollision(parent){		var hasCollided:Boolean		var segmentCollided:Number		var depthCollided:Number				var collision:Array			collision = hitTestSegments(parent)			if (collision[0] == -1 ){ hasCollided = false } else {				hasCollided = true				segmentCollided= collision[0]				depthCollided= collision[1]		}		if (hasCollided) {					parent.dampen(.5)										var vPerp:Number					var vParent:Array					var units:Array					var unitPerp:Array					var theImpulse:Number										var f:Array					var fAgainst:Array					var magF:Number					var fUnitPar:Array										var cancelDepth = 20					var k:Number								//This Section Conserves Energy									if (hasCollided){					units = wallGetUnits(segmentCollided)					unitPerp= [units[2],units[3]]									vParent = parent.velocity()					vPerp   = VectorMath2D.dotMultiply2D([vParent[0],vParent[1]],unitPerp)					theImpulse = -1 * 2 * parent.mass  * (vPerp) 					parent.exertImpulseOn([theImpulse * unitPerp[0], theImpulse * unitPerp[1]])								//This Section Dampens					k = depthCollided/cancelDepth					f = parent.forceOn()										fAgainst = [-1 * unitPerp[0] * f[0] * k, -1 * f[1] * unitPerp[1] * k]					parent.exertImpulseOn(fAgainst)									}							}				}						public function hitTestSegments(obj:PhysObject):Array{			var indexhit = -1			var collisiondepth = 0			for (var i:Number = 0 ; i < segments.length ; i++){				var units = wallGetUnits(i)				var angleNormal = Math.asin(units[3])				if (units[2] < 0) {angleNormal += Math.PI}				var rotateRadians = angleNormal - Math.PI / 2								var intersection = PhysCollisions.physHitTestIrregular(obj.getGraphic(), segments[i],thisUniverse,rotateRadians) 				if ((intersection != null)) {					indexhit = i					collisiondepth = intersection.height}						}			return [indexhit,collisiondepth]		}				public function wallGetUnits(segIdx):Array{						var seg0 = [xcoord[segIdx],ycoord[segIdx]]			var seg1 = [xcoord[segIdx + 1],ycoord[segIdx + 1]]			var sl = Math.sqrt(Math.pow(seg0[0] - seg1[0],2) + Math.pow(seg0[1] - seg1[1],2))			var unitpar = [(seg1[0] - seg0[0]) / sl,  (seg1[1] - seg0[1]) / sl]			var unitperp =[-unitpar[1], unitpar[0]]				return [unitpar[0],unitpar[1],unitperp[0],unitperp[1]]		}						public function wallGetClosestSegment(object:PhysObject):Number{			var mindistance:Number ; var thisdistance:Number ; var minidx:Number			//NOTE AFTER SWITCHING TO PHYSICAL X/Y THIS MAY NOT YET WORK (USED TO USE CONCAT)						var pt = [object.getX(),object.getY()]				for(var i:Number = 0; i <( xcoord.length - 1) ; i++){				    thisdistance = VectorMath2D.ptLineDist(pt,[xcoord[i],ycoord[i]],[xcoord[i+1],ycoord[i+1]])					if (i == 0) { 						 mindistance = thisdistance						 minidx = i					} else { if ( thisdistance < mindistance ) {						mindistance = thisdistance						minidx = i}					}				}				return minidx		}				public function wallGetAltitude(object:PhysObject, segment:Number):Array{//NOTE AFTER SWITCHING TO PHYSICAL X/Y THIS MAY NOT YET WORK (USED TO USE CONCAT)					var pt =[object.getX(),object.getY()]						var thisAltitude = VectorMath2D.ptLineAltitude(pt,[xcoord[segment],ycoord[segment]],[xcoord[segment +1],ycoord[segment +1]])			var altVec = [thisAltitude[2] - thisAltitude[0], thisAltitude[3] - thisAltitude[1]]			return altVec		}				public function wallExpelObject(object:PhysObject):void{			var segment = wallGetClosestSegment(object)						var units = wallGetUnits(segment)			var unitperp = [units[2],units[3]]						if ( VectorMath2D.dotMultiply2D(wallGetAltitude(object,segment),unitperp) < 0 ) {unitperp = [-1 *unitperp[0],-1 * unitperp[1]]}						object.moveBy([unitperp[0] * expelDistance,  unitperp[1] * expelDistance])					}								}}