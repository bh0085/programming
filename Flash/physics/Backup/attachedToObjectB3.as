package physics.objects.oscript{	import physics.twobody.TwoBodyCollision	import physics.PhysUniverse	import physics.objects.PhysObject	import flash.geom.Rectangle	import math.graphs.MovingGraph	import flash.display.Sprite	import flash.display.Shape	import flash.display.BitmapData	import flash.display.Bitmap	import flash.geom.Matrix		import math.VectorMath2D	import math.VectorMath3D	import flash.utils.getTimer	import paths.Node	import paths.CtdOutline			public class attachedToObject extends ObjectScript{				public static var s:Shape				public var objAttachedTo		public var nodesAttached		public var bindingForceConstant = 1		var kOut = 10, kIn = 5, kOn = .05				var bindingMaxDistance = 20		var bindingMaxForceConstant = 3		var bindingMaxVelocity = 800					public var surfaceUnits:Array		public var surfacePoints:Array			public var sfcPtAvg:Array		public var sfcUnitsAvg:Array				public var isInside = false		public var wasInside:Boolean					public var mGraph:MovingGraph		public function friction():void{			thisObject.dampen([.8,.8,1])		}		public function testDetach():Boolean{			var d = false			if(thisObject.mustDetach()){				d = true				thisObject.setDetachPronto(false)			}			return d		}		public function detach():void{				thisObject.constraint = null				scriptDone = true				spawnDetached()		}		public function findNearbyNodes(atcOutline:CtdOutline):Array{			var objBounds = thisObject.thisOutline.outline.getBoundsExt()			var m = 15			objBounds.x -= m			objBounds.y -= m			objBounds.height += 2 * m			objBounds.width += 2* m			var nodeList = atcOutline.nodesInRect(objBounds)			return nodeList		}		public function findNodesOnObject(atcNodes:Array):Array{			var objNodes = thisObject.thisOutline.outline.nodesInOrder()			var objUnits = new Array(objNodes.length)			var objUnitsIn = new Array(objNodes.length)			var nodesHit = new Array(objNodes.length)			var endsHit = new Array(objNodes.length)			for(var i = 0 ; i < objNodes.length ; i++){				objUnits[i] = objNodes[i].getUnitsExt(false)				objUnitsIn[i] = [-objUnits[i][2],-objUnits[i][3]]				nodesHit[i] = false				endsHit[i] = [false,false]			}			var atcUnitsUp = new Array(atcNodes.length)			var nodePairsPtPairsDepths = [new Array(),new Array(),new Array(), new Array()]			for(var i = 0 ; i < atcNodes.length ; i++){				var units = atcNodes[i].getUnitsExt(false)				atcUnitsUp[i] = [ units[2],units[3] ]				var minDist = -1				var secondMinIDX = -1				var secondMinDist = -1				var minIDX  = -1				for(var j = 0; j < objUnits.length ; j++){					var pt1 = atcNodes[i].getXY()					var segs2 = [objNodes[j].getXY(),objNodes[j].next.getXY()]					var dist = VectorMath2D.ptLineDist(pt1,segs2[0],segs2[1])[0]					if(minIDX == -1 || dist <minDist){						secondMinIDX = minIDX						secondMinDist = minDist						minDist = dist						minIDX = j											} else { 						if(secondMinIDX == -1 || dist < secondMinDist){							secondMinIDX = j							secondMinDist = dist						}					}				}				for(var m = 0; m < 2 ; m++){					if(m == 0){if(minDist< 15){j = minIDX} else { j = -1}}					if(m == 1){if(secondMinDist < 15){j = secondMinIDX} else {j = -1}}					if(j != -1){						if(VectorMath2D.dotMultiply2D(atcUnitsUp[i],objUnitsIn[j]) > 0){							var pt1= atcNodes[i].getXY()							var segs2 = [objNodes[j].getXY(),objNodes[j].next.getXY()]							var pt2 = VectorMath2D.ptLineClosest(pt1,segs2[0],segs2[1])							var ptPair = [[pt1,[pt2[0],pt2[1]]],[0,pt2[2]]]							var objDepth =VectorMath2D.dotMultiply2D([ptPair[0][0][0] - ptPair[0][1][0], ptPair[0][0][1]- ptPair[0][1][1]],objUnitsIn[j])							var atcDepth =VectorMath2D.dotMultiply2D([ptPair[0][0][0] - ptPair[0][1][0], ptPair[0][0][1]- ptPair[0][1][1]],atcUnitsUp[i])							nodePairsPtPairsDepths[0].push([atcNodes[i],objNodes[j]])							nodePairsPtPairsDepths[1].push(ptPair)							nodePairsPtPairsDepths[2].push([atcDepth,objDepth])							nodePairsPtPairsDepths[3].push('firstround')							nodesHit[j] = true						}											} else {						m++ 					}				}			}						for(var i = 0 ;  i < objNodes.length ; i++){				if(nodesHit[i]){					if(!endsHit[i][0]){						var extXY = objNodes[i].getXY()						var localXY = atcNodes[0].thisCtdOutline.localCoords(extXY)						var minDist = -1						var minNode = null						for(var j = 0 ; j < atcNodes.length ; j++){							if(VectorMath2D.dotMultiply2D(atcUnitsUp[j],objUnitsIn[i]) > 0){								var dist = atcNodes[j].ptBitDistance(localXY)								if(minNode == null || dist < minDist){									minNode = atcNodes[j]									minDist = dist									bestIDX = j								}							}						}						if(minNode != null){							var out = minNode.ptBitClosest(localXY,true)							var atcXY = [out[0],out[1]]							var segEnd = out[2]							ptPair = [[atcXY,extXY],[segEnd,0]]							objDepth =VectorMath2D.dotMultiply2D([ptPair[0][0][0] - ptPair[0][1][0], ptPair[0][0][1]- ptPair[0][1][1]],objUnitsIn[i])							atcDepth =VectorMath2D.dotMultiply2D([ptPair[0][0][0] - ptPair[0][1][0], ptPair[0][0][1]- ptPair[0][1][1]],atcUnitsUp[bestIDX])							nodePairsPtPairsDepths[0].push([minNode,objNodes[i]])							nodePairsPtPairsDepths[1].push(ptPair)							nodePairsPtPairsDepths[2].push([atcDepth,objDepth])							nodePairsPtPairsDepths[3].push('nodeadd')						}					}					if(!endsHit[i][1]){						 extXY = objNodes[i].next.getXY()						 localXY = atcNodes[0].thisCtdOutline.localCoords(extXY)												 minDist = -1						 minNode = null						for( j = 0 ; j < atcNodes.length ; j++){							if(VectorMath2D.dotMultiply2D(atcUnitsUp[j],objUnitsIn[i]) > 0){								var dist = atcNodes[j].ptBitDistance(localXY)								if(minNode == null || dist < minDist){									minNode = atcNodes[j]									minDist = dist									var bestIDX = j								}															}						}						if(minNode != null){							out = minNode.ptBitClosest(localXY,true)							atcXY = [out[0],out[1]]							segEnd = out[2]							ptPair = [[atcXY,extXY],[segEnd,1]]							objDepth =VectorMath2D.dotMultiply2D([ptPair[0][0][0] - ptPair[0][1][0], ptPair[0][0][1]- ptPair[0][1][1]],objUnitsIn[i])							atcDepth =VectorMath2D.dotMultiply2D([ptPair[0][0][0] - ptPair[0][1][0], ptPair[0][0][1]- ptPair[0][1][1]],atcUnitsUp[bestIDX])							nodePairsPtPairsDepths[0].push([minNode,objNodes[i]])							nodePairsPtPairsDepths[1].push(ptPair)							nodePairsPtPairsDepths[2].push([atcDepth,objDepth])							nodePairsPtPairsDepths[3].push('nodeadd')						}					}				}			}			//the form of ptPairs is as follows: [pairIndex][xys,endhit][atc,obj][x,y]			return nodePairsPtPairsDepths		}					override public function advance(...args):void{			if(objAttachedTo.isDestroyed){				detach()				return			}						var step = args[0]			if(step == 0 || step == 1){				if(testDetach()){					thisObject.constraint = null					detach()				}			}			if(step == 1 ){										PhysUniverse.universe.setExtraGraphics(new Sprite())					var outlines = [thisObject.thisOutline.outline, objAttachedTo.thisOutline.outline]					var inew = CtdOutline.getDeepestPair(outlines[0],outlines[1])							}			if(step == 1&& !scriptDone) {				friction()				thisObject.constraint = [objAttachedTo.thisOutline.outline, nodesAttached[0]]				var outline = thisObject.constraint[0]				//thisObject.cancelAppliedForces()				//thisObject.dampen([.6,.6,.8])	/*							var output = new Array()							var intersection = thisObject.thisOutline.intersect2(objAttachedTo.thisOutline.outline,1,output)				var allArcs = output[0]				var intData = output[1]				if(allArcs == null){return}				var arcs = allArcs[0]								var g = new Sprite()				g.addChild(intersection.simpleDraw(true,false,0))				PhysUniverse.universe.setExtraGraphics(g)				//trace(arcs.length)				if(arcs.length == 2){					var objNodes = [arcs[1][0][0],arcs[1][0][1]]					var atcNodes = [arcs[0][0][0],arcs[0][0][1]]					var objInts = arcs[1][1]					var atcInts = arcs[0][1]					if(arcs[1][2] != true){						objNodes = objNodes.reverse()						objInts = objInts.reverse()}					if(arcs[0][2] != true){						atcNodes = atcNodes.reverse()						atcInts = atcInts.reverse()}					var objIntPts = [intData[objInts[0]][1],intData[objInts[1]][1]]					var atcIntPts = [intData[atcInts[0]][1],intData[atcInts[1]][1]]					var search = true					var objNode = objNodes[0]					var objNodesTween = new Array()					var objUnits = new Array()					var objDists = new Array()					while(search){												if(objNode == objNodes[0]){var p1 = objIntPts[0]} else {p1 = objNode.getXY()}						if(objNode == objNodes[1]){var p2 = objIntPts[1]} else {p2 = objNode.next.getXY()}						objDists.push(Math.sqrt(Math.pow(p1[0] - p2[0],2) + Math.pow(p1[1] - p2[1],2)))																									  						objNodesTween.push(objNode)						objUnits.push(objNode.getUnitsExt(false))						if(objNode == objNodes[1]){search = false}						objNode = objNode.next					}					var atcNode = atcNodes[0]					search = true					var atcNodesTween = new Array()					var atcUnits = new Array()					var atcDists = new Array()					while(search){												if(atcNode == atcNodes[0]){var p1 = atcIntPts[0]} else {p1 = atcNode.getXY()}						if(atcNode == atcNodes[1]){var p2 = atcIntPts[1]} else {p2 = atcNode.next.getXY()}						atcDists.push(Math.sqrt(Math.pow(p1[0] - p2[0],2) + Math.pow(p1[1] - p2[1],2)))						atcNodesTween.push(atcNode)						atcUnits.push(atcNode.getUnitsExt(false))						if(atcNode == atcNodes[1]){ search = false}						atcNode = atcNode.next					}					var anglesTween = new Array()										for(var i = 0 ; i < atcUnits.length ; i++){						anglesTween[i] = new Array()						for(var j = 0 ; j < objUnits.length ; j++){							var angleTween = VectorMath2D.angle1To2([atcUnits[i][0],atcUnits[i][1]],[objUnits[j][0],objUnits[j][1]])							if(angleTween < 0){angleTween += Math.PI} else {angleTween -+ Math.PI}							anglesTween[i][j] = angleTween						}					}										if(objNodesTween.length ==objNode.thisCtdOutline.numNodes){						var objType = 'entire'					} else {						if (objNodesTween.length > 2){							objType = 'curve'							var objNode =  objNodesTween[Math.floor(objNodesTween.length /2)]						} else {							if(objNodesTween.length == 2){								objType = 'pt'								var objPt = objNodesTween[1].getXY()								objNode = objNodesTween[Math.floor(objNodesTween.length /2)]							} else {								objType = 'seg'								objNode = objNodesTween[Math.floor(objNodesTween.length /2)]							}						}					}					if(atcNodesTween.length == atcNode.thisCtdOutline.numNodes){						var atcType = 'entire'					} else {						if (atcNodesTween.length > 2){							atcType = 'curve'							var atcNode =  atcNodesTween[Math.floor(atcNodesTween.length /2)]						} else {							if(atcNodesTween.length == 2){								atcType = 'pt'								var atcPt = atcNodesTween[1].getXY()								var atcNode =  atcNodesTween[Math.floor(atcNodesTween.length /2)]								//atPresent this  algorithm is really dumb... it should choose the attachment node better.							} else {								atcType = 'seg'								atcNode = atcNodesTween[Math.floor(atcNodesTween.length /2)]							}						}					}															if(atcType == 'entire'){return}					if(atcType == 'seg' || atcType == 'curve' || atcType == 'pt'){var uAtc =  atcNode.getUnitsExt(false)}					if(objType == 'entire'){return}					if(objType == 'seg' || objType == 'curve' || objType == 'pt'){var uObj =  objNode.getUnitsExt(false)}										var angleMin = -1					var ijGood = new Array()					var distMin = 10					if(true){						for(var i = 0 ; i < atcNodesTween.length; i++){							for(var j = 0 ; j < objNodesTween. length ; j++){								if(anglesTween[i][j] < angleMin || angleMin == -1){									ijGood = [i,j]									angleMin = anglesTween[i][j]								}							}						}					}										//if(Math.abs(angleMin) < Math.PI /4){thisObject.rotateBy(angleMin)}					if(objPt == null) {objPt = objNode.getXY()}					if(atcPt == null) {atcPt = atcNode.getXY()}					var vecToAtc = [atcPt[0] - objPt[0],atcPt[1] - objPt[1]]					var depth = VectorMath2D.dotMultiply2D(vecToAtc,[uAtc[2],uAtc[3]])					thisObject.moveBy([uAtc[2]*depth,uAtc[3]*depth])					g.graphics.lineStyle(1,0xFFFFFF)					g.graphics.drawCircle(atcNode.getXY()[0],atcNode.getXY()[1],5)					g.graphics.moveTo(atcPt[0],atcPt[1])					g.graphics.lineTo(atcPt[0]+ uAtc[0]*50,atcPt[1]+uAtc[1]*50)					g.graphics.moveTo(objPt[0],objPt[1])					g.graphics.lineTo(objPt[0]+ uObj[0]*50,objPt[1]+uObj[1]*50)					trace(depth)					if(PhysUniverse.toggleGraphics){PhysUniverse.universe.addExtraGraphic(objAttachedTo.thisOutline.outline.simpleDrawGradient(true))}				} */				var nodeList = findNearbyNodes(outline)				if(nodeList.length != 0){					var out = findNodesOnObject(nodeList)									var ptPairs = out[1]					var nodePairs = out[0]					var depthPairs = out[2]					var comments = out[3]					if(ptPairs.length != 0){						var unitsT = new Array()						var depths = new Array()						var flagged =new Array()      //flags points that are connected endpoints... they are unreliable...						for(var i = 0 ; i < depthPairs.length ; i++){							if(ptPairs[i][1][0] == 0){								var units = nodePairs[i][0].getUnitsExt(true)							}							if(ptPairs[i][1][0] == 1){								units = nodePairs[i][0].next.getUnitsExt(true)							}							if(ptPairs[i][1][0] == -1){								units = nodePairs[i][0].getUnitsExt(false)							}							var uTemp = [units[2], units[3]] 						 	unitsT.push(uTemp )							var vecToSurface = [ptPairs[i][0][0][0] - ptPairs[i][0][1][0],ptPairs[i][0][0][1] - ptPairs[i][0][1][1]]							depths.push( VectorMath2D.dotMultiply2D(vecToSurface,uTemp))							if(ptPairs[i][1][0] != -1 && ptPairs[i][1][1] != -1){								flagged[i] = true							}						}						var dMetric = new Array()						for(var i = 0 ; i < depths.length; i ++){							dMetric[i] = depths[i]							if(flagged[i]){dMetric[i] = -1}						}						var idxs = dMetric.sort(2|8)						var depthTol = 0						var depthOffMax = 10						var depthFirst =  dMetric[idxs[0]]						var depthMin = Math.max(-1 * depthTol, depthFirst - depthOffMax)						var depthMin2 = -1*depthTol						var ptFirst = ptPairs[idxs[0]][0][1]						if(dMetric[idxs[0]] > depthMin){							var maxDist =-1							var maxIDX = -1							for(var i = 0 ; i < idxs.length ; i++){								var depth = dMetric[idxs[i]]								var pt = ptPairs[idxs[i]][0][1]								var dist = Math.sqrt(Math.pow(pt[0] - ptFirst[0], 2) + Math.pow(pt[1] - ptFirst[1],2))								if(depth > depthMin && dist > maxDist && !flagged[idxs[i]]){									maxDist = dist									maxIDX = i								}								if(depth < depthMin){									break;								}							}							var differentiationResolution = 20							var secondMaxIDX = -1							var secondMaxDist = 0							if(maxDist > differentiationResolution){								ptFirst = ptPairs[idxs[maxIDX]][0][1]									for(var i = 0 ; i < idxs.length ; i++){									var depth = dMetric[idxs[i]]									var pt = ptPairs[idxs[i]][0][1]									var dist = Math.sqrt(Math.pow(pt[0] - ptFirst[0], 2) + Math.pow(pt[1] - ptFirst[1],2))									if(depth > depthMin && dist > secondMaxDist && !flagged[idxs[i]]){										secondMaxDist = dist										secondMaxIDX = i									}									if(depth < depthMin){										break;									}								}								var idx1 = idxs[maxIDX]								var idx2 = idxs[secondMaxIDX]							} else {								ptFirst = ptPairs[idxs[0]][0][1]								for(var i = 1 ; i < idxs.length ; i++){									var depth = dMetric[idxs[i]]									var pt = ptPairs[idxs[i]][0][1]									var dist = Math.sqrt(Math.pow(pt[0] - ptFirst[0], 2) + Math.pow(pt[1] - ptFirst[1],2))									if(depth > depthMin2 && dist > differentiationResolution){										secondMaxDist = dist										secondMaxIDX = i										break;									}									if(depth < depthMin2){										break;									}								}										if(secondMaxIDX == -1){									idx1 = idxs[0]									idx2 = -1								} else {									idx1 = idxs[maxIDX]									idx2 = idxs[secondMaxIDX]															}							}							var vecToSurface =[ptPairs[idxs[0]][0][0][0] - ptPairs[idxs[0]][0][1][0],ptPairs[idxs[0]][0][0][1] - ptPairs[idxs[0]][0][1][1]]							var g = new Sprite()							g.graphics.lineStyle(0,0xFFFFFF)							g.graphics.moveTo( ptPairs[idxs[0]][0][1][0],ptPairs[idxs[0]][0][1][1] )							g.graphics.lineTo( ptPairs[idxs[0]][0][0][0],ptPairs[idxs[0]][0][0][1] )							var unitOut = unitsT[idxs[0]]							var dot = VectorMath2D.dotMultiply2D(vecToSurface,unitOut)/2							//trace(unitOut)							var moveBy = [dot * unitOut[0], dot * unitOut[1]]							var pt1 = ptPairs[idx1][0][1]							var u1 = unitsT[idx1]							if(idx2 == -1){								var impulses = TwoBodyCollision.onePtInelasticObjs([thisObject,objAttachedTo],pt1,u1)							} else {								var pt2 = ptPairs[idx2][0][1]								var u2 = unitsT[idx2]								var impulses = TwoBodyCollision.twoPtInelasticObjs([thisObject,objAttachedTo],[pt1,pt2],[u1,u2])												}							/*							var gfx = new Sprite()							gfx.graphics.lineStyle(0)							gfx.graphics.drawCircle(pt1[0],pt1[1],5)							if(pt2 != null){							gfx.graphics.drawCircle(pt2[0],pt2[1],10)							}						*/							//PhysUniverse.universe.setExtraGraphics(new Sprite())							//PhysUniverse.universe.addExtraGraphic(gfx)							//PhysUniverse.universe.addExtraGraphic(g)																				}					}				}			}		}		public function spawnDetached():void{			var newScript = new detachFromObj()			newScript.setAttachedTo(objAttachedTo)			thisObject.addObjectScript(newScript)		}		public function setAttachedTo(obj:PhysObject):void{			objAttachedTo = obj			multiPriorities = true		}		public function setWhichAttached(nodes:Array):void{			nodesAttached = nodes		}			}}