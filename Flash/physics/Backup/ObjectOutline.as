package paths{	import physics.PhysObject	import flash.geom.Rectangle	import mygraphics.PtObj	import mygraphics.Obj	import flash.utils.getTimer	import flash.display.DisplayObject	public class ObjectOutline extends Path2D{		public var lastSegUpdated = 0		public var thisObject:PhysObject		var searchOffset = 5				public function ObjectOutline(object:PhysObject){			thisObject = object		}		public function updateThoseInNeed(num:Number):void{			if(thisObject.outlineDetached){				for(var i = 1; i <= num ; i++){						search = true					nSearch = 0					while(search && nSearch < num){						seg = lastSegUpdated + 1						if (seg >= pathX.length ) {seg -= pathX.length}						nSearch ++						if(subPathsOutOfDate[seg] != false){							genSubPath(seg)							search = false						}						lastSegUpdated = seg					}					if(thisObject.thisUniverse.toggleDebug){					}				}			} else{								var kptNeed = keypointsInNeed()				if(kptNeed != null){					for( i = 1; i <= num ; i++){						var search = true						var nSearch = 0						while(search && nSearch < num){							var seg = lastSegUpdated + 1							if (seg >= pathX.length ) {seg -= pathX.length}							nSearch ++							if(kptNeed[seg] != false){								var ptXY = [pathX[seg] +thisObject.getX(),pathY[seg] +thisObject.getY()]								var objXY = [thisObject.getX(),thisObject.getY()]								var gfx = thisObject.getGraphic()								var searchRect = new Rectangle(ptXY[0] - searchOffset, ptXY[1] - searchOffset, searchOffset*2,searchOffset*2)								var closestPoint = PtObj.closestPoint(ptXY,objXY,gfx,thisObject.thisUniverse,searchRect)								if(closestPoint != null){									var closestPointInObj = [closestPoint[0][0] - thisObject.getX(),closestPoint[0][1] - thisObject.getY()]									addToKeypoint(closestPointInObj[0],closestPointInObj[1],1,seg)								} else {									var m = 5									searchRect = new Rectangle(ptXY[0] - m*searchOffset, ptXY[1] - m*searchOffset, searchOffset*2 * m,searchOffset*2 * m)									closestPoint = PtObj.closestPoint(ptXY,objXY,gfx,thisObject.thisUniverse,searchRect)									if(closestPoint != null){										 closestPointInObj = [closestPoint[0][0] - thisObject.getX(),closestPoint[0][1] - thisObject.getY()]										addToKeypoint(closestPointInObj[0],closestPointInObj[1],1,seg)									} 								}							search = false							}						lastSegUpdated = seg						} 					}				} else {					zeroTension = true					for( i = 1; i <= num ; i++){						 search = true						 nSearch = 0						while(search && nSearch < num){							 seg = lastSegUpdated + 1							if (seg >= pathX.length ) {seg -= pathX.length}							nSearch ++							if(subPathsOutOfDate[seg] != false){								genSubPath(seg)							}							if(subPathsInNeed[seg] == true){								if(subPaths[seg] == null){									genSubPath(seg)								}								for(var j = 0; j< subPaths[seg].pathX.length ; j++){									 ptXY = [subPaths[seg].pathX[j]+thisObject.getX(),subPaths[seg].pathY[j]+thisObject.getY()]									 objXY = [thisObject.getX(),thisObject.getY()]									 gfx = thisObject.getGraphic()									 searchRect = new Rectangle(ptXY[0] - searchOffset, ptXY[1] - searchOffset, searchOffset*2,searchOffset*2)									 closestPoint = PtObj.closestPoint(ptXY,objXY,gfx,thisObject.thisUniverse,searchRect)									if(closestPoint != null){										 closestPointInObj = [closestPoint[0][0] - thisObject.getX(),closestPoint[0][1] - thisObject.getY()]																				subPaths[seg].pushPt(closestPointInObj[0],closestPointInObj[1],1)																											} else {										 m = 5										searchRect = new Rectangle(ptXY[0] - m*searchOffset, ptXY[1] - m*searchOffset, searchOffset*2 * m,searchOffset*2 * m)										closestPoint = PtObj.closestPoint(ptXY,objXY,gfx,thisObject.thisUniverse,searchRect)										if(closestPoint != null){											 closestPointInObj = [closestPoint[0][0] - thisObject.getX(),closestPoint[0][1] - thisObject.getY()]											subPaths[seg].pushPt(closestPointInObj[0],closestPointInObj[1],1)																					} 									}								}								search = false								subPathsInNeed[seg] = false							} else {							}							lastSegUpdated = seg						}						getSubpathsInNeed()					}				}			}		}		public function doesNeedUpdate():Boolean{			if(!thisObject.outlineDetached && keypointsInNeed() != null){return true}			for(var i = 0; i < pathX.length ; i++){				if(subPathsOutOfDate[i] == true ){					return true				}												if(!thisObject.outlineDetached && subPathsInNeed[i] == true){					return(true)				}			}			return false		}		public static function findConnectedOutlineIntersection(path1:ObjectOutline,path2:ObjectOutline):Path2D{			 var t = flash.utils.getTimer()			var x1 = path1.thisObject.getX()			var x2 = path2.thisObject.getX()			var y1 = path1.thisObject.getY()			var y2 = path2.thisObject.getY()			path1.genShape()			path2.genShape()						if(path1.isClosed == false || path2.isClosed == false){trace("Cannot Intersect Unclosed Paths") ; return null}			var pts1Inside = new Array(path1.pathX.length)			var pts2Inside = new Array(path2.pathX.length)			var nIn1 = 0, nIn2 = 0			for(var i = 0; i<pts1Inside.length ; i++){				pts1Inside[i] = path2.ptIsInside([path1.pathX[i] + x1 - x2,path1.pathY[i] + y1 - y2],false)				if(pts1Inside[i]){nIn1 ++}			}						for( i = 0; i<pts2Inside.length ; i++){				pts2Inside[i] = path1.ptIsInside([path2.pathX[i] + x2 - x1,path2.pathY[i] + y2 - y1],false)				if(pts2Inside[i]){nIn2 ++}			}			if(nIn1 == 0 && nIn2 == 0){return null}						var newPath = new Path2D()			var ptX, ptY			newPath.zeroTension = true			newPath.setMergeDistance(0)			//trace(1,flash.utils.getTimer() - t)			for(var k = 0; k< 2 ; k++){				if(k ==0){					var inside = pts1Inside					var path = path1					var pathOther = path2					var xOffInOther = x1 - x2					var yOffInOther = y1 - y2								var xOffReal = x1 					var yOffReal = y1 				} else {					newPath.isClosed = true					 inside = pts2Inside					 path = path2					 pathOther = path1					 xOffInOther = x2 - x1					 yOffInOther = y2 - y1								 xOffReal = x2					 yOffReal = y2 								}				for(i = 0 ; i<inside.length ; i++){					if(inside[i]){													ptX = path.pathX[i] + xOffReal						ptY = path.pathY[i] + yOffReal						newPath.pushKeypoint(ptX,ptY,10)						var iplus = i + 1						var iminus =  i - 1						if(iplus >= inside.length){iplus = iplus -inside.length}						if(iminus<0){iminus = pts1Inside.length -1 }						var addedExtra = false						if(!inside[iminus]){							var subPath = path.subPaths[iminus]							for(var j = 0 ; j<subPath.pathX.length ; j ++){								if(!addedExtra){									var ptOther =[ subPath.pathX[j] + xOffInOther,subPath.pathY[j] + yOffInOther]									var ptReal =[ subPath.pathX[j] + xOffReal,subPath.pathY[j] + yOffReal]									if(pathOther.ptIsInside(ptOther,false)){										newPath.pushKeypoint(ptReal[0],ptReal[1],10)										addedExtra = true									}								}							}						}						addedExtra = false						if(!inside[iplus]){							subPath = path.subPaths[iplus]							for( j = subPath.pathX.length - 1 ; j>=0 ; j --){								if(!addedExtra){									ptOther =[ subPath.pathX[j] + xOffInOther,subPath.pathY[j] + yOffInOther]									ptReal =[ subPath.pathX[j] + xOffReal,subPath.pathY[j] + yOffReal]									if(pathOther.ptIsInside(ptOther,false)){										newPath.pushKeypoint(ptReal[0],ptReal[1],10)										addedExtra = true									}								}							}						}					}				}			}					//trace(flash.utils.getTimer() - t)		return newPath					}		public static function pts1InsideOf2(out1:ObjectOutline,out2:ObjectOutline):Array{			if(out1.thisObject !=null){				var x1 = out1.thisObject.getX()				var y1 = out1.thisObject.getY()			} else{x1 = 0 ; y1 = 0}						if(out2.thisObject !=null){				var x2 = out2.thisObject.getX()				var y2 = out2.thisObject.getY()			} else{x2 = 0 ; y2 = 0}							out1.genShape()			var pts1Inside = new Array(out1.pathX.length)			var nIn1 = 0			for(var i = 0; i<pts1Inside.length ; i++){				pts1Inside[i] = out2.ptIsInside([out1.pathX[i] + x1 - x2,out1.pathY[i] + y1 - y2],false)				if(pts1Inside[i]){nIn1 ++}			}									if(nIn1 == 0) {return null}			return pts1Inside		}		public function eraseWith(out2:ObjectOutline,zT:Boolean):void{			if(thisObject !=null){				var x1 = thisObject.getX()				var y1 = thisObject.getY()			} else{x1 = 0 ; y1 = 0}						if(out2.thisObject !=null){				var x2 = out2.thisObject.getX()				var y2 = out2.thisObject.getY()			} else{x2 = 0 ; y2 = 0}								var xOffIn1 = x2 - x1			var yOffIn1 = y2 - y1						setMergeDistance(5)			var oneIn2 = ObjectOutline.pts1InsideOf2(this,out2)			var twoIn1 = ObjectOutline.pts1InsideOf2(out2,this)			this.zeroTension = zT			if(oneIn2 != null){				for(var i = pathX.length - 1 ;  i>= 0 ; i--){					if(oneIn2[i]){removeKeypoint(i)}				}			}			if(twoIn1 != null){				for(i = 0 ; i< out2.pathY.length; i++){					if(twoIn1[i]){pushKeypoint(out2.pathX[i]+xOffIn1,out2.pathY[i]+yOffIn1,out2.numAvgd[i])}				}			}		}		public function buildQuickOutline(numPts:Number,g:DisplayObject,...args):void{			var offset = [0,0]			if(args.length > 0){offset = args[0]}			var r = Math.sqrt(Math.pow(g.width,2) + Math.pow(g.height,2))			var spacing = 2 * Math.PI * r / numPts			if(r != 0){				setMergeDistance(spacing/2)								for (var i = 0; i < numPts; i ++){					var angle = i / numPts * Math.PI * 2					var ptInObj = Obj.edgePointAtAngle(g,angle, r,offset)					var pt = [ptInObj[0], ptInObj[1]]					pushPt(pt[0],pt[1])				}				isClosed = true						} else {		}		}	}}