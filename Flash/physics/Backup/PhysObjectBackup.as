package physics{		import math.MathArray	import math.VectorMath3D	import math.VectorMath2D		import physics.pscript.PhysScript	import physics.objects.oscript.ObjectScript	import physics.objects.oscript.attachToObj	import physics.objects.oscript.bounceOffObj	import physics.pscript.stickToObject	import physics.projectile.NewtonianSphere	import physics.misc.Dipole		import flash.utils.getQualifiedClassName	import flash.display.MovieClip	import flash.display.Sprite	import flash.display.DisplayObject	import flash.text.TextField	import Math	import flash.geom.Rectangle	import flash.events.MouseEvent	import flash.events.Event	import flash.utils.getTimer	import flash.display.Graphics	import paths.Node	import paths.PhysOutline		import mygraphics.PtObj	import mygraphics.Obj			public class PhysObject extends MovieClip {		public var extraGFX:Sprite				public static var eps = 8.845 * Math.pow(10, -12)	//Free Space Permittivity in MKS		public static var kc = 9*Math.pow(10,9)				//Coulomb law K in MKS		public static var G = 6.67 * Math.pow(10, -11)	//Gravitational Constant		public static var defaultSearchRadius = 50				//Init attributes				public var objName:String;				// Graphical Attributes				public var constraint = null		public var attachedTo:PhysObject		public var childOf:PhysObject		public var rInParentDefault:Number = 0		public var angleInParentDefault:Number = 0				public var momentOfInertia:Number = 0		public var COM = [0,0]		public var children:Array						public var omega:Number = 0		public var angle:Number = 0				public var nameField:TextField;		public var potentialField:TextField;		public var graphic:Sprite;		public var gfxMask:DisplayObject;		public var numConsecutiveCollisions:Array		public var lastNodeCollided:Node		public var numConsecutiveCollisionsThisNode:Number				public var hasCollided:Array						public var mass = 0		public var customCharges:Array = new Array()		public var charge = 0				//Management of the fields, potentials and universe of which this object is a part.		public var thisUniverseIndex:Number;	 		public var thisUniverse:PhysUniverse;				//Dynamic attributes		public var isstatic:Boolean = false;				//Disables motion		public var isSleeping:Boolean = false		public var staticInFields: Array = new Array()		public var dragging:Boolean = false;				//Handles dragging		public var lastclicktimer:Number = 0 				// Double Click Timer				public var dragTicker:Number = 0				public var minimumMassToAttachTo:Number = 20000		public var objectCanAttach = false		public var objectCanStick = false				public var xvel = 0;								public var yvel = 0;								//Current particle velocity				public var pastx:MathArray = new MathArray()							public var pasty:MathArray = new MathArray()		public var pastvx:MathArray = new MathArray()		public var pastvy:MathArray	 = new MathArray()					 //Allows the object to remember its motion upon drag-relsease		public var ftorqueThisTimeStep = [0,0,0]				public var isPtLike = false		public var isDraggable:Boolean = true		public var isWall:Boolean = false		public var scripts = new Array		public var minimumMeaningfulLengthScale = 300		public var searchRadius = 75		public var collisionRadius = 0				public var detached = false		public var detachPronto = false		public var skinDepth = 10				public var color = 0xFFFFFF		public var thisOutline:PhysOutline		public var eraseable = false						public var lastXY:Array			public var thisXY:Array				public function PhysObject(){			addEventListener(MouseEvent.MOUSE_DOWN,objMouseDown)			addEventListener(MouseEvent.MOUSE_UP,objMouseUp)			addEventListener(Event.ENTER_FRAME,objEnterFrame,false, 10)			graphic = new Sprite()			extraGFX = new Sprite()			addChild(graphic)			addChild(extraGFX)		}				public function executeScripts(priority:Number):void	{			if  (scripts.length != 0){				for (var i = 0 ; i< (scripts.length) ;i ++){						if(scripts[i].getPriority() == priority){						if (scripts[i].advanceDefault()){							scripts[i].endScriptDefault()							scripts.splice(i,1)}}}}		}		public function defaultFT():void						{			var ftTemp = forceAndTorqueOn()				ftorqueThisTimeStep[0] += ftTemp[0]			ftorqueThisTimeStep[1] += ftTemp[1]			ftorqueThisTimeStep[2] += ftTemp[2]		}		public function resetFT():void							{			ftorqueThisTimeStep = [0,0,0]		}		public function staticFriction():void{			if(Math.sqrt(Math.pow(xvel,2) + Math.pow(yvel,2)) < Math.pow(10,-3)){xvel = 0 ; yvel = 0 }		}		public function defaultKinematics():void				{					if(constraint == null){			rotateStep()			moveStep()			accelerateBy([ftorqueThisTimeStep[0]/ mass,ftorqueThisTimeStep[1]/mass])			if (momentOfInertia != 0) {angularAccelerateBy(ftorqueThisTimeStep[2]/ momentOfInertia)}					dampenStep()				staticFriction()			trace(customCharges[1])			trace(flash.utils.getQualifiedClassName(this),ftorqueThisTimeStep[0]/mass)		} else {						constrainedMoveStep()			accelerateBy([ftorqueThisTimeStep[0]/ mass,ftorqueThisTimeStep[1]/mass])			dampenStep()			staticFriction()					}				}		public function executeTimeStep():Boolean 				{			if (! isstatic && ! dragging && (childOf == null) ) {return true} else {return false}		}						public function timeStep():void	{									if (executeTimeStep()){			if(!isSleeping){defaultFT()}						executeScripts(0)			executeScripts(1)			defaultKinematics()			resetFT()			}				}				public function doesAttachTo(object:PhysObject):Boolean	{			if(objectCanAttach){				if (minimumMassToAttachTo > 0){					if(object.getMass() > minimumMassToAttachTo){return true} else {return false}				} else {return false}			} else {return false}		}		public function setAttachMass(arg:Number)				{			minimumMassToAttachTo = arg		}		public function createAttachScript(object:PhysObject,nodesAttached:Array):void{			var attachScript = new attachToObj()			addObjectScript(attachScript,false)			attachScript.setAttachedTo(object)			attachScript.setWhichAttached(nodesAttached)					}		public function attach(object:PhysObject):void			{			detached = false			attachedTo = object		}		public function getDetached()							{			return detached		}		public function getAttachedTo():PhysObject				{			return attachedTo		}		public function detach():void							{			detached = true			attachedTo = null		}		public function mustDetach():Boolean{			if(detachPronto){				detachPronto = false; 				return true}			else return false		}				public function createStickToScript(object:PhysObject):void{			var script = new stickToObject()			script.setWhichIsStuck(this)			script.setWhichStuckTo(object)			script.setPriority(1)			thisUniverse.addUniverseScript(script)					}		public function doesStickTo(object:PhysObject):Boolean{			if(objectCanStick){return true} else{return false}					}		public function createBounceOffScript(object:PhysObject,nodesAttached:Array):void{			var bounceScript = new bounceOffObj()			addObjectScript(bounceScript,false)			bounceScript.setAttachedTo(object)			bounceScript.setWhichAttached(nodesAttached)					}						public function sleep():void{			isSleeping = true		}		public function wake():void{			isSleeping = false		}		public function collided():void{}				public function updateChildren():void										{				if (children != null){					var xyInParent:Array = [0,0]					for (var i = 0 ; i < children.length ; i++){						xyInParent[0] = Math.cos(angle + children[i].angleInParentDefault) * children[i].rInParentDefault 						xyInParent[1] = Math.sin(angle + children[i].angleInParentDefault) * children[i].rInParentDefault						children[i].moveTo([getX() + xyInParent[0], getY() + xyInParent[1]])					}				}		}				public function addObjectScript(script:ObjectScript, ...runFrame):void		{			var advanceOnInit = true			if(runFrame.length > 0){ advanceOnInit = runFrame[0] } 			script.setObject(this)			addScript(script, advanceOnInit )		}		public function addScript(script:PhysScript,advanceOnInit:Boolean):void	  	{			scripts.push(script); 			script.beginScriptDefault(advanceOnInit)		}		public function addChildObject(obj:PhysObject,angRads:Number,rad:Number)	{			if (children == null) {children = new Array()}			obj.angleInParentDefault = angRads			obj.rInParentDefault = rad			obj.setChildOf( this )			children.push(obj)			if(thisUniverse != null) {				setDefaults()				obj.setUniverse(thisUniverse,thisUniverseIndex)			}					}		public function setChildOf(obj:PhysObject):void								{			childOf = obj		}		public function displayChildren():void										{			if (children != null) {			for (var i = 0; i < children.length; i++){					children[i].thisUniverse = thisUniverse					thisUniverse.addChild(children[i])			}			}		}		function setDefaults():void				{			setCOMDefault			setMomentDefault()		}				function setChargeDefault():void		{			charge = 0			if (children != null){			if (children.length != 0){			for (var i = 0; i< children.length; i++) {				charge += children[i].charge			}}			} else {charge = 0 }			setCharge(charge)		}		function setMomentDefault():void		{			momentOfInertia = 0			if (children != null){				if (children.length != 0){				for (var i = 0; i< children.length; i++) {					momentOfInertia += Math.pow(children[i].rInParentDefault,2) * children[i].mass				}}			} else {				var nodes = thisOutline.outline.nodesInOrder()				var nodeMass = mass / nodes.length				momentOfInertia = 0				for(var i = 0 ; i < nodes.length ; i++){					var r = Math.sqrt(Math.pow(nodes[i].x,2 ) + Math.pow(nodes[i].y,2) )					momentOfInertia += nodeMass * Math.pow(r,2)				}			}					}		public function setCOMDefault()			{			COM = thisOutline.outline.getCOM		}				public function getNumCollisions(index:Number):Number								{			if(childOf == null) {return numConsecutiveCollisions[index]}			else{return childOf.getNumCollisions(index)}		}		public function collidedWith(indexCollidedWith:Number,didCollide:Boolean):void		{						if(didCollide){								numConsecutiveCollisions[indexCollidedWith] ++				collided()				var object = thisUniverse.objects[indexCollidedWith]				if(doesAttachTo(thisUniverse.objects[indexCollidedWith])){					var nodesCollided = getNodesCollided(object.thisOutline)					var thisNode = nodesCollided[0][0]					if(thisNode != lastNodeCollided){						lastNodeCollided = thisNode						numConsecutiveCollisionsThisNode = 1					} else {						numConsecutiveCollisionsThisNode ++					}										if(nodesCollided[0][0].isSticky && nodesCollided[0][1].isSticky){						createAttachScript(object,nodesCollided[0])					} else {						createBounceOffScript(object,nodesCollided[0])					}				} 				if(doesStickTo(object)){					createStickToScript(object)				}			}			else{numConsecutiveCollisions[indexCollidedWith] = 0}		}		public function resetCollisions():void												{			numConsecutiveCollisions = new Array(thisUniverse.objects.length)			for(var k = 0 ; k< thisUniverse.objects.length;k++){				numConsecutiveCollisions[k] = 0			}		}				public function eraseWith(po:PhysOutline){			if(thisOutline != null){				var path = thisOutline.intersectWith(po.outline, 0)				if(path!= null){					thisOutline.outline = path					thisOutline.setObject(this)					thisOutline.outline.genSegments()					thisOutline.outline.genFill()					//thisOutline.outline.deleteKinks(Math.PI/10)					thisOutline.outline.genOrientation()				}								setGfxMask(thisOutline.outline.drawFill())							}		}				public function getNodesCollided(po:PhysOutline){			var outs =[new Array(), new Array()]			var search = true			var nodes = thisOutline.outline.nodesInOrder()						for(var i = 0 ; i <nodes.length ; i++){					var node = nodes[i]					var nodeExternalXY = node.thisCtdOutline.nodeExternalCoords(node)					var collision = po.getCollision(nodeExternalXY)					outs[0].push(collision[0])					outs[1].push(collision[1])			}			var altitudes = outs[0]			var bestAlt:Number			var bestIDX:Number = -1			var secondBestIDX = -1			var secondBestAlt:Number			for(i = 0 ; i <altitudes.length ; i ++){				if(bestIDX == -1 || altitudes[i] < bestAlt){					secondBestIDX = bestIDX					secondBestAlt = bestAlt					bestIDX = i					bestAlt = altitudes[i]				} else {					if ( secondBestIDX == -1 || altitudes[i] < secondBestAlt){							secondBestAlt = altitudes[i]							secondBestIDX = i					}				}			}			var bits = outs[1]			var closeBits = [bits[bestIDX],bits[secondBestIDX]]			var closeNodes= [nodes[bestIDX],nodes[secondBestIDX]]			return([closeNodes,closeBits])		}				public function getUniverseIndex():Number											{			var objWithIndex = this			var search = true			var sidx = 0			var objindex: Number						while (search){				if ( objWithIndex.childOf == null)					{						objindex = objWithIndex.thisUniverseIndex						search = false					} else {						objWithIndex = objWithIndex.childOf					}				sidx ++				if (sidx >10) { search = false}			}			return objindex		}		public function comRadius():Array													{			if (childOf == null){				return  null				} else {				return[x - childOf.getX(),y - childOf.getY(),0]			}		}		public function getSuper():PhysSuper 												{return thisUniverse.thisstage}		public function getOverlay():PhysOverlay 											{return thisUniverse.thisstage.thisOverlay}		public function isStaticIn(index:Number):Boolean									{			if (staticInFields.length <= index) { return false 				} else { 			return staticInFields[index] }		}		public function setStaticIn(index:Number,isStatic:Boolean):void 					{			if (staticInFields.length < (index + 1 )){				while(staticInFields.length < (index + 1)){					staticInFields.push(false)				}			}			staticInFields[index] = isStatic		}						public function setUniverse(physUniverse:PhysUniverse, i : Number):void{			thisUniverse = physUniverse			thisUniverseIndex = i			displayChildren()			setDefaults()			if(children!= null){				for(var j:Number = 0; j < children.length;j ++){					children[j].setUniverse(physUniverse,i)				}			}			thisUniverse.addChild(extraGFX)		}				public function setName(newName:String):void		{objName = newName}		public function setMass(newMass:Number):void		{			mass = newMass			if(thisUniverse != null){			if(thisUniverse.fieldIsGravity != -1){				setCustomCharge(thisUniverse.fieldIsGravity,mass)			}}		}		public function setCharge(newCharge:Number):void	{			charge = newCharge 			if(thisUniverse != null){			if(thisUniverse.fieldIsElectric != -1){				setCustomCharge(thisUniverse.fieldIsElectric,charge)			}}		}		public function setCustomCharge(index:Number, charge:Number):void{			if (customCharges.length < (index + 1 )){				while(customCharges.length < (index + 1)){					customCharges.push(0)				}			}			customCharges[index] = charge		}				public function getCustomCharge(index:Number):Number{			if (customCharges.length > index) {return customCharges[index]} else return 0		}				public function setXY(xy:Array):void				{moveTo([xy[0],xy[1]])}		public function setGraphic(newGraphic:DisplayObject){						var remove = true			while(remove){				try{					graphic.removeChildAt(0)				} catch (e:Error) {					remove = false				}			}			graphic.addChild(newGraphic)		}		public function setGfxMask(newGraphic:DisplayObject){			if(gfxMask != null){removeChild(gfxMask)}			addChild(newGraphic)			gfxMask = newGraphic			graphic.mask = gfxMask		}		public function addGraphic(newGraphic:DisplayObject){			graphic.addChild(newGraphic)		}		public function getSearchRadius():Number{return searchRadius}		public function getGraphic():Sprite{return graphic}		public function getX():Number{ if (childOf == null){return x} else {			return childOf.getX() + comRadius()[0]		}}		public function getY():Number{ if (childOf == null){return y} else {return childOf.getY() + comRadius()[1]}}		public function getCOMX():Number{			return getX() +COM[0] * Math.cos(angle) - COM[1] * Math.sin(angle)		}		public function getCOMY():Number{			return getY()+ COM[1] * Math.cos(angle) + COM[0] * Math.sin(angle)		}		public function get2Pts():Array{			//if (childOf == null){				var comXY = [getCOMX(),getCOMY()]				var units = getUnits()				var pts = [comXY[0] - units[0]* 10 , comXY[1] - units[1] * 10 ,comXY[0] + units[0] * 10, comXY[1] + units[1] * 10]				return pts		}		public function getDipole():Dipole{				var comXY = [getCOMX(), getCOMY()]				var masses = [mass/2,mass/2]				var charges = [charge/2,charge/2]				var ccEach = new Array(customCharges.length)				for(var i = 0 ; i < ccEach.length; i++){					ccEach[i] = customCharges[i] / 2				}				var dipoleCustomCharges = [ccEach,ccEach]				var radius =Math.sqrt( momentOfInertia / mass )				var units = getUnits()				var ptsXY = [[comXY[0] + units[0] * radius,comXY[1] + units[1] * radius],[comXY[0] -units[0] * radius, comXY[1] - units[1] * radius]]				var dipole = new Dipole(masses, charges, dipoleCustomCharges, ptsXY)				return dipole					}		public function getUnits():Array{			//Returns unit vectors for this object in the Universe Coordinate System			if( childOf != null){return childOf.getUnits()} else{			return [Math.cos(angle),Math.sin(angle),-1*Math.sin(angle),Math.cos(angle)]			}		}		public function getMass():Number{return mass}		public function unitUp():Array{			var units = getUnits()			return([ -1 * units[2], -1 * units[3] ] )		}		public function velocity():Array{			if (childOf == null){					var v = [xvel,yvel]					return v									} else{				var vParent = childOf.velocity()								var vInParent = [-1 * childOf.omega * comRadius()[1], childOf.omega*comRadius()[0]]				var vThis = [vParent[0]  + vInParent[0] , vParent[1] + vInParent[1]]				return vThis				}		}		public function KEOf():Number{			var v = velocity()			return (.5 * mass * ( Math.pow( v[0],2) + Math.pow(v[1],2)) + .5 * momentOfInertia * Math.pow(omega, 2))		}		public function eOfAt(xy:Array):Array{			var rx = xy[0] - getX()			var ry = xy[1] - getY()			var r = Math.max(Math.sqrt(Math.pow(rx,2) + Math.pow(ry,2)),minimumMeaningfulLengthScale)			var E= [kc * rx * charge / Math.pow(r,3), kc * ry * charge / Math.pow(r,3)]			return E		}		public function gOfAt(xy:Array):Array{						var rx = xy[0] - getX()			var ry = xy[1] - getY()				var r = Math.max(Math.sqrt(Math.pow(rx,2) + Math.pow(ry,2)),minimumMeaningfulLengthScale)			var g = [-G * rx * mass / Math.pow(r,3), -G * ry * mass / Math.pow(r,3)]			return g		}				public function inverseSquareOfAt(xy:Array):Array{			var rx = xy[0] - getX()			var ry = xy[1] - getY()			var r = Math.max(Math.sqrt(Math.pow(rx,2) + Math.pow(ry,2)),minimumMeaningfulLengthScale)			var f= [ rx  / Math.pow(r,3),  ry  / Math.pow(r,3)]			return f		}		public function inverseCubeOfAt(xy:Array):Array{			var rx = xy[0] - getX()			var ry = xy[1] - getY()			var r = Math.max(Math.sqrt(Math.pow(rx,2) + Math.pow(ry,2)),minimumMeaningfulLengthScale)			var f= [ rx  / Math.pow(r,3),  ry  / Math.pow(r,4)]			return f		}		public function inverseFirstOfAt(xy:Array):Array{			var rx = xy[0] - getX()			var ry = xy[1] - getY()			var r = Math.max(Math.sqrt(Math.pow(rx,2) + Math.pow(ry,2)),minimumMeaningfulLengthScale)			var f= [ rx  / Math.pow(r,3),  ry  / Math.pow(r,2)]			return f		}				public function exertImpulseOn(impulse:Array):void			{ 		if (childOf == null){			ftorqueThisTimeStep[0] += impulse[0] / PhysUniverse.timestep			ftorqueThisTimeStep[1] += impulse[1] / PhysUniverse.timestep		} else {			childOf.exertImpulseOn(impulse)			impulse.push(0)				var torqueImpulse = VectorMath3D.crossMultiply3D(comRadius(), impulse)   			childOf.exertTorqueImpulseOn( torqueImpulse)		}					}		public function exertImpulseAt(impulse:Array,xyAt:Array){			exertImpulseOn(impulse)			var xyRadius = [xyAt[0] - getCOMX(), xyAt[1] - getCOMY(), 0]			var torqueImpulse = VectorMath3D.crossMultiply3D(xyRadius, impulse)   			exertTorqueImpulseOn(torqueImpulse)								}		public function exertTorqueImpulseOn(impulse:Array):void	{			if (childOf == null) {					ftorqueThisTimeStep[2]+=impulse[2] /PhysUniverse.timestep				} else {				var rad = comRadius()				rad = [-1* rad[0] , -1 * rad[1]]				var radperp = [ -1 * rad[1],  rad[0]]				var radlength = Math.sqrt(Math.pow(rad[0],2) + Math.pow(rad[1],2))				var impulseMag = impulse[2] / Math.pow(radlength ,2)								childOf.exertImpulseOn([impulseMag * radperp[0], impulseMag * radperp[1]])								}		}				public function moveStep():void							{			var vel = velocity()						var displacement = [vel[0] *PhysUniverse.timestep, vel[1] * PhysUniverse.timestep]						moveBy(displacement)			lastXY = thisXY			thisXY = [getX(),getY()]						if(children != null){				for (var i = 0; i < children.length ; i++){					children[i].lastXY = children[i].thisXY					children[i].thisXY =[ children[i].getX(),children[i].getY()]				}			}					}		public function rigidMoveBy(xyMove):void				{			if (childOf ==null) {moveBy(xyMove)}else {				childOf.rigidMoveBy(xyMove)				}		}		public function rigidMoveTo(xyFinal):void				{			if (childOf ==null) {moveTo(xyFinal)} else{			 	var radius = comRadius()				var parentFinal = [xyFinal[0] - radius[0], xyFinal[1] - radius[1]]				childOf.rigidMoveTo(parentFinal)			}		}		public function movePtTowardsAboutFixedPt(ptXY:Array,fixedXY:Array,xyFinal:Array):void{										var vecFixedToFinal = [xyFinal[0] - fixedXY[0], xyFinal[1]  - fixedXY[1]]					var vecFixedToPt = [ptXY[0] - fixedXY[0], ptXY[1] - fixedXY[1]]					var magFTF = Math.sqrt(Math.pow(vecFixedToFinal[0] ,2) + Math.pow(vecFixedToFinal[1],2))					var magFTP = Math.sqrt(Math.pow(vecFixedToPt[0] ,2) + Math.pow(vecFixedToPt[1],2))					var unitFTF = [vecFixedToFinal[0] / magFTF, vecFixedToFinal[1]/magFTF]					var unitFTP = [vecFixedToPt[0]/magFTP,vecFixedToPt[1]/magFTP]										var angFTF = Math.asin(unitFTF[1])					if(unitFTF[0] < 0){ angFTF = Math.PI - angFTF }					var angFTP = Math.asin(unitFTP[1])					if(unitFTP[0] < 0){ angFTP = Math.PI - angFTP }										var angleDelta = angFTF - angFTP									rotateAroundBy(fixedXY,angleDelta)					}				public function moveAsChildTo(xyFinal:Array,...args):void{			var fixedChild:Number			if(args.length ==0){fixedChild = -1} else {fixedChild = args[0]}						if (childOf != null){				var displacement:Array,magD:Number,unitD:Array,angleD:Number,targetAngle:Number				if(fixedChild == -1){					 displacement = [xyFinal[0] - childOf.getX(), xyFinal[1] - childOf.getY()]					 magD = Math.sqrt(Math.pow(displacement[0],2) + Math.pow(displacement[1],2))					 unitD = [displacement[0] / magD, displacement[1]/ magD]					 angleD = Math.asin(unitD[1])					if(unitD[0] < 0){ angleD = Math.PI - angleD }					 targetAngle = angleD - angleInParentDefault					childOf.rotateTo(targetAngle)					rigidMoveTo(xyFinal)				} else {					var fixedXY = [childOf.children[fixedChild].getX(),childOf.children[fixedChild].getY()]										 displacement = [xyFinal[0] - fixedXY[0], xyFinal[1] - fixedXY[1]]					 magD = Math.sqrt(Math.pow(displacement[0],2) + Math.pow(displacement[1],2))					 unitD = [displacement[0] / magD, displacement[1]/ magD]					 angleD = Math.asin(unitD[1])					if(unitD[0] < 0){ angleD = Math.PI - angleD }					var defaultVectorThisInParent = [Math.cos(angleInParentDefault) * rInParentDefault, Math.sin(angleInParentDefault) * rInParentDefault]					var vectorAxisToParent = [childOf.getX() - fixedXY[0], childOf.getY() - fixedXY[1]]					var angP = childOf.angle					var unrotATP = [Math.cos(angP) * vectorAxisToParent[0] - Math.sin( -angP) * vectorAxisToParent[1], Math.cos(angP)*vectorAxisToParent[1] + Math.sin( -angP) * vectorAxisToParent[0]]					var axisToThis = [defaultVectorThisInParent[0] + unrotATP[0],defaultVectorThisInParent[1] + unrotATP[1]]					var magATT = Math.sqrt(Math.pow(axisToThis[0],2) + Math.pow(axisToThis[1],2))					var aTTUnit = [axisToThis[0] / magATT, axisToThis[1]/magATT]					var angleToThis = Math.asin(aTTUnit[1])					if(aTTUnit[0] < 0){ angleToThis = Math.PI - angleToThis }														 targetAngle = angleD - angleToThis					childOf.rotateAroundTo(fixedXY,targetAngle)																	}			}		}		public function moveAsChildBy(xyMove:Array, ...args):void{			var fixedChild:Number			if(args.length ==0){fixedChild = -1} else {fixedChild = args[0]}			if(childOf != null){				var xyFinal = [xyMove[0] + getX(), xyMove[1] + getY()]				moveAsChildTo(xyFinal,fixedChild)			}		}		public function moveBy(xyMove:Array):void				{				x += xyMove[0]				y += xyMove[1]				updateChildren()		}		public function moveTo(xyFinal:Array):void				{				x = xyFinal[0]				y = xyFinal[1]				updateChildren()		}				public function constrainedMoveStep():void{			var vel = velocity()			var displacement = [vel[0] *PhysUniverse.timestep, vel[1] * PhysUniverse.timestep]			var xyInit = constraint[1].thisCtdOutline.nodeExternalCoords(constraint[1])			var out = constraint[0].moveFromBy(xyInit,displacement)							var newXY = out[0]			var unitAlong = out[1]			var dot = out[2]			moveBy([newXY[0] - xyInit[0],newXY[1] - xyInit[1]])			var magV = Math.sqrt(Math.pow(vel[0],2) + Math.pow(vel[1],2))			var vNew = [magV * unitAlong[0] * dot , magV * unitAlong[1] * dot]						xvel = vNew[0]			yvel = vNew[1]									//accelerateBy([ftorqueThisTimeStep[0]/ mass,ftorqueThisTimeStep[1]/mass])					}				public function getForceApplied():Array					{			return [ftorqueThisTimeStep[0],ftorqueThisTimeStep[1]]		}		public function getTorqueApplied():Number				{			return ftorqueThisTimeStep[2]		}		public function accelerationOf():Array					{			var force = this.forceOn()			var ax = force[0] / mass			var ay = force[1] / mass			return [ax,ay]				}		public function forceAndTorqueOn():Array				{			var ftorque:Array			if (children == null){								ftorque =  forceOn()				ftorque.push(0)			} else{						var torque:Number = 0			ftorque = [0,0,0]							var force:Array				var r1:Array				var thisTorque:Array				for ( var i = 0 ; i < children.length ; i++){					force = children[i].forceOn()					ftorque[0] += force[0]					ftorque[1] += force[1]					force.push(0)					r1 = children[i].comRadius()					thisTorque = VectorMath3D.crossMultiply3D(r1,force)					ftorque[2] += thisTorque[2]				}			}			return ftorque					}		public function forceOn():Array							{		var force = [0,0]		var j:Number		if (children == null){			var i:Number			var thisforce:Array			for (j = 0; j < customCharges.length ; j++){  							if((customCharges[j] != 0) && (!isStaticIn(j)) ){									thisforce = thisUniverse.customChargeFields[j].forceOn(this)				force[0] += thisforce[0]				force[1] += thisforce[1]				}			}						} else {			 			var fthis:Array						for( i = 0 ; i< children.length; i++){				fthis = children[i].forceOn()				force[0] += fthis[0]				force[1] += fthis[1]			}			}			return force		}		public function accelerateBy(a:Array):void				{						xvel += a[0]* PhysUniverse.timestep  						yvel += a[1] *PhysUniverse.timestep		}		public function angularAccelerationOf():Number			{			if(momentOfInertia != 0){				var torque = torqueOn()				return torque / momentOfInertia			} else {return 0}		}		public function torqueOn():Number						{						var torque:Number = 0			if (children == null) {return 0} else {							var force:Array				var r1:Array				var thisTorque:Array				for ( var i = 0 ; i < children.length ; i++){					force = children[i].forceOn()					force.push(0)					r1 = children[i].comRadius()					thisTorque = VectorMath3D.crossMultiply3D(r1,force)					torque += thisTorque[2]				}				return torque					}		}		public function angularAccelerateBy(alpha:Number):void	{				omega += PhysUniverse.timestep * alpha		}						public function rotateStep()						{			rotateBy(omega * PhysUniverse.timestep)		}		public function rotateBy(radians:Number):void		{			if(childOf == null){				angle += radians				this.rotation = angle * 180 / Math.PI				updateChildren()			} else { childOf.rotateBy(radians) }		}		public function rotateTo(angleRadians:Number):void	{			if(childOf == null){				angle = angleRadians				updateChildren()			} else {childOf.rotateTo(angleRadians)}		}				public function rotateAroundBy(xyRotAround:Array,angleRadians:Number):void{			if(childOf == null){				var toAxis = [xyRotAround[0] - getX(),xyRotAround[1] - getY()]				rotateBy(angleRadians)				var axisNewPositionX = [Math.cos(angleRadians) * toAxis[0] - Math.sin(angleRadians) * toAxis[1]]				var axisNewPositionY = [Math.cos(angleRadians) * toAxis[1] + Math.sin(angleRadians) * toAxis[0]]				var axisDisplacement = [axisNewPositionX - toAxis[0], axisNewPositionY - toAxis[1]]				rigidMoveBy([-1 * axisDisplacement[0], -1 * axisDisplacement[1]])			} else { childOf.rotateAroundBy(xyRotAround,angleRadians) }																			}		public function rotateAroundTo(xyRotAround:Array,angleRadians:Number):void{			if(childOf == null){				var deltaAngle = angleRadians - angle				rotateAroundBy(xyRotAround,deltaAngle)			} else {childOf.rotateAroundTo(xyRotAround,angleRadians) }		}				public function dampenStep():void					{dampen([.9,.9,.9])}		public function dampen(args,...extra):void			{			var dampenForce:Boolean			if(extra.length ==0){dampenForce = false} else {dampenForce = args[0]}						var wdamp:Number			var xdamp:Number			var ydamp:Number			if (args.length ==0){xdamp = 1; ydamp = 1 ; wdamp = 1} else {				if (args.length ==1) {xdamp = args[0] ; ydamp = args[0] ; wdamp = args[0]} else {					if (args.length ==2) {xdamp = args[0] ; ydamp = args[1] ; wdamp =1} else {						if (args.length ==3 ) {xdamp = args[0];ydamp = args[1] ; wdamp = args[2]}					}				}			}						if (childOf == null){			xvel *= xdamp			yvel *= ydamp			omega *= wdamp						if(dampenForce){				ftorqueThisTimeStep[0] *= xdamp				ftorqueThisTimeStep[1] *= ydamp				ftorqueThisTimeStep[2] *= wdamp			}						} else{				childOf.dampen([xdamp,ydamp,wdamp,dampenForce])			}		}						public function dampenAlong(unit, k, ...args):void	{			var dampenForce:Boolean			if(args.length ==0){dampenForce = false} else {dampenForce = args[0]}			if (childOf == null){			var unitPerp = [ -1 * unit[1], unit[0] ]			var vAlong = VectorMath2D.dotMultiply2D(unit,[xvel,yvel])			var vPerp = VectorMath2D.dotMultiply2D(unitPerp, [xvel,yvel])			vAlong = vAlong * k						xvel = unitPerp[0] * vPerp + unit[0] * vAlong			yvel = unitPerp[1] * vPerp + unit[1] * vAlong			if(dampenForce){				var fAlong = VectorMath2D.dotMultiply2D(unit,[ftorqueThisTimeStep[0],ftorqueThisTimeStep[1]])				var fPerp = VectorMath2D.dotMultiply2D(unitPerp,[ftorqueThisTimeStep[0],ftorqueThisTimeStep[1]])				fAlong = fAlong * k											ftorqueThisTimeStep[0] = unitPerp[0] * fPerp + unit[0] * fAlong				ftorqueThisTimeStep[1] = unitPerp[1] * fPerp + unit[1] * fAlong			}						} else{				childOf.dampenAlong(unit,k,dampenForce)			}		}		public function cancelForces(... args)				{			var k:Number			if (args.length ==0) { k = 1 } else { k = args[0]}			var f = forceOn()			exertImpulseOn([ - k * f[0] * PhysUniverse.timestep, -k * f[1] * PhysUniverse.timestep])					}		public function cancelAppliedForces():void			{			ftorqueThisTimeStep = [0,0,ftorqueThisTimeStep[2]]		}		public function cancelAppliedTorques():void			{			ftorqueThisTimeStep = [ftorqueThisTimeStep[0],ftorqueThisTimeStep[1],0]		}		public function objMouseDown(event:MouseEvent)		{						var thistime = flash.utils.getTimer()			if (thistime - lastclicktimer < 400) {isstatic = ! isstatic} 			lastclicktimer = thistime			if (isDraggable){			startDrag()			dragTicker = 0			dragging = true			pastx = new MathArray()			pasty = new MathArray()			pastx.push(x)			pasty.push(y)			}		} 							public function objMouseUp(event:MouseEvent)		{				if (isDraggable){			stopDrag()			dragging = false			xvel = pastvx.mean()    / PhysUniverse.timestep			yvel = pastvy.mean()	/ PhysUniverse.timestep		}					}		public function objEnterFrame(event:Event)			{			if (dragging){			dragTicker++			if (dragTicker % 2 ==0){														pastx.push(x);				pasty.push(y); 				if (pastx.length > 3){					pastx.shift()					pasty.shift()				}								pastvx = new MathArray()				pastvy = new MathArray()				for ( var i:Number = 0 ; i <( pastx.length -1 ); i ++) {					pastvx.push(( pastx[i + 1] - pastx[i]	)/2)				pastvy.push(( pasty[i + 1] - pasty[i]   )/2)				}			xvel = pastvx.mean()    / PhysUniverse.timestep			yvel = pastvy.mean()	/ PhysUniverse.timestep			}			}			}							public function destroyDefault():void{			thisUniverse.thisstage.removeDrawnObject(this)			destroy()		}		public function destroy():void{}						}}