package physics.objects.oscript{	import physics.twobody.TwoBodyCollision	import physics.PhysUniverse	import physics.objects.PhysObject	import flash.geom.Rectangle	import math.graphs.MovingGraph	import flash.display.Sprite	import flash.display.Shape	import flash.display.BitmapData	import flash.display.Bitmap	import flash.geom.Matrix		import math.VectorMath2D	import flash.utils.getTimer			public class attachedToObject extends ObjectScript{				public static var s:Shape				public var objAttachedTo		public var nodesAttached		public var bindingForceConstant = 1		var kOut = 10, kIn = 5, kOn = .05				var bindingMaxDistance = 20		var bindingMaxForceConstant = 3		var bindingMaxVelocity = 800					public var surfaceUnits:Array		public var surfacePoints:Array			public var sfcPtAvg:Array		public var sfcUnitsAvg:Array				public var isInside = false		public var wasInside:Boolean					public var mGraph:MovingGraph									 function friction():void{			thisObject.dampen([.9,.9,.8])			if(frame == 1){thisObject.dampen([.8,.8,.8])}		 }				 function alignWithSurface():void{			var node0XY =  nodesAttached[0].thisCtdOutline.nodeExternalCoords(nodesAttached[0])			var a0 = [node0XY[0] - surfacePoints[0][0] , node0XY[1] - surfacePoints[0][1]]			thisObject.moveBy([ -1 * a0[0], -1 * a0[1]])			//trace(a0,"A")			 node0XY =  nodesAttached[0].thisCtdOutline.nodeExternalCoords(nodesAttached[0])			var uUp = thisObject.unitUp()			var ptAbove =  [node0XY[0] + uUp[0]*5, node0XY[1] + uUp[1]*5]			var ptSfc = [node0XY[0] + surfaceUnits[0][2]*5, node0XY[1] + surfaceUnits[0][3]*5]			thisObject.movePtTowardsAboutFixedPt(ptAbove,node0XY,ptSfc)			var node1XY =  nodesAttached[1].thisCtdOutline.nodeExternalCoords(nodesAttached[1])			var outline = objAttachedTo.thisOutline.outline			var pt = node1XY			var surfaceBit = outline.closest(pt)			var localXY = outline.localCoords(pt)			var sfcPt = surfaceBit.ptBitClosest(localXY,true) 						var keepRotating = true			var loops = 0			while(keepRotating){				loops ++				//trace(sfcPt,"SFC")				thisObject.movePtTowardsAboutFixedPt(node1XY,node0XY,sfcPt)						//trace("pt",node1XY,sfcPt,node0XY)					node1XY =  nodesAttached[1].thisCtdOutline.nodeExternalCoords(nodesAttached[1])				if(Math.sqrt(Math.pow(node1XY[0] - sfcPt[0] , 2) + Math.pow(node1XY[1] - sfcPt[1],2)) < 5){					keepRotating = false				} else {						 outline = objAttachedTo.thisOutline.outline						 pt = node1XY							 surfaceBit = outline.closest(pt)						 localXY = outline.localCoords(pt)						 sfcPt = surfaceBit.ptBitClosest(localXY,true) 						//trace("pt",node1XY)						if(loops > 4){keepRotating = false}										}						}			//trace(thisObject.getX())		}		public function testDetach():Boolean{			var d = false			if(thisObject.mustDetach()){				d = true				thisObject.setDetachPronto(false)			}			return d		}		public function detach():void{				thisObject.constraint = null				scriptDone = true				spawnDetached()		}					override public function advance(...args):void{			if(objAttachedTo.isDestroyed){				detach()				return			}						var step = args[0]			if(step == 0 || step == 1){				if(testDetach()){					thisObject.constraint = null					detach()				}			}			if(step == 1) {				//NOW ONLY THE FRONT NODE IS ATTACHED				if(nodesAttached[0].x < 0 && nodesAttached[1].x > 0){nodesAttached.reverse();}				thisObject.constraint = [objAttachedTo.thisOutline.outline, nodesAttached[0]]				//thisObject.sleep()						//the function of moveNoPull is basically to attach a bit rather than a node to an outline.				var tol = 3 // A tolerance in pixels to consider a point "attached"					var outline = thisObject.constraint[0]								var attached = thisObject.getNodesCollided(outline.object.thisOutline)					var depthsForward = new Array(2)				var depthsBackward= new Array(2)				var ptsForward = new Array(2)				var ptsBackward = new Array(2)				var angles = new Array(2)				var closests = new Array(2)								var markGood = new Array(2)				thisObject.thisUniverse.setExtraGraphics(new Sprite())					for(var i = 0 ; i < 2 ; i ++){									if(i == 0 ){						var n1 = attached[0][0]						} else {						n1 =  attached[0][0].prev						}					var n1XY = n1.getXY()					var n2 = n1.next					var n2XY = n2.getXY()										var bitMid = [(n1XY[0] + n2XY[0])/2 ,( n1XY[1] + n2XY[1])/2]						var closest = outline.closest(bitMid)					closests[i] = closest					var units = n1.thisCtdOutline.getUnitsExt(n1,false)					var unitIn = [-units[2],-units[3]]					var sfcUnits = outline.getUnitsExt(closest)										angles[i] = VectorMath2D.angle1To2([sfcUnits[2],sfcUnits[3]],unitIn)					var out = outline.findDepths(closest.next,unitIn,[n1XY,n2XY])					depthsForward[i] = out[1][0]					depthsBackward[i] = out[1][1]					ptsForward[i] = out[0][0]					ptsBackward[i] = out[0][1]									}						// Right now I do not need to search both nodes because I am judging as based only on angles...				if(Math.abs(angles[0]) <Math.abs(angles[1])){					var idxBest = 0				} else{ 					idxBest = 1				}								if(idxBest == 0 ){					var n1 = attached[0][0]					} else {					n1 =  attached[0][0].prev					}				var n1XY = n1.getXY()				var n2 = n1.next				var n2XY = n2.getXY()				var bitMid = [(n1XY[0] + n2XY[0])/2 ,( n1XY[1] + n2XY[1])/2]								var dFwd = depthsForward[idxBest]				var dBkwd= depthsBackward[idxBest]				var pFwd = ptsForward[idxBest]				var pBkwd= ptsBackward[idxBest]								var fMax = Number.NEGATIVE_INFINITY				var bMax = Number.NEGATIVE_INFINITY				for( i = 0; i < dFwd.length ; i++){					if(dFwd[i] > fMax){						fMax = dFwd[i]						var iFwd = i					}				}				for( i = 0; i < dBkwd.length ; i++){					if(dBkwd[i] > bMax){						bMax = dBkwd[i]						var iBkwd = i					}				}					var torqueFree = false				var useMid = ( (dFwd[0] - dFwd[iFwd]) > -tol) && ((dBkwd[0] -dBkwd[iBkwd]) > -tol)				if((iFwd == 0 && iBkwd == 0) || ( useMid ) ){										closest = closests[idxBest]					var attachedUnits = closest.thisCtdOutline.getUnitsExt(closest)					thisObject.rotateAroundBy(bitMid,-angles[idxBest])					var localCoords = closest.thisCtdOutline.localCoords(bitMid)					var closestPt = closest.ptBitClosest(localCoords,true)					var m0 = [closestPt[0] - bitMid[0],closestPt[1] - bitMid[1]]										var n1XY = n1.getXY()					var n2XY = n2.getXY()					var bitMid = [(n1XY[0] + n2XY[0]) / 2, (n1XY[1] + n2XY[1]) / 2]										var attachedPt = bitMid					torqueFree = true				} else {				if(iFwd != 0 && iBkwd == 0){					var pt = pFwd[iFwd]					var local = n1.thisCtdOutline.localCoords(pt)					attachedPt = n1.ptBitClosest(local,true)					m0 = [pt[0] - attachedPt[0],pt[1] - attachedPt[1]]					closest = outline.closest(attachedPt)					attachedUnits = closest.thisCtdOutline.getUnitsExt(closest)									} else {				if(iFwd == 0 && iBkwd != 0){					var pt = pBkwd[iBkwd]					var local = n1.thisCtdOutline.localCoords(pt)					attachedPt = n1.ptBitClosest(local,true)					m0 = [pt[0] - attachedPt[0],pt[1] - attachedPt[1]]					closest = outline.closest(attachedPt)					attachedUnits = closest.thisCtdOutline.getUnitsExt(closest)									} else {				if(dFwd[iFwd] > dBkwd[iBkwd]){					var pt = pFwd[iFwd]					var local = n1.thisCtdOutline.localCoords(pt)					attachedPt = n1.ptBitClosest(local,true)					m0 = [pt[0] - attachedPt[0],pt[1] - attachedPt[1]]					closest = outline.closest(attachedPt)					attachedUnits = closest.thisCtdOutline.getUnitsExt(closest)					} else {				if(dFwd[iFwd] < dBkwd[iBkwd]){					var pt = pBkwd[iBkwd]					var local = n1.thisCtdOutline.localCoords(pt)					attachedPt = n1.ptBitClosest(local,true)					m0 = [pt[0] - attachedPt[0],pt[1] - attachedPt[1]]					closest = outline.closest(attachedPt)					attachedUnits = closest.thisCtdOutline.getUnitsExt(closest)							} else {					trace("HUH?")				}				}}}}					thisObject.moveBy(m0)				if(! torqueFree) {				var impulses = TwoBodyCollision.inelasticCollideObjs([thisObject,outline.object],attachedPt,attachedUnits,true)				} else {					impulses = TwoBodyCollision.inelasticSimpleObjs([thisObject,outline.object],attachedUnits,true)				}				var v = thisObject.getNextVel()				thisObject.exertImpulseAt([impulses[0][0] *1.1,impulses[0][1] *1.1],attachedPt)				var s = new Sprite()				var magImpulse = Math.sqrt(Math.pow(impulses[0][0],2) + Math.pow(impulses[0][1],2))				var impulseDraw = [impulses[0][0]/magImpulse * 50,impulses[0][1]/magImpulse * 50]				s.graphics.lineStyle(0,0xFF0000)				s.graphics.drawCircle(attachedPt[0],attachedPt[1],5)				s.graphics.drawCircle(thisObject.getCOM()[0],thisObject.getCOM()[1],10)				s.graphics.moveTo(attachedPt[0],attachedPt[1])				s.graphics.lineTo(attachedPt[0] + impulseDraw[0], attachedPt[1] + impulseDraw[1])				s.graphics.moveTo(attachedPt[0],attachedPt[1])				s.graphics.lineTo(attachedPt[0] + v[0], attachedPt[1] + v[1])				thisObject.thisUniverse.addExtraGraphic(s)						friction()											}						}		public function spawnDetached():void{			var newScript = new detachFromObj()			newScript.setAttachedTo(objAttachedTo)			thisObject.addObjectScript(newScript)		}		public function setAttachedTo(obj:PhysObject):void{			objAttachedTo = obj			multiPriorities = true		}		public function setWhichAttached(nodes:Array):void{			nodesAttached = nodes		}			}}