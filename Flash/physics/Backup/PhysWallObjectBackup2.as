package physics{	import flash.display.Bitmap;	import flash.display.BitmapData;	import flash.geom.Matrix;	import flash.geom.ColorTransform;	import flash.geom.Point	import flash.events.MouseEvent;	import flash.events.Event;	import flash.display.Shape;	import flash.display.Sprite;	import flash.geom.Rectangle;	import flash.utils.getTimer;	import math.VectorMath2D;	import math.VectorMath3D;	import mygraphics.PtObj		public class PhysWallObject extends PhysWall {		public var drawRadii:Boolean = false		public var tracer:Sprite;		public var unitArrow:Shape;		public var twoRadii:Shape;		public static  var lastbmp:Bitmap;		public static var unitSprite		public var xCenters:Array;		public var yCenters:Array;		public var massFracs:Array;		public var chargeFracs:Array;		public var massWeights:Array;		public var chargeWeights:Array;				public function setCenters(xs:Array,ys:Array):void {			xCenters = xs;			yCenters = ys;			massWeights = new Array();			chargeWeights = new Array();			for (var i = 0; i < xs.length; i++) {				massWeights.push(1);				chargeWeights.push(1);			}			calculateFracs();		}		public function addCenter(xAdd:Number,yAdd:Number):void {			if ( xCenters == null) {				xCenters = new Array ;				yCenters = new Array ;				massWeights = new Array ;				chargeWeights = new Array;			}			xCenters.push(xAdd);			yCenters.push(yAdd);			massWeights.push(1);			chargeWeights.push(1);			calculateFracs();		}		function calculateFracs():void {			var l = xCenters.length;			var cWeightTotal = 0;			var mWeightTotal = 0;			massFracs = new Array(l);			chargeFracs = new Array(l)			;			for (var i = 0; i < l; i++) {				cWeightTotal+= chargeWeights[i];				mWeightTotal+= massWeights[i];			}			if (cWeightTotal == 0) {				cWeightTotal = 1;			}			if (mWeightTotal ==0) {				mWeightTotal = 1;			}			for (i = 0; i< l; i++) {				massFracs[i] = massWeights[i] / mWeightTotal;				chargeFracs[i] = chargeWeights[i] / cWeightTotal;			}		}		public function getXCenters() {			var newXCenters = new Array();			if(xCenters == null){xCenters = [0]}			for (var i  = 0; i < xCenters.length; i++) {				newXCenters[i] = xCenters[i] + getX();			}			return newXCenters;		}		public function getYCenters() {			var newYCenters = new Array();			if(yCenters == null){yCenters = [0]}			for (var i  = 0; i < yCenters.length; i++) {				newYCenters[i] = yCenters[i] + getY();			}			return newYCenters;		}		public function getNearestCenter(object:PhysObject):Array {			if (xCenters == null) {				return [getX(),getY()];			} else {				var newXCenters = getXCenters();				var newYCenters = getYCenters();				var objX = object.getX();				var objY = object.getY();				var l = newXCenters.length;				var abs = Math.sqrt(Math.pow(objX - newXCenters[0],2) + Math.pow(objY - newYCenters[0],2));				var idxAbs = 0;				var temp:Number;				for (var i = 1; i < l; i ++) {					temp = Math.sqrt(Math.pow(objX - newXCenters[i],2) + Math.pow(objY - newYCenters[i],2));					if (temp < abs) {						abs = temp;						idxAbs = i;					}				}				var output = xCenters;				return [newXCenters[idxAbs],newYCenters[idxAbs]];			}		}		public function getNearestCenterToPt(pt:Array):Array {			if (xCenters == null) {				return [getX(),getY()];			} else {				var newXCenters = getXCenters();				var newYCenters = getYCenters();				var objX = pt[0];				var objY = pt[1];				var l = newXCenters.length;				var abs = Math.sqrt(Math.pow(objX - newXCenters[0],2) + Math.pow(objY - newYCenters[0],2));				var idxAbs = 0;				var temp:Number;				for (var i = 1; i < l; i ++) {					temp = Math.sqrt(Math.pow(objX - newXCenters[i],2) + Math.pow(objY - newYCenters[i],2));					if (temp < abs) {						abs = temp;						idxAbs = i;					}				}				var output = xCenters;				return [newXCenters[idxAbs],newYCenters[idxAbs]];			}		}		override public function getCOMX():Number{			if(massFracs != null){			if (xCenters.length == 0){return getX()} else{				var newX = getXCenters()				var COMX = 0				for (var i = 0; i < newX.length ; i++){					COMX += massFracs[i] * newX[i]				}				return COMX						}} else{ return getX() }		}		override public function getCOMY():Number{			if(massFracs != null){			if (yCenters.length == 0){return getY()} else{				var newY = getYCenters()				var COMY = 0				for (var i = 0; i < newY.length ; i++){					COMY += massFracs[i] * newY[i]				}				return COMY			} } else { return getY() }				}						override public function eOfAt(xy:Array):Array {			var newXCenters = getXCenters();			var newYCenters = getYCenters();			var E:Array = [0,0];			var rx:Number;			var ry:Number;			var r:Number;			for (var i = 0; i < xCenters.length; i++) {				rx = xy[0] - newXCenters[i];				ry = xy[1] - newYCenters[i];				r = Math.sqrt(Math.pow(rx,2) + Math.pow(ry,2));				E[0] += kc * rx * chargeFracs[i] *charge / Math.pow(r,3) ;				E[1] += kc * ry * chargeFracs[i] * charge/ Math.pow(r,3);			}			return E;		}		override public function gOfAt(xy:Array):Array {			var newXCenters = getXCenters();			var newYCenters = getYCenters();			var g:Array = [0,0];			var rx:Number;			var ry:Number;			var r:Number;			for (var i = 0; i < xCenters.length; i++) {				rx = xy[0] - newXCenters[i];				ry = xy[1] - newYCenters[i];				//trace(rx)				//trace(ry)				r = Math.sqrt(Math.pow(rx,2) + Math.pow(ry,2));				g[0] += -G * rx * massFracs[i] * mass /  Math.pow(r,3) ;				g[1] += -G * ry * massFracs[i] * mass /  Math.pow(r,3);				//trace(g)			}			return g;		}		override public function inverseSquareOfAt(xy:Array):Array{			var newXCenters = getXCenters();			var newYCenters = getYCenters();			var f:Array = [0,0];			var rx:Number;			var ry:Number;			var r:Number;					var fThis:Array;						for (var i = 0; i < xCenters.length; i++) {						 rx = xy[0] - newXCenters[i];						 ry = xy[1] - newYCenters[i];						 r = Math.max(Math.sqrt(Math.pow(rx,2) + Math.pow(ry,2)),minimumMeaningfulLengthScale)						 fThis = [ rx  / Math.pow(r,3),  ry  / Math.pow(r,3)]						 f[0] += fThis[0]						 f[1] += fThis[1]						}			return f		}		override public function inverseCubeOfAt(xy:Array):Array{			var newXCenters = getXCenters();			var newYCenters = getYCenters();			var f:Array = [0,0];			var rx:Number;			var ry:Number;			var r:Number;					var fThis:Array;						for (var i = 0; i < xCenters.length; i++) {						 rx = xy[0] - newXCenters[i];						 ry = xy[1] - newYCenters[i];						 r = Math.max(Math.sqrt(Math.pow(rx,2) + Math.pow(ry,2)),minimumMeaningfulLengthScale)						 fThis = [ rx  / Math.pow(r,3),  ry  / Math.pow(r,3)]						 f[0] += fThis[0]						 f[1] += fThis[1]						}			return f		}		override public function inverseFirstOfAt(xy:Array):Array{			var newXCenters = getXCenters();			var newYCenters = getYCenters();			var f:Array = [0,0];			var rx:Number;			var ry:Number;			var r:Number;					var fThis:Array;						for (var i = 0; i < xCenters.length; i++) {						 rx = xy[0] - newXCenters[i];						 ry = xy[1] - newYCenters[i];						 r = Math.max(Math.sqrt(Math.pow(rx,2) + Math.pow(ry,2)),minimumMeaningfulLengthScale)						 fThis = [ rx  / Math.pow(r,3),  ry  / Math.pow(r,3)]						 f[0] += fThis[0]						 f[1] += fThis[1]						}						//trace(["AAAA",thisUniverseIndex,getXCenters(),f])			return f		}						public function hitTest(obj:PhysObject,units:Array):Number {			var indexhit = -1;						var collisiondepth = 0;			var angle12 = Math.sin(units[1])						if (units[0] < 0){angle12 = Math.PI - angle12}						var rotateRadians = -1 * angle12;			var intersection = PhysCollisions.physHitTestIrregular(obj.getGraphic(), getGraphic() ,thisUniverse,rotateRadians);			if ((intersection != null)) {				collisiondepth = intersection.height;			}			return collisiondepth;		}				public function collision(ParentObject:PhysObject):void {			if (ParentObject.children != null) {				complexBodyCollision(ParentObject,ParentObject.children);			} else {				simpleCollision(ParentObject);			}		}		public function simpleCollision(parentObj:PhysObject):void {			var units:Array			var uTemp = getUnitsToObject(parentObj)						if (uTemp != null){					units = uTemp				} else{					units = parentObj.getUnits()				}			var depthCollided:Number			var anyCollisions = false;			depthCollided = hitTest(parentObj,units);			if (depthCollided > 0) { anyCollisions = true}						if (anyCollisions) {				parentObj.collided()				var nColl  = 1;				var skinDepths = getSkinDepths(depthCollided)				dampenObject(parentObj,nColl,skinDepths)				exertImpulse(parentObj,units)				exertSecondImpulse(parentObj, skinDepths,units)				secondDampenObject(parentObj,nColl,skinDepths)							}									}		public function getSkinDepths(collisionDepth:Number):Number{			var skinDepth = 10			return(collisionDepth / skinDepth)		}		public function exertImpulse(object:PhysObject,units:Array):void{																	var unitPar = [units[0],units[1]];					var unitPerp= [units[2],units[3]];											var rChild = object.comRadius();					if (rChild != null){						var distanceParalellToWall = VectorMath2D.dotMultiply2D(unitPar,rChild);						var equivalentMass = 1 / (Math.pow(distanceParalellToWall , 2) / object.childOf.momentOfInertia + 1 / object.childOf.mass);							var vParent = object.childOf.velocity();						var vChild  = VectorMath3D.crossMultiply3D([0,0,object.childOf.omega], [unitPar[0] *distanceParalellToWall,unitPar[1]*distanceParalellToWall,0]);						var vPerp   = VectorMath2D.dotMultiply2D([vParent[0] + vChild[0],vParent[1] + vChild[1]],unitPerp)													var theImpulse = -1 * 2 * equivalentMass  * (vPerp) 									if (object.numConsecutiveWallHits ==0 ) {							object.exertImpulseOn([theImpulse * unitPerp[0], theImpulse * unitPerp[1]]);						}					}		}		public function exertSecondImpulse(object:PhysObject, skinDepths:Number,units:Array){												var unitPar = [units[0],units[1]];						var unitPerp= [units[2],units[3]]						var f:Array												if( object.childOf != null){ f = object.childOf.forceOn()} else{							 f = object.forceOn()}													var magF = Math.sqrt(Math.pow(f[0],2) + Math.pow(f[1],2))												//Now, the directions of the force are defined...						var fUnitPar =  [ f[0] / magF,  f[1]/ magF];						var fUnitPerp = [ fUnitPar[1], - fUnitPar[0]]												//and Now, the dot product of rChild with the force vector												var massFrac:Number						if (object.childOf !=null){							var rChildPerp = VectorMath2D.dotMultiply2D(fUnitPerp, object.comRadius());							var equivalentMass = 1 / (Math.pow(rChildPerp , 2) / object.childOf.momentOfInertia + 1 / object.childOf.mass);							 massFrac = equivalentMass/object.childOf.mass						} else { massFrac = 1}												var fOnMag   = magF * massFrac												var k = Math.sqrt( Math.min(skinDepths,20) / PhysUniverse.timestep / 10)						var fOnChildAgainst = [ unitPerp[0] * fOnMag * k,  unitPerp[1] * fOnMag * k];						object.exertImpulseOn([fOnChildAgainst[0] * PhysUniverse.timestep,fOnChildAgainst[1] * PhysUniverse.timestep]);						//object.cancelForces(skinDepths/2);		}		public function dampenObject(object:PhysObject, nColl:Number, skinDepths:Number):void{												if (object.childOf != null ){object.childOf.dampen(getDamping(skinDepths,nColl,object.numConsecutiveWallHits,true))} else {								object.dampen(getDamping(skinDepths,nColl,object.numConsecutiveWallHits,true))}		}		public function getDamping( skinDepth:Number, numChildrenCollided:Number, numCollisionsChild:Number, incoming:Boolean):Array {			var vdamp:Number			var wdamp:Number			if (numCollisionsChild == 0 ){vdamp = .9} else {vdamp = .9}			if (numChildrenCollided >= 0){wdamp = .9 } else {wdamp =.9 }						var xdamp = vdamp			var ydamp = vdamp			return([xdamp, ydamp, wdamp])								}		public function secondDampenObject(object:PhysObject, nColl:Number, skinDepths:Number):void{						if (object.childOf != null ){object.childOf.dampen(getDamping(skinDepths,nColl,object.numConsecutiveWallHits,false))} else {								object.dampen(getDamping(skinDepths,nColl,object.numConsecutiveWallHits,false))}					}				public function complexBodyCollision(parentObject:PhysObject, children:Array) {			var l = children.length;			var hasCollided = new Array(l);			var depthCollided = new Array(l);			var anyCollisions = false;			var collision:Number;			var uTemp:Array						var units = new Array(l+1)			for (var i = 0; i < l; i++) {				drawRadii = (i == 0)				var t = flash.utils.getTimer()				uTemp = getUnitsToObject(children[i])				if (uTemp != null){					units[i] = uTemp				} else{					units[i] = children[i].getUnits()				}				collision = hitTest(children[i],units[i]);				if (collision == 0 ) {					hasCollided[i] = false;				} else {					hasCollided[i] = true;					depthCollided[i] = collision;					anyCollisions = true;					children[i].hasCollided = true;				}			}			uTemp = getUnitsToObject(parentObject)						if (uTemp != null){					units[l] = uTemp				} else{					units[l] = parentObject.getUnits()				}							if (unitSprite == null){				unitSprite = new Sprite()				thisUniverse.addChild(unitSprite)			}			unitSprite.graphics.clear()			for(i = 0; i< l ; i++){			unitSprite.graphics.lineStyle(1)			unitSprite.graphics.moveTo(children[i].getX(),children[i].getY())			unitSprite.graphics.lineTo(children[i].getX() + units[i][2]*50,children[i].getY() + units[i][3]*50)			}						if (anyCollisions) {				parentObject.collided()				var skinDepths:Array = new Array(l)				var nColl  = 0;								for (i =0; i < l; i++) {					skinDepths[i] = getSkinDepths(depthCollided[i])					if (hasCollided[i]) {						nColl++;					}				}				for (i =0; i < l; i++) {					if (hasCollided[i]) {						dampenObject(children[i],nColl,skinDepths[i])					}				}				for (i =0; i < l; i++) {					if (hasCollided[i]) {						exertImpulse(children[i],units[i])					}				}				for (i =0; i < l; i++) {					if (hasCollided[i]) {						exertSecondImpulse(children[i], skinDepths[i], units[l])					}				}				for (i =0; i < l; i++) {					if (hasCollided[i]) {						secondDampenObject(children[i],nColl,skinDepths[i])					}				}			}		}	}}