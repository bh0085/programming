package paths{	import flash.display.Shape	import flash.display.Sprite	import flash.display.DisplayObject	import flash.display.BlendMode	import flash.display.BitmapData	import flash.display.Bitmap	import flash.text.TextField	import flash.geom.Matrix	import flash.geom.Rectangle	import flash.geom.Point	import flash.geom.ColorTransform	import flash.utils.getTimer	import physics.objects.PhysObject	import physics.PhysUniverse		import mygraphics.ObjObj	import math.VectorMath2D		public class PhysOutline {		public var outline:CtdOutline		public var holes:Array				public function setObject(po:PhysObject){			outline.setObject(po)			for(var i = 0; i<holes.length; i++){				holes[i].setObject( po )			}		}				public static function sphereOutline(radius:Number,nPoints:Number,...args):PhysOutline{			if(args.length == 0){var midXY = [0,0]} else { midXY = args[0] }			var thisOutline = new PhysOutline()			var o = new CtdOutline()			var num = nPoints			for(var i = 0 ; i < num ; i++){				var angle = Math.PI * 2 * i / (num)				var nxy = [Math.cos(angle) * (radius ) + midXY[0], Math.sin(angle) * (radius) + midXY[1]]				var node = new Node(nxy[0],nxy[1])				o.pushNode(node)							}			thisOutline.setOutline(o)			thisOutline.outline.genFill()			thisOutline.outline.genOrientation()			thisOutline.outline.genSegments()			return thisOutline					}		public static function irregularSphereOutline(irregularity:Number,radius:Number,nPoints:Number,...args):PhysOutline{			if(args.length == 0){var midXY = [0,0]} else { midXY = args[0] }			var thisOutline = new PhysOutline()			var o = new CtdOutline()			var num = nPoints			for(var i = 0 ; i < num ; i++){				var angle = Math.PI * 2 * i / (num )				var nxy = [Math.cos(angle) * - (radius +radius*  Math.random() *irregularity) + midXY[0], Math.sin(angle) * (radius + radius *irregularity* Math.random()) + midXY[1]]				var node = new Node(nxy[0],nxy[1])				o.pushNode(node)							}			thisOutline.setOutline(o)			thisOutline.outline.genFill()			thisOutline.outline.genOrientation()			thisOutline.outline.genSegments()			return thisOutline					}				public function PhysOutline(){			holes = new Array()		}		public function setOutline(o:CtdOutline):void{			outline = o		}	  		public static function findCrossingPts(o1:DisplayObject, o2:DisplayObject):Array{						var t = new Array()			t.push(flash.utils.getTimer())				o2.blendMode = BlendMode.ADD				var s2 = new Sprite()				var s1 = new Sprite()				s1.addChild(o1)				s2.addChild(o2)				var b1 = o1.getBounds(s1)				var  b2 = o2.getBounds(s2)				var b0 = b1.intersection(b2)				if(b0.height == 0){					trace("no intersection in drawing")					return null				}				//Most of the time is invested in drawing the two pieces of data and creating the bitmapdata itself				var data = new BitmapData(b0.width,b0.height,false,0x000000)				var mat = new Matrix(1,0,0,1,-b0.x,-b0.y)							data.draw(s1,mat, new ColorTransform(1,1,1,1,255,0,0,255))				data.draw(s2,mat, new ColorTransform(1,1,1,1,0,255,0,255))			var intersection = data.getColorBoundsRect(0x00010100,0x00010100)						if(intersection.height == 0){				trace("intersection rectangle = 0")				return null}			var wExpected = 10			var hExpected = 10					var goodData = new Array()			var goodRect = new Array()			var tooBig = new Array()			var justRight = new Array()			if(intersection.height >hExpected || intersection.width>wExpected ){tooBig.push(intersection)} else {justRight.push(intersection)}						var loops = 0			while(tooBig.length>0 && loops <100){				var partitions = [2,2]								var patch = tooBig.splice(0,1)[0]				if(patch.width <wExpected){partitions[0] = 1}				if(patch.height <hExpected){partitions[1] = 1}									for(var i = 0; i<partitions[0] ; i++){					for(var j = 0; j<partitions[1] ; j++){						var dLittle = new BitmapData(Math.ceil(patch.width/partitions[0]),Math.ceil(patch.height/partitions[1]),false,0x000000)						//dLittle.floodFill(0,0,0x000000)						var copyRect = new Rectangle(patch.x + i * patch.width/partitions[0], patch.y + j*patch.height/partitions[1], patch.width/partitions[0], patch.height/partitions[1])						dLittle.copyPixels(data,copyRect,new Point(0,0))						var newPatch = dLittle.getColorBoundsRect(0x00010100,0x00010100)						var square = new Shape()						square.graphics.lineStyle(1,0xFFFFFF)						square.graphics.drawRect(newPatch.x,newPatch.y,newPatch.width,newPatch.height)						dLittle.draw(square)						if(newPatch.width >0){							newPatch.x += copyRect.x							newPatch.y += copyRect.y							if(newPatch.width>wExpected || newPatch.height>hExpected){tooBig.push(newPatch)} else {								newPatch.x += b0.x								newPatch.y += b0.y								justRight.push(newPatch)								}						}											}				}				loops ++			}							return justRight		}		public static function pts2Nodes(outlines:Array, crossingRects:Array):Array{			var justRight = crossingRects			if(justRight == null){ return null}			outlines[0].genFill()			outlines[1].genFill()			var pts = new Array()			var nodes = [new Array(),new Array()]			var unitIn = [new Array(),new Array()]			var isInOther = [new Array(),new Array()]			var nodesInOut = [new Array(), new Array()]			var isDupe = new Array(justRight.length)			for(var i = 0 ; i <justRight.length ; i++){				isDupe[i] = false				pts[i] = ([justRight[i].x + justRight[i].width/2 , justRight[i].y + justRight[i].height/2 ])				for(var j = 0 ; j<2 ; j++){					var current = outlines[j]					var other = outlines[1-j]					nodes[j][i] = (current.closest(pts[i]))					isInOther[j][i] = (other.ptIsInside(current.nodeExternalCoords(nodes[j][i])))										var search = true					var searchLimit = 20					var nSearch = 0					var next = nodes[j][i]					var prev = nodes[j][i]										while(search){						nSearch ++						if(nSearch > searchLimit){search = false}						 next = next.next						 prev = prev.prev						var prevIsInside = other.ptIsInside(current.nodeExternalCoords(prev))						var nextIsInside = other.ptIsInside(current.nodeExternalCoords(next))						if(prevIsInside !=isInOther[j][i]){							var otherNode = prev.next							if(prevIsInside){								var addThis = [prev,otherNode]								for(var k = 0 ; k<nodesInOut[j].length ; k++){									if(nodesInOut[j][k][0] == addThis[0] && nodesInOut[j][k][1] == addThis[1]){isDupe[i] = true}								}								nodesInOut[j][i] = addThis								unitIn[j][i] = -1							}else{								 addThis = ([otherNode,prev])								for(k = 0 ; k<nodesInOut[j].length ; k++){									if(nodesInOut[j][k][0] == addThis[0] && nodesInOut[j][k][1] == addThis[1]){isDupe[i] = true}								}								nodesInOut[j][i] = addThis								unitIn[j][i] = 1							}							search = false						} else {							if(nextIsInside != isInOther[j][i]){								otherNode = next.prev								if(nextIsInside){									 addThis = [next,otherNode]									for(k = 0 ; k<nodesInOut[j].length ; k++){										if(nodesInOut[j][k][0] == addThis[0] && nodesInOut[j][k][1] == addThis[1]){isDupe[i] = true}									}									nodesInOut[j][i] = addThis									unitIn[j][i] = 1								}else{									 addThis = [otherNode,next]									for(k = 0 ; k<nodesInOut[j].length ; k++){										if(nodesInOut[j][k][0] == addThis[0] && nodesInOut[j][k][1] == addThis[1]){isDupe[i] = true}									}									nodesInOut[j][i] = addThis									unitIn[j][i] = -1								}								search = false							}						}					}				}			}						return([pts,nodesInOut,unitIn,isDupe])		}		public static function rectInsideRectOutside(f1:DisplayObject,f2:DisplayObject):Array{			f2.blendMode = BlendMode.ADD			var s = new Sprite			s.addChild(f1)			s.addChild(f2)			var b1 = f1.getBounds(s)			var b2 = f2.getBounds(s)			var b0 = b1.intersection(b2)			if(b0.height == 0){return null}			var data = new BitmapData(b0.width,b0.height,false,0x000000)			var mat = new Matrix(1,0,0,1,-b0.x,-b0.y)			data.draw(s,mat)			var outside = data.getColorBoundsRect(0xFFFFFF,0x00FF00)			var inside = data.getColorBoundsRect(0xFFFFFF,0xFFFF00)						return ([outside,inside])					}		public function intersect2(h:CtdOutline, eraIntUni:Number):Array{			var outlines = [outline,h]			var intersection = 	 CtdOutline.findIntersections(outline,h)			var pts = new Array()			var prodsOut = new Array()			var nodes = new Array()			for(var i = 0 ; i < intersection.length ; i++){				pts.push(intersection[i][1])				nodes.push(intersection[i][0])				prodsOut.push(intersection[i][2])			}						if(eraIntUni == 0){var searchIn = [-1,1]} 			else {				if(eraIntUni == 1){searchIn = [1,1]}				else {searchIn = [-1,-1]}			}						var n12 = [ outline.nodesInOrder(), h.nodesInOrder()]			var indicesOf = [new Array(), new Array()]			var sort = new Array()			for(var i = 0 ; i < 2 ; i++){				for (var j = 0 ; j < nodes.length; j++){					indicesOf[i].push(n12[i].indexOf(nodes[j][i]))				}				sort[i] = indicesOf[i].sort(8)			}			//positions of the elements of sort denote the relative positions of nodes in either outline									var intTally = new Array()			for(var i = 0 ; i < nodes.length ; i++){intTally[i] = 0}			var allArcs = new Array()			var makePaths = true			while(makePaths){				var currOutline = 1				var currInt = intTally.indexOf(0)				if(currInt == -1){ break }				var arcs = new Array()				var makeArcs = true				//arcs contains three entries: [starting node, last node[,[startingInt,finishingInt], direction				while(makeArcs){					if(searchIn[currOutline] * prodsOut[currInt][currOutline] < 0){var searchFwd =true} else {searchFwd = false}						var startNode = nodes[currInt][currOutline]					var idxPos = sort[currOutline].indexOf(currInt)											if(searchFwd){ var nextPos = idxPos + 1 } else {nextPos = idxPos -1}					if(nextPos == sort[currOutline].length){nextPos = 0}					if(nextPos == -1){nextPos = sort[currOutline].length - 1}										var nextInt = sort[currOutline][nextPos]					var finishNode = nodes[nextInt][currOutline]										arcs.push([[startNode,finishNode],[currInt,nextInt],searchFwd])					intTally[currInt] += 1					intTally[nextInt] += 1					currOutline = 1 - currOutline					currInt = nextInt					if(intTally[currInt] > 1){makeArcs = false}				}				allArcs.push(arcs)			}						var outs = new Array()			for(var j = 0 ; j < allArcs.length ; j ++){				var newPath = new CtdOutline()				arcs = allArcs[j]				for(var i = 0 ; i < arcs.length ; i ++){					var searchForward = arcs[i][2]					if(searchForward){startNode = arcs[i][0][0].next} else {startNode = arcs[i][0][0]}					if(searchForward){finishNode= arcs[i][0][1]} else {finishNode= arcs[i][0][1].next}					if(newPath.first != null){var nodeAt = newPath.first.prev}					newPath.spliceAt(nodeAt,startNode,finishNode,startNode.thisCtdOutline,!searchForward)					var tempInt = arcs[i][1][1]					var intXY = pts[tempInt]					newPath.spliceOneAt(newPath.first.prev,new Node(intXY[0],intXY[1]))				}				outs.push(newPath)			}						return [allArcs,intersection,outs]				}				public function intersectWith(h:CtdOutline, eraIntUni:Number):CtdOutline{			//for a 400 pt outline each call to drawfillext costs about 1.5 ms						var t = new Array()			t.push(flash.utils.getTimer())			outline.generateBigNodes(h.rectInExternalCoords( h.bounds))			h.generateBigNodes(outline.rectInExternalCoords( outline.bounds))			var f1  = outline.simpleDrawNoBigs(false,true,1,0x000000,0xFF0000,true)			var f2  = h.simpleDrawNoBigs(false,true,1,0x000000,0x00FF00,true)			t.push(flash.utils.getTimer())						var outInRect = rectInsideRectOutside(f1,f2)			t.push(flash.utils.getTimer())			if(outInRect == null){				trace("badRectangle")				return null}			var outside = outInRect[0], inside = outInRect[1]			if(outside.height == 0){ 				addHole(h) ; 				trace("objectIsInside")				return null			}			if(inside.height ==0){				trace("objectIsOutside")				return null			}						var o1 = outline.drawOutlineExt(false,null,1,0xFF0000)			var o2  = h.drawOutlineExt(false,null,1,0x00FF00)			t.push(flash.utils.getTimer())			var justRight = findCrossingPts(o1,o2)						var outlines = [outline,h]			t.push(flash.utils.getTimer())			var out = pts2Nodes(outlines,justRight)			var pts = out[0], nodesInOut = out[1], unitIn = out[2], isDupe = out[3]						var nInOut = [[new Array(),new Array()],[ new Array(), new Array()]]			var uIn = [new Array(), new Array()]			var ptsNew = new Array()			for( i = 0; i < nodesInOut[0].length ; i++){				if( !isDupe[i] && nodesInOut[0][i] != null && nodesInOut[1][i] != null ){					for(var j = 0 ; j < 2 ; j++ ){												nInOut[j][0].push(nodesInOut[j][i][0])						nInOut[j][1].push(nodesInOut[j][i][1])						uIn[j].push(unitIn[j][i]) 					}					ptsNew.push(pts[i])				}			}						var searchForward:Boolean			var loops = new Array()			var ps = new Array()						var k = 0			var nodesRemain = true			var indicesUsed = new Array()			for(i = 0 ; i < uIn[0].length ; i ++){				indicesUsed.push(false)			}			if(uIn[0].length ==0){ 				trace("noUnits")				return null			}			var startIndex = 0						if(eraIntUni == 0){				var searchIn = [-1,1]			} else {				if(eraIntUni == 1){					searchIn = [1,1]				} else {					searchIn = [-1,-1]				}			}						while(nodesRemain){				var currentOutline = 1				var newPath = new CtdOutline()				newPath.setObject(outline.object)				loops[k] = new Array()				var kNoIncrement = false				var node = nInOut[currentOutline][1- (searchIn[currentOutline] + 1)/2][startIndex]				var searchDir = uIn[currentOutline][startIndex]				var targetList = nInOut[currentOutline][1- (searchIn[currentOutline] + 1)/2]								newPath.pushPt([ptsNew[startIndex][0],ptsNew[startIndex][1]])				var exCoord = outlines[currentOutline].nodeExternalCoords(node)				newPath.pushPt([exCoord[0],exCoord[1]],node)																						  				loops[k].push([currentOutline,startIndex])								var loopTally = 0				var buildLoop = true				while(buildLoop){					var abort = false					var buildArc = true					var arcTally = 0					var n0 = node										while(buildArc){						if(searchDir * searchIn[currentOutline] == 1){							node = node.next						} else {							node = node.prev						}												exCoord = outlines[currentOutline].nodeExternalCoords(node)						newPath.pushPt([exCoord[0],exCoord[1]],node)										var hit = -1						if(node == n0){abort = true}						for( i = 0 ; i< targetList.length ; i++){							if(targetList[i] == node){								if(uIn[currentOutline][i] !=  searchDir){									hit = i									if(indicesUsed[hit]){abort = true}									buildArc = false								}							} 						}												arcTally++						if(abort){buildArc = false}					}					if(!abort){						loops[k].push([currentOutline,hit])																		currentOutline = 1 - currentOutline						node = nInOut[currentOutline][1- (searchIn[currentOutline] + 1)/2][hit]												if(hit != startIndex){												newPath.pushPt([ptsNew[hit][0],ptsNew[hit][1]])											exCoord = outlines[currentOutline].nodeExternalCoords(node)						newPath.pushPt([exCoord[0],exCoord[1]],node)												}																		 						searchDir =uIn[currentOutline][hit]						 targetList = nInOut[currentOutline][1 - (searchIn[currentOutline] + 1)/2]						loops[k].push([currentOutline,hit])						indicesUsed[hit] = true						if(hit == startIndex){buildLoop = false}						loopTally++						if(loopTally>25){abort = true; trace("tooManyBuild)")}					} else {buildLoop = false}				}				indicesUsed[startIndex] = true				if(!abort){					ps[k] = newPath					k++				}				startIndex = -1				for(i = 0 ; i <indicesUsed.length ; i++){					if(startIndex == -1 && indicesUsed[i] == false){						startIndex = i					}				}				if(startIndex == -1){					nodesRemain = false					if(abort){loops.splice(k,1)}				}			}					t.push(flash.utils.getTimer())			for(i = 1; i < t.length ; i++){				//trace(i, "time", t[i] - t[i-1])			}			var maxNodes = 0			var maxIndex = 0			if(ps!= null && ps.length != 0){			for(var i = 0 ; i < ps.length ; i++){				if(ps[i].numNodes >maxNodes){maxIndex = i ; maxNodes = ps[i].numNodes}			}			var path = ps[maxIndex]			return path			} else { trace("noPaths");return null }				}				public function cleanOutline():void{			outline.mergeNeighbors(20)		}				public static function expensiveGetIntersection(p1:PhysOutline,p2:PhysOutline):CtdOutline{			var intOutline = p1.intersectWith(p2.outline,1)			return intOutline								}		public function edgeInsideOf(other:PhysOutline):Rectangle{						var s1 = new Sprite()			s1.addChild(outline.drawFillExt(0xF00000,1))			s1.addChild(outline.drawOutlineExt(false,null,4,0x0F0000))			var s2 = new Sprite()			s2.addChild(other.outline.drawFillExt(0x00F000,1))			s2.addChild(other.outline.drawOutlineExt(false,null,4,0x000F00))			s2.blendMode = BlendMode.ADD			var s = new Sprite			s.addChild(s1)			s.addChild(s2)			var b1 = s1.getBounds(s)			var b2 = s2.getBounds(s)			var b0 = b1.intersection(b2)			if(b0.height == 0){return null}			var data = new BitmapData(b0.width,b0.height,false,0x000000)			var mat = new Matrix(1,0,0,1,-b0.x,-b0.y)			data.draw(s,mat)			var o1intf2 = data.getColorBoundsRect(0xFFFFFF,0x00FF00)			return o1intf2								}		public static function intersectionRectangle(po1:PhysOutline,po2:PhysOutline,...args):Rectangle{			if(args.length ==0){var padding = 0} else { padding = args[0] }			var o1 = po1.outline			var o2 = po2.outline			var s1 = new Sprite()			s1.addChild(o1.drawFillExt(0x000000,1,padding * 2))			var s2 = new Sprite()			s2.addChild(o2.drawFillExt(0x000000,1,padding * 2))			var s0 = new Sprite()			s0.addChild(s1)			s0.addChild(s2)				var rect = ObjObj.findIntersect(s1,s2,s0)									if(rect == null){rect = new Rectangle()}			return rect								}		public function drawShape(...args):Sprite{			if(args.length <1){var thick = 10} else {thick = args[0] }			if(args.length <2 ){var outlineColor = 0xCCCCCC} else {outlineColor = args[1]}			if(args.length <3){var fillColor = 0xFFFFFF} else {fillColor = args[2]}			if(args.length <4){var smooth = true} else {smooth = args[3]}			var out = new Sprite					if(smooth){				out.addChild(outline.drawSmoothOutline(thick,outlineColor,true,fillColor))			} else {				out.addChild(outline.simpleDraw(true,true,thick,outlineColor,fillColor))			}			return out		}				public function drawShapeExt(...args):Sprite{			if(args.length <1){var color = 0xFFFFFF} else { color = args[0] }			if(args.length <2 ){var thick = 40} else {thick = args[1]}			var out = new Sprite					out.addChild(outline.drawSmoothOutlineExt(thick,0xCCCCCC,true,color))			return out		}		public function addHole(h:CtdOutline):void{			holes.push(h)		}						public function getCollision(externalXY:Array):Array{			var localXY = outline.localCoords(externalXY)			var closestBit = outline.closest(localXY)			var closestUnits = outline.getUnits(closestBit)			var closestAltitude = closestBit.ptBitAltitude(localXY)			var height = math.VectorMath2D.dotMultiply2D(closestAltitude,[closestUnits[2],closestUnits[3]])			return([height,closestBit])																																															}			}}