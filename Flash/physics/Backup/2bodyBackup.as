package physics.twobody{	import math.VectorMath2D	import math.VectorMath3D	import flash.display.Sprite	import physics.PhysUniverse	public class TwoBodyCollision{		public static function elasticCollideObjs(objs:Array,pt:Array,units:Array,nextVel:Boolean):Array{			if(nextVel){				var vs = [objs[0].getNextVel(),objs[1].getNextVel()]			}else{				vs = [objs[0].getVel(),objs[1].getVel()]			}			return(elasticCollision([objs[0].getMass(),objs[1].getMass()],[objs[0].getMomentOfInertia(),objs[1].getMomentOfInertia()],[objs[0].getCOM(),objs[1].getCOM()],vs,[objs[0].getOmega(),objs[1].getOmega()],pt,units))		}		public static function inelasticCollideObjs(objs:Array,pt:Array,units:Array,nextVel:Boolean):Array{			if(nextVel){				var vs = [objs[0].getNextVel(),objs[1].getNextVel()]			}else{				vs = [objs[0].getVel(),objs[1].getVel()]			}			return(inelasticCollision([objs[0].getMass(),objs[1].getMass()],[objs[0].getMomentOfInertia(),objs[1].getMomentOfInertia()],[objs[0].getCOM(),objs[1].getCOM()],vs,[objs[0].getOmega(),objs[1].getOmega()],pt,units))		}		public static function inelasticSimpleObjs(objs:Array,units:Array,nextVel:Boolean):Array{			if(nextVel){				var vs = [objs[0].getNextVel(),objs[1].getNextVel()]			}else{				vs = [objs[0].getVel(),objs[1].getVel()]			}			return(inelasticSimple([objs[0].getMass(),objs[1].getMass()],vs,units))		}		public static function twoPtInelasticObjs(objs:Array,pts:Array,unitsToward1:Array){			var s = new Sprite()			var obj1 = objs[0]			var obj2 = objs[1]			var vec12 = [pts[1][0] - pts[0][0],pts[1][1] - pts[0][1]]						var v10 = obj1.getNextVel(pts[0])			var u10 = obj2.getNextVel(pts[0])			var v20 = obj1.getNextVel(pts[1])			var u20 = obj2.getNextVel(pts[1])			var iHat11 = [unitsToward1[0][0],unitsToward1[0][1]]			var iHat21 = [-iHat11[0],-iHat11[1]]			var iHat12 = [unitsToward1[1][0],unitsToward1[1][1]]			var iHat22 = [-iHat12[0],-iHat12[1]]			var r11 = obj1.getCOMRadius(pts[0])			var r12 = obj1.getCOMRadius(pts[1])			var r21 = obj2.getCOMRadius(pts[0])			var r22 = obj2.getCOMRadius(pts[1])			r11.push(0)			r12.push(0)			r21.push(0)			r22.push(0)			iHat11.push(0)			iHat21.push(0)			iHat12.push(0)			iHat22.push(0)									var k11Vec = VectorMath3D.crossMultiply3D(VectorMath3D.crossMultiply3D(r11,iHat11),r11)			k11Vec = [k11Vec[0] / obj1.getMomentOfInertia(), k11Vec[1] / obj1.getMomentOfInertia()]			var k12Vec = VectorMath3D.crossMultiply3D(VectorMath3D.crossMultiply3D(r11,iHat11),r12)			k12Vec = [k12Vec[0] / obj1.getMomentOfInertia(), k12Vec[1] / obj1.getMomentOfInertia()]			var k21Vec = VectorMath3D.crossMultiply3D(VectorMath3D.crossMultiply3D(r12,iHat12),r11)			k21Vec = [k21Vec[0] / obj1.getMomentOfInertia(), k21Vec[1] / obj1.getMomentOfInertia()]			var k22Vec = VectorMath3D.crossMultiply3D(VectorMath3D.crossMultiply3D(r12,iHat12),r12)			k22Vec = [k22Vec[0] / obj1.getMomentOfInertia(), k22Vec[1] / obj1.getMomentOfInertia()]			var c11Vec = VectorMath3D.crossMultiply3D(VectorMath3D.crossMultiply3D(r21,iHat11),r21)			c11Vec = [c11Vec[0] / obj2.getMomentOfInertia(), c11Vec[1] / obj2.getMomentOfInertia()]			var c12Vec = VectorMath3D.crossMultiply3D(VectorMath3D.crossMultiply3D(r21,iHat11),r22)			c12Vec = [c12Vec[0] / obj2.getMomentOfInertia(), c12Vec[1] / obj2.getMomentOfInertia()]			var c21Vec = VectorMath3D.crossMultiply3D(VectorMath3D.crossMultiply3D(r22,iHat12),r21)			c21Vec = [c21Vec[0] / obj2.getMomentOfInertia(), c21Vec[1] / obj2.getMomentOfInertia()]			var c22Vec = VectorMath3D.crossMultiply3D(VectorMath3D.crossMultiply3D(r22,iHat12),r22)			c22Vec = [c22Vec[0] / obj2.getMomentOfInertia(), c22Vec[1] / obj2.getMomentOfInertia()]			//now the "c" coefficients describe change in motion of pts on object2 caused by a unit push along the direction iHat1						var k11 = VectorMath2D.dotMultiply2D(k11Vec,vec12)			var k12 = VectorMath2D.dotMultiply2D(k12Vec,vec12)			var k21 = VectorMath2D.dotMultiply2D(k21Vec,vec12)			var k22 = VectorMath2D.dotMultiply2D(k22Vec,vec12)						var t11 = (VectorMath3D.crossMultiply3D(r11,iHat11))[2]			var t12 = (VectorMath3D.crossMultiply3D(r12,iHat12))[2]						var t21 = (VectorMath3D.crossMultiply3D(r21,iHat11))[2]			var t22 = (VectorMath3D.crossMultiply3D(r22,iHat12))[2]			var g11 = VectorMath2D.dotMultiply2D(k11Vec,iHat11)			var g12 = VectorMath2D.dotMultiply2D(k21Vec,iHat11)			var g21 = VectorMath2D.dotMultiply2D(c11Vec,iHat11)			var g22 = VectorMath2D.dotMultiply2D(c21Vec,iHat11)						var m0 = (1/obj1.getMass() + 1/ obj2.getMass())									var scl = 50 / Math.sqrt(Math.pow(k11Vec[0],2) + Math.pow(k11Vec[1],2)) 									s.graphics.lineStyle(2,0xFFFFFF)			s.graphics.moveTo(pts[0][0],pts[0][1])			s.graphics.lineTo(pts[0][0] + scl *k11Vec[0], pts[0][1] + scl *k11Vec[1])						s.graphics.lineStyle(0,0xFFFFFF)			s.graphics.moveTo(pts[0][0],pts[0][1])			s.graphics.lineTo(pts[0][0] + -r11[0], pts[0][1] + - r11[1])			s.graphics.lineStyle(0,0xFF0000)			s.graphics.moveTo(pts[0][0],pts[0][1])			s.graphics.lineTo(pts[0][0] + scl *k21Vec[0], pts[0][1] + scl *k21Vec[1])			s.graphics.lineStyle(0,0xFFFFFF)			s.graphics.moveTo(pts[1][0],pts[1][1])			s.graphics.lineTo(pts[1][0] + scl *k12Vec[0], pts[1][1] + scl *k12Vec[1])						s.graphics.lineStyle(0,0xFFFFFF)			s.graphics.moveTo(pts[1][0],pts[1][1])			s.graphics.lineTo(pts[1][0] + -r12[0], pts[1][1] + - r12[1])			s.graphics.lineStyle(0,0xFF0000)			s.graphics.moveTo(pts[1][0],pts[1][1])			s.graphics.lineTo(pts[1][0] + scl *k22Vec[0], pts[1][1] + scl *k22Vec[1])			if(k21 == k22 || k11 == k12){								cof0 = 1			} else {				var cof0 = (k21 - k22)/(k11 - k12)						}			trace(cof0, k21 == k22,  k11 == k12)			var cofA1 = m0 * cof0			var cofA2 = VectorMath2D.dotMultiply2D(k11Vec,iHat11) * cof0			var cofA3 = VectorMath2D.dotMultiply2D(c11Vec,iHat11) * cof0			var cofB1 = m0* VectorMath2D.dotMultiply2D(iHat11,iHat12)			var cofB2 = VectorMath2D.dotMultiply2D(k21Vec,iHat11)			var cofB3 = VectorMath2D.dotMultiply2D(c21Vec,iHat11)			var cofC1 = VectorMath2D.dotMultiply2D([v10[0] - u10[0],v10[1] - u10[1]],iHat11)								//var i2 = cofC1 / (cofA1 + cofA2 + cofA3 + cofB1 + cofB2 + cofB3)			var i2 = - cofC1 / (cofA1 + cofA2 + cofA3 + cofB1 + cofB2 + cofB3)						var i1 = cof0 * i2											s.graphics.lineStyle(0,0x00FFFF)			s.graphics.drawCircle(pts[0][0],pts[0][1],5)			s.graphics.lineStyle(0,0x000000)			s.graphics.drawCircle(pts[1][0],pts[1][1],5)						PhysUniverse.universe.addExtraGraphic(s)			var dist = VectorMath2D.distance(pts[0],pts[1])																//trace(i1,i2)								if(i1 > 0 && i2 >0){													var impulse1 = [i1 * unitsToward1[0][0],i1 * unitsToward1[0][1]]				var impulse2 = [i2 * unitsToward1[1][0],i1 * unitsToward1[1][1]]								obj1.exertImpulseAt(impulse1,pts[0])				obj1.exertImpulseAt(impulse2,pts[1])				var vf1 = obj1.getNextVel(pts[0])				var vf2 = obj1.getNextVel(pts[1])								var magV = Math.sqrt(Math.pow(v10[0],2) + Math.pow(v10[1],2))				var vScl = 50 / magV								for(var i = 0 ; i < 2 ; i++){					var pt = pts[i]					if(i ==0){ 						var v = v10						var ih = iHat11						var im = i1/obj1.getMass()						var vf = vf1											} else {						v  = v20						ih = iHat12						var im = i2/obj1.getMass()						var vf = vf2					}				var im2 = cofC1				s.graphics.lineStyle(0,0x000000)				s.graphics.moveTo(pt[0],pt[1])				s.graphics.lineTo(pt[0] + ih[0] * im *vScl, pt[1] + ih[1] * im *vScl)				s.graphics.moveTo(pt[0],pt[1])				s.graphics.lineTo(pt[0] + v[0] *vScl, pt[1] + v[1] *vScl)				//s.graphics.lineStyle(0,0xFF0000)				//s.graphics.moveTo(pt[0],pt[1])				//s.graphics.lineTo(pt[0] + ih[0]  *vScl* im2, pt[1] + ih[1] * im2 *vScl)				//s.graphics.lineStyle(0,0xFFFF00)				//s.graphics.moveTo(pt[0],pt[1])				//s.graphics.lineTo(pt[0] + vf[0] *vScl, pt[1] + vf[1] *vScl)													  				}									return([impulse1,impulse2])			} else {				if(i1 > i2){					var pt = pts[0]					var unitTo1 = unitsToward1[0]				} else {					pt = pts[1]					unitTo1 = unitsToward1[1]				}				return(onePtInelasticObjs([obj1,obj2],pt,unitTo1))							}					}		public static function onePtInelasticObjs(objs:Array,pt:Array,unitTo1:Array):Array{							var s = new Sprite()				s.graphics.lineStyle(2,0x00FF00)				s.graphics.drawCircle(pt[0],pt[1],10)				PhysUniverse.universe.addExtraGraphic(s)				var obj1 = objs[0]				var obj2 = objs[1]				var m1 = obj1.getEMassAtAlong(pt,unitTo1)				var m2 = obj2.getEMassAtAlong(pt,unitTo1)				var v1A = VectorMath2D.dotMultiply2D(obj1.getNextVel(pt),unitTo1)				var v2A = VectorMath2D.dotMultiply2D(obj2.getNextVel(pt),unitTo1)				var vC = (v1A * m1 + v2A * m2)/(m1 + m2)				var v1A2 = v1A - vC				var v2A2 = v2A - vC				var eI1 = -m1 * v1A2				var eI2 = -m2 * v2A2				var impulse1 = [eI1 * unitTo1[0], eI1 * unitTo1[1]]				var impulse2 = [eI2 * unitTo1[0], eI2 * unitTo1[1]]				obj1.exertImpulseAt(impulse1,pt)				obj2.exertImpulseAt(impulse2,pt)				return([impulse1,impulse2])									}		public static function twoPtInelastic(){					}				public static function elasticCollision(masses:Array,moments:Array,COMs:Array,velocities:Array,omegas:Array,pt:Array,units:Array):Array{			var eMasses = new Array(2)			var vPerps = new Array(2)			var unitAlong = [units[0],units[1]]			var unitPerp = [units[2],units[3]]						for( var i = 0; i < 2 ; i++ ){				var colRad = [pt[0] - COMs[i][0],pt[1] - COMs[i][1]]				var radiusParallel = VectorMath2D.dotMultiply2D(unitAlong,colRad)				eMasses[i] =  1 / (Math.pow(radiusParallel , 2) / moments[i] + 1 / masses[i])				var vBig = velocities[i]				var vSpin = VectorMath3D.crossMultiply3D([0,0,omegas[i]], [unitAlong[0] *radiusParallel,unitAlong[1]*radiusParallel,0])				vPerps[i] = VectorMath2D.dotMultiply2D([vBig[0] + vSpin[0],vBig[1] + vSpin[1]],unitPerp)			}											var vCom = (vPerps[0]*eMasses[0] + vPerps[1]*eMasses[1])/(eMasses[0] + eMasses[1])			var vIns = [vPerps[0] - vCom, vPerps[1] - vCom]			var energyIn = .5 * eMasses[0]*Math.pow(vIns[0],2)+ .5 * eMasses[1]*Math.pow(vIns[1],2)			var magVOuts = new Array(2)			magVOuts[0] = Math.sqrt(energyIn * 2 * eMasses[1]/eMasses[0] * 1/(eMasses[0] + eMasses[1]))			magVOuts[1] = Math.sqrt(energyIn * 2 * eMasses[0]/eMasses[1] * 1/(eMasses[0] + eMasses[1]))			var vOuts = new Array(2)			if(vIns[0] < 0){				vOuts[0] = magVOuts[0]				vOuts[1] = magVOuts[1] * -1			} else {				vOuts[0] = magVOuts[0] * -1				vOuts[1] = magVOuts[1] 			}			var magImpulse1 = (vOuts[0] - vIns[0]) * eMasses[0]			var magImpulse2 = (vOuts[1] - vIns[1]) * eMasses[1]			var impulse1 = [magImpulse1 * unitPerp[0],magImpulse1 * unitPerp[1]]			var impulse2 = [magImpulse2 * unitPerp[0],magImpulse2 * unitPerp[1]]			return([impulse1,impulse2])										}		public static function inelasticCollision(masses:Array,moments:Array,COMs:Array,velocities:Array,omegas:Array,pt:Array,units:Array):Array{			var eMasses = new Array(2)			var vPerps = new Array(2)			var unitAlong = [units[0],units[1]]			var unitPerp = [units[2],units[3]]						for( var i = 0; i < 2 ; i++ ){				var colRad = [pt[0] - COMs[i][0],pt[1] - COMs[i][1]]				var radiusParallel = VectorMath2D.dotMultiply2D(unitAlong,colRad)				eMasses[i] =  1 / (Math.pow(radiusParallel , 2) / moments[i] + 1 / masses[i])				var vBig = velocities[i]				var vSpin = VectorMath3D.crossMultiply3D([0,0,omegas[i]], [unitAlong[0] *radiusParallel,unitAlong[1]*radiusParallel,0])				vPerps[i] = VectorMath2D.dotMultiply2D([vBig[0] + vSpin[0],vBig[1] + vSpin[1]],unitPerp)							}											var vCom = (vPerps[0]*eMasses[0] + vPerps[1]*eMasses[1])/(eMasses[0] + eMasses[1])			var vIns = [vPerps[0] - vCom, vPerps[1] - vCom]			var vOuts = [0,0]			var magImpulse1 = (vOuts[0] - vIns[0]) * eMasses[0]			var magImpulse2 = (vOuts[1] - vIns[1]) * eMasses[1]			var impulse1 = [magImpulse1 * unitPerp[0],magImpulse1 * unitPerp[1]]			var impulse2 = [magImpulse2 * unitPerp[0],magImpulse2 * unitPerp[1]]			return([impulse1,impulse2])				}				public static function inelasticSimple(masses:Array,velocities:Array,units:Array):Array{			var vPerps = new Array(2)			var unitAlong = [units[0],units[1]]			var unitPerp = [units[2],units[3]]						for( var i = 0; i < 2 ; i++ ){				var vBig = velocities[i]				vPerps[i] = VectorMath2D.dotMultiply2D(vBig,unitPerp)			}											var vCom = (vPerps[0]*masses[0] + vPerps[1]*masses[1])/(masses[0] + masses[1])			var vIns = [vPerps[0] - vCom, vPerps[1] - vCom]			var vOuts = [0,0]			var magImpulse1 = (vOuts[0] - vIns[0]) * masses[0]			var magV0 =Math.sqrt(Math.pow( velocities[0][0],2) + Math.pow(velocities[0][1],2))			var magVChange = vIns[0]			var magImpulse2 = (vOuts[1] - vIns[1]) * masses[1]			var impulse1 = [magImpulse1 * unitPerp[0],magImpulse1 * unitPerp[1]]			var impulse2 = [magImpulse2 * unitPerp[0],magImpulse2 * unitPerp[1]]			return([impulse1,impulse2])				}	}}