package physics{	import flash.display.Bitmap;	import flash.display.BitmapData;	import flash.geom.Matrix;	import flash.geom.ColorTransform;	import flash.geom.Point	import flash.events.MouseEvent;	import flash.events.Event;	import flash.display.Shape;	import flash.display.Sprite;	import flash.geom.Rectangle;	import flash.utils.getTimer;	import math.VectorMath2D;	import math.VectorMath3D;	import mygraphics.PtObj		import physics.collisions.Collision		public class PhysWallObject extends PhysWall {		public var drawRadii:Boolean = false		public var tracer:Sprite;		public var unitArrow:Shape;		public var twoRadii:Shape;		public static  var lastbmp:Bitmap;		public static var unitSprite		public var xCenters:Array;		public var yCenters:Array;		public var massFracs:Array;		public var chargeFracs:Array;		public var massWeights:Array;		public var chargeWeights:Array;				public function setCenters(xs:Array,ys:Array):void {			xCenters = xs;			yCenters = ys;			massWeights = new Array();			chargeWeights = new Array();			for (var i = 0; i < xs.length; i++) {				massWeights.push(1);				chargeWeights.push(1);			}			calculateFracs();		}		public function addCenter(xAdd:Number,yAdd:Number):void {			if ( xCenters == null) {				xCenters = new Array ;				yCenters = new Array ;				massWeights = new Array ;				chargeWeights = new Array;			}			xCenters.push(xAdd);			yCenters.push(yAdd);			massWeights.push(1);			chargeWeights.push(1);			calculateFracs();		}		function calculateFracs():void {			var l = xCenters.length;			var cWeightTotal = 0;			var mWeightTotal = 0;			massFracs = new Array(l);			chargeFracs = new Array(l)			;			for (var i = 0; i < l; i++) {				cWeightTotal+= chargeWeights[i];				mWeightTotal+= massWeights[i];			}			if (cWeightTotal == 0) {				cWeightTotal = 1;			}			if (mWeightTotal ==0) {				mWeightTotal = 1;			}			for (i = 0; i< l; i++) {				massFracs[i] = massWeights[i] / mWeightTotal;				chargeFracs[i] = chargeWeights[i] / cWeightTotal;			}		}		public function getXCenters() {			var newXCenters = new Array();			if(xCenters == null){xCenters = [0]}			for (var i  = 0; i < xCenters.length; i++) {				newXCenters[i] = xCenters[i] + getX();			}			return newXCenters;		}		public function getYCenters() {			var newYCenters = new Array();			if(yCenters == null){yCenters = [0]}			for (var i  = 0; i < yCenters.length; i++) {				newYCenters[i] = yCenters[i] + getY();			}			return newYCenters;		}		public function getNearestCenter(object:PhysObject):Array {			if (xCenters == null) {				return [getX(),getY()];			} else {				var newXCenters = getXCenters();				var newYCenters = getYCenters();				var objX = object.getX();				var objY = object.getY();				var l = newXCenters.length;				var abs = Math.sqrt(Math.pow(objX - newXCenters[0],2) + Math.pow(objY - newYCenters[0],2));				var idxAbs = 0;				var temp:Number;				for (var i = 1; i < l; i ++) {					temp = Math.sqrt(Math.pow(objX - newXCenters[i],2) + Math.pow(objY - newYCenters[i],2));					if (temp < abs) {						abs = temp;						idxAbs = i;					}				}				var output = xCenters;				return [newXCenters[idxAbs],newYCenters[idxAbs]];			}		}		public function getNearestCenterToPt(pt:Array):Array {			if (xCenters == null) {				return [getX(),getY()];			} else {				var newXCenters = getXCenters();				var newYCenters = getYCenters();				var objX = pt[0];				var objY = pt[1];				var l = newXCenters.length;				var abs = Math.sqrt(Math.pow(objX - newXCenters[0],2) + Math.pow(objY - newYCenters[0],2));				var idxAbs = 0;				var temp:Number;				for (var i = 1; i < l; i ++) {					temp = Math.sqrt(Math.pow(objX - newXCenters[i],2) + Math.pow(objY - newYCenters[i],2));					if (temp < abs) {						abs = temp;						idxAbs = i;					}				}				var output = xCenters;				return [newXCenters[idxAbs],newYCenters[idxAbs]];			}		}		override public function getCOMX():Number{			if(massFracs != null){			if (xCenters.length == 0){return getX()} else{				var newX = getXCenters()				var COMX = 0				for (var i = 0; i < newX.length ; i++){					COMX += massFracs[i] * newX[i]				}				return COMX						}} else{ return getX() }		}		override public function getCOMY():Number{			if(massFracs != null){			if (yCenters.length == 0){return getY()} else{				var newY = getYCenters()				var COMY = 0				for (var i = 0; i < newY.length ; i++){					COMY += massFracs[i] * newY[i]				}				return COMY			} } else { return getY() }				}						override public function eOfAt(xy:Array):Array {			var newXCenters = getXCenters();			var newYCenters = getYCenters();			var E:Array = [0,0];			var rx:Number;			var ry:Number;			var r:Number;			for (var i = 0; i < xCenters.length; i++) {				rx = xy[0] - newXCenters[i];				ry = xy[1] - newYCenters[i];				r = Math.sqrt(Math.pow(rx,2) + Math.pow(ry,2));				E[0] += kc * rx * chargeFracs[i] *charge / Math.pow(r,3) ;				E[1] += kc * ry * chargeFracs[i] * charge/ Math.pow(r,3);			}			return E;		}		override public function gOfAt(xy:Array):Array {			var newXCenters = getXCenters();			var newYCenters = getYCenters();			var g:Array = [0,0];			var rx:Number;			var ry:Number;			var r:Number;			for (var i = 0; i < xCenters.length; i++) {				rx = xy[0] - newXCenters[i];				ry = xy[1] - newYCenters[i];				//trace(rx)				//trace(ry)				r = Math.sqrt(Math.pow(rx,2) + Math.pow(ry,2));				g[0] += -G * rx * massFracs[i] * mass /  Math.pow(r,3) ;				g[1] += -G * ry * massFracs[i] * mass /  Math.pow(r,3);				//trace(g)			}			return g;		}		override public function inverseSquareOfAt(xy:Array):Array{			var newXCenters = getXCenters();			var newYCenters = getYCenters();			var f:Array = [0,0];			var rx:Number;			var ry:Number;			var r:Number;					var fThis:Array;						for (var i = 0; i < xCenters.length; i++) {						 rx = xy[0] - newXCenters[i];						 ry = xy[1] - newYCenters[i];						 r = Math.max(Math.sqrt(Math.pow(rx,2) + Math.pow(ry,2)),minimumMeaningfulLengthScale)						 fThis = [ rx  / Math.pow(r,3),  ry  / Math.pow(r,3)]						 f[0] += fThis[0]						 f[1] += fThis[1]						}			return f		}		override public function inverseCubeOfAt(xy:Array):Array{			var newXCenters = getXCenters();			var newYCenters = getYCenters();			var f:Array = [0,0];			var rx:Number;			var ry:Number;			var r:Number;					var fThis:Array;						for (var i = 0; i < xCenters.length; i++) {						 rx = xy[0] - newXCenters[i];						 ry = xy[1] - newYCenters[i];						 r = Math.max(Math.sqrt(Math.pow(rx,2) + Math.pow(ry,2)),minimumMeaningfulLengthScale)						 fThis = [ rx  / Math.pow(r,3),  ry  / Math.pow(r,3)]						 f[0] += fThis[0]						 f[1] += fThis[1]						}			return f		}		override public function inverseFirstOfAt(xy:Array):Array{			var newXCenters = getXCenters();			var newYCenters = getYCenters();			var f:Array = [0,0];			var rx:Number;			var ry:Number;			var r:Number;					var fThis:Array;						for (var i = 0; i < xCenters.length; i++) {						 rx = xy[0] - newXCenters[i];						 ry = xy[1] - newYCenters[i];						 r = Math.max(Math.sqrt(Math.pow(rx,2) + Math.pow(ry,2)),minimumMeaningfulLengthScale)						 fThis = [ rx  / Math.pow(r,3),  ry  / Math.pow(r,3)]						 f[0] += fThis[0]						 f[1] += fThis[1]						}						//trace(["AAAA",thisUniverseIndex,getXCenters(),f])			return f		}								public function collision(ParentObject:PhysObject):void {			Collision.collision(this,ParentObject)		}	}}