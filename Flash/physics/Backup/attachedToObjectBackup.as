package physics.objects.oscript{	import physics.PhysUniverse	import physics.objects.PhysObject	import flash.geom.Rectangle	import math.graphs.MovingGraph	import flash.display.Sprite	import flash.display.Shape	import flash.display.BitmapData	import flash.display.Bitmap	import flash.geom.Matrix		import math.VectorMath2D	import flash.utils.getTimer			public class attachedToObject extends ObjectScript{				public static var s:Shape				public var objAttachedTo		public var nodesAttached		public var bindingForceConstant = 1		var kOut = 10, kIn = 5, kOn = .05				var bindingMaxDistance = 20		var bindingMaxForceConstant = 3		var bindingMaxVelocity = 800					public var surfaceUnits:Array		public var surfacePoints:Array			public var sfcPtAvg:Array		public var sfcUnitsAvg:Array				public var isInside = false		public var wasInside:Boolean					public var mGraph:MovingGraph									 function friction():void{			thisObject.dampen([.9,.9,1])			if(frame == 1){thisObject.dampen([.8,.8,1])}		 }				 function alignWithSurface():void{			var node0XY =  nodesAttached[0].thisCtdOutline.nodeExternalCoords(nodesAttached[0])			var a0 = [node0XY[0] - surfacePoints[0][0] , node0XY[1] - surfacePoints[0][1]]			thisObject.moveBy([ -1 * a0[0], -1 * a0[1]])			//trace(a0,"A")			 node0XY =  nodesAttached[0].thisCtdOutline.nodeExternalCoords(nodesAttached[0])			var uUp = thisObject.unitUp()			var ptAbove =  [node0XY[0] + uUp[0]*5, node0XY[1] + uUp[1]*5]			var ptSfc = [node0XY[0] + surfaceUnits[0][2]*5, node0XY[1] + surfaceUnits[0][3]*5]			thisObject.movePtTowardsAboutFixedPt(ptAbove,node0XY,ptSfc)			var node1XY =  nodesAttached[1].thisCtdOutline.nodeExternalCoords(nodesAttached[1])			var outline = objAttachedTo.thisOutline.outline			var pt = node1XY			var surfaceBit = outline.closest(pt)			var localXY = outline.localCoords(pt)			var sfcPt = surfaceBit.ptBitClosest(localXY,true) 						var keepRotating = true			var loops = 0			while(keepRotating){				loops ++				//trace(sfcPt,"SFC")				thisObject.movePtTowardsAboutFixedPt(node1XY,node0XY,sfcPt)						//trace("pt",node1XY,sfcPt,node0XY)					node1XY =  nodesAttached[1].thisCtdOutline.nodeExternalCoords(nodesAttached[1])				if(Math.sqrt(Math.pow(node1XY[0] - sfcPt[0] , 2) + Math.pow(node1XY[1] - sfcPt[1],2)) < 5){					keepRotating = false				} else {						 outline = objAttachedTo.thisOutline.outline						 pt = node1XY							 surfaceBit = outline.closest(pt)						 localXY = outline.localCoords(pt)						 sfcPt = surfaceBit.ptBitClosest(localXY,true) 						//trace("pt",node1XY)						if(loops > 4){keepRotating = false}										}						}			//trace(thisObject.getX())		}		public function testDetach():Boolean{			var d = false			if(thisObject.mustDetach()){				d = true				thisObject.setDetachPronto(false)			}			return d		}		public function detach():void{				thisObject.constraint = null				scriptDone = true				spawnDetached()		}					override public function advance(...args):void{			if(objAttachedTo.isDestroyed){				detach()				return				}			var step = args[0]			if(step == 0){					if(testDetach()){						thisObject.constraint = null						detach()					}			} else{ if(step == 1) {				//NOW ONLY THE FRONT NODE IS ATTACHED				if(nodesAttached[0].x < 0 && nodesAttached[1].x > 0){nodesAttached.reverse();}				thisObject.constraint = [objAttachedTo.thisOutline.outline, nodesAttached[0]]				//thisObject.sleep()					if(objAttachedTo.thisOutline != null){																	 surfacePoints = new Array()					 surfaceUnits = new Array()					 sfcPtAvg = [0,0]					 sfcUnitsAvg = [0,0,0,0]					for(var i = 0; i < nodesAttached.length ; i ++){						var outline = objAttachedTo.thisOutline.outline						var pt = nodesAttached[i].thisCtdOutline.nodeExternalCoords(nodesAttached[i])													var surfaceBit = outline.closest(pt)																	var localXY = outline.localCoords(pt)						var sfcXY = surfaceBit.ptBitClosest(localXY,true) 						surfacePoints.push(sfcXY)						sfcPtAvg[0] += sfcXY[0]/nodesAttached.length						sfcPtAvg[1] += sfcXY[1]/nodesAttached.length						var sfcUnits = outline.getUnitsExt(surfaceBit,true)							surfaceUnits.push(sfcUnits)						sfcUnitsAvg = [sfcUnitsAvg[0] + sfcUnits[0],sfcUnitsAvg[1] +sfcUnits[1], sfcUnitsAvg[2] + sfcUnits[2],sfcUnitsAvg[3] + sfcUnits[3]]						 											}					var sfcMag1 = Math.sqrt(Math.pow(sfcUnitsAvg[0], 2) + Math.pow(sfcUnitsAvg[1],2))					sfcUnitsAvg = [sfcUnitsAvg[0] / sfcMag1, sfcUnitsAvg[1]/sfcMag1,-sfcUnitsAvg[1]/sfcMag1,sfcUnitsAvg[0]/sfcMag1]										if(testDetach()){						detach()					}					if(!scriptDone){						//alignWithSurface()						friction()												}										var s = new Sprite()					s.graphics.lineStyle(1)					s.graphics.moveTo(thisObject.getX(),thisObject.getY())					s.graphics.lineTo(thisObject.getX() +sfcUnitsAvg[2]* 50 ,thisObject.getY() + sfcUnitsAvg[3]* 50)					//thisObject.setExtraGFX(s)				}								}}						}		public function spawnDetached():void{			var newScript = new detachFromObj()			newScript.setAttachedTo(objAttachedTo)			thisObject.addObjectScript(newScript)		}		public function setAttachedTo(obj:PhysObject):void{			objAttachedTo = obj			multiPriorities = true		}		public function setWhichAttached(nodes:Array):void{			nodesAttached = nodes		}			}}