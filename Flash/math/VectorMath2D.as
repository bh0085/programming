package math{		import Math	import math.ScalarField2D	import flash.geom.Rectangle	import flash.geom.Point	public class VectorMath2D{		public static var gradDelta = 2	//VECTOR ANGLE		public static function segSegDistAcrossAxis(seg1:Array,seg2:Array,axis:Array,minDist:Boolean,...args):Number{			var magAxis = Math.sqrt(Math.pow(axis[1][0] - axis[0][0],2) + Math.pow(axis[1][1] - axis[0][1],2))			var axisUnit=[(axis[1][0] - axis[0][0] )/magAxis,(axis[1][1] - axis[0][1])/magAxis]			var axisPerp=[-axisUnit[1],axisUnit[0]]									var seg1DotAlong = dotMultiply2D(axisUnit,[seg1[1][0] - seg1[0][0],seg1[1][1] - seg1[0][1]])			if(seg1DotAlong < 0 ){seg1 = seg1.reverse() ; seg1DotAlong *= -1}						var seg1DotTo = dotMultiply2D(axisUnit,[seg1[0][0] - axis[0][0],seg1[0][1] - axis[0][1]])			var seg2DotAlong = dotMultiply2D(axisUnit,[seg2[1][0] - seg2[0][0],seg2[1][1] - seg2[0][1]])			if(seg2DotAlong < 0 ){seg2 = seg2.reverse() ; seg2DotAlong *= -1}			var seg2DotTo = dotMultiply2D(axisUnit,[seg2[0][0] - axis[0][0],seg2[0][1] - axis[0][1]])			if(seg1DotTo < seg2DotTo){				reversed = false				var segs = [seg1,seg2]				var dotsTo=[seg1DotTo,seg2DotTo]				var dotsAlong=[seg1DotAlong,seg2DotAlong]			} else {				var reversed = true				 segs = [seg2,seg1]				 dotsTo=[seg2DotTo,seg1DotTo]				 dotsAlong=[seg2DotAlong,seg1DotAlong]							}					if(dotsTo[0] + dotsAlong[0]  < dotsTo[1]){ return -1}			var mags = [Math.sqrt(Math.pow(segs[0][1][0] - segs[0][0][0],2) + Math.pow(segs[0][1][1] - segs[0][0][1],2 )),Math.sqrt(Math.pow(segs[1][1][0] - segs[1][0][0],2) + Math.pow(segs[1][1][1] - segs[1][0][1],2))]			var uADots=[dotsAlong[0] / mags[0],dotsAlong[1] / mags[1]]			var unitsA = [[ (segs[0][1][0] - segs[0][0][0])/mags[0],(segs[0][1][1] - segs[0][0][1])/mags[0]], [(segs[1][1][0] - segs[1][0][0])/mags[1],(segs[1][1][1] - segs[1][0][1])/mags[1]]]			var dotsP  = [dotMultiply2D(unitsA[0],axisPerp),dotMultiply2D(unitsA[1],axisPerp)]			var magDotsP = [dotsP[0] * mags[0],dotsP[1] * mags[1]]			var dotsA  = uADots			var magDotsA = dotsAlong						var h0s = [dotMultiply2D(axisPerp,[segs[0][0][0] - axis[0][0],segs[0][0][1]]),dotMultiply2D(axisPerp,[segs[1][0][0] - axis[0][0],segs[1][0][1] - axis[0][1]])]																								if(dotsTo[0] + dotsAlong[0]  < dotsTo[1] + dotsAlong[1]){				var dh1 = magDotsP[0] / magDotsA[0] * (dotsTo[1] - dotsTo[0]) 				var dh2 = magDotsP[1] / magDotsA[0] * (dotsTo[0] + dotsAlong[0] - dotsTo[1])				var dist1 = h0s[0] + dh1 - h0s[1]				var pair1 =[ [segs[1][0][0] + dist1 *axisPerp[0],segs[1][0][1] + dist1 *axisPerp[1]],[segs[1][0][0],segs[1][0][1]]]				var dist2 = h0s[0] + magDotsP[0] - h0s[1] - dh2				var pair2 =[ [segs[0][1][0],segs[0][1][1]],[segs[0][1][0] - dist2 *axisPerp[0],segs[0][1][1] - dist2 *axisPerp[1]]]			} else {				var dh1 = magDotsP[0] / magDotsA[0] * (dotsTo[1] - dotsTo[0]) 				var dh1Prime = magDotsP[0] / magDotsA[0] * (dotsTo[1] + dotsAlong[1] - dotsTo[0]) 				var dh2 = magDotsP[1]				var dist1 = h0s[0] + dh1 - h0s[1]				var pair1 = [[segs[1][0][0] + dist1 *axisPerp[0],segs[1][0][1] + dist1 *axisPerp[1]],[segs[1][0][0],segs[1][0][1]]]				var dist2 = h0s[0] + dh1Prime - h0s[1] - dh2								var pair2 =[[segs[1][1][0] + dist2 *axisPerp[0],segs[1][1][1] + dist2 *axisPerp[1]] ,[segs[1][1][0],segs[1][1][1]]]					}			if(args.length == 0){var extra = new Array() } else {extra = args[0]}			if(reversed){				pair1 = pair1.reverse(), pair2 = pair2.reverse()}			if(minDist){				if(dist1 < 0 && dist2 > 0){						var intersect = lineLineIntersect(seg1,seg2)						extra.push([intersect,intersect])						return 0				} else { 					if(Math.abs(dist1) < Math.abs(dist2)){						extra.push(pair1)						return Math.abs(dist1)					} else {						extra.push(pair2)						return Math.abs(dist2)									}				}			} else {				if(Math.abs(dist1) > Math.abs(dist2)){					extra.push(pair1)					return Math.abs(dist1)				} else {					extra.push(pair2)					return Math.abs(dist2)								}						}											}			public static function angle1To2(unit1:Array,unit2:Array):Number{				var a1 = Math.asin(unit1[1])				if(unit1[0] < 0){ a1 = Math.PI - a1 }				var a2 = Math.asin(unit2[1])				if(unit2[0] < 0){ a2 = Math.PI - a2 }								var angleDelta = a2 - a1				if(isNaN(angleDelta)){					trace(NaN, unit1,unit2)					return angleDelta				}				var search = true			 	while( search ){					if(angleDelta < -1 * Math.PI) { angleDelta += Math.PI * 2 }					if(angleDelta > Math.PI) {angleDelta -= Math.PI*2 }					if(Math.abs(angleDelta) <= Math.PI) {search = false}				}				return(angleDelta)												}		public static function vectorGetAngle(v:Array):Number{			var magV = Math.sqrt(Math.pow(v[0],2) + Math.pow(v[1],2))			var unit1 = [v[0] / magV,v[1]/magV]			var a1 = Math.asin(unit1[1])			if(unit1[0] < 0){ a1 = Math.PI - a1 }						return a1		}	//PT RECTANGLE		public static function ptRectMinMaxDist(pt:Array, rect:Rectangle,maxClosest:Boolean):Array{						if(rect.containsPoint(new Point(pt[0],pt[1]))){								var min = 0							} else {				var s1 = rect.height/rect.width				var s2 = -s1				var h1 = (pt[0] - rect.x)*s1 + rect.y				var h2 = (pt[0] - rect.x)*s2 + rect.y + rect.height				if(pt[1] < h1){					if(pt[1] < h2){						var seg0 = [rect.x,rect.y]						var seg1 = [rect.x + rect.width, rect.y]					} else {						seg0 = [rect.x + rect.width,rect.y]						seg1 = [rect.x + rect.width, rect.y + rect.height]					}				} else {					if(pt[1] < h2){						seg0 = [rect.x,rect.y + rect.height]						seg1 = [rect.x, rect.y]					} else {						seg0 = [rect.x + rect.width,rect.y + rect.height]						seg1 = [rect.x , rect.y + rect.height]					}				}				var out = ptLineDist(pt,seg0,seg1)				 min = out[0]			} 			var mMin = -1			var mSec = -1			var mMax = -1			for(var i = 0; i < 4 ; i++){				if(i == 0 || i ==1){var ptX = rect.x} else{ptX = rect.x + rect.width}				if(i == 0 || i ==2){var ptY = rect.y} else{ptY = rect.y + rect.height}								var thisDist = Math.sqrt(Math.pow(pt[0] - ptX,2) + Math.pow(pt[1] - ptY,2))				if(thisDist < mMin || mMin == -1){					mSec = mMin					mMin = thisDist				} else { if( thisDist < mSec || mSec == -1){						mSec = thisDist					}				}				if(thisDist >mMax || mMax == -1){					mMax = thisDist				}			}			if(maxClosest){return [min,mSec]} else {return [min,mMax]}		}		public static function ptRectMinDist(pt:Array, rect:Rectangle):Number{						if(rect.containsPoint(new Point(pt[0],pt[1]))){								var min = 0							} else {				var s1 = rect.height/rect.width				var s2 = -s1				var h1 = (pt[0] - rect.x)*s1 + rect.y				var h2 = (pt[0] - rect.x)*s2 + rect.y + rect.height				if(pt[1] < h1){					if(pt[1] < h2){						var seg0 = [rect.x,rect.y]						var seg1 = [rect.x + rect.width, rect.y]					} else {						seg0 = [rect.x + rect.width,rect.y]						seg1 = [rect.x + rect.width, rect.y + rect.height]					}				} else {					if(pt[1] < h2){						seg0 = [rect.x,rect.y + rect.height]						seg1 = [rect.x, rect.y]					} else {						seg0 = [rect.x + rect.width,rect.y + rect.height]						seg1 = [rect.x , rect.y + rect.height]					}				}				var out = ptLineDist(pt,seg0,seg1)				 min = out[0]			} 			return(min)		}			//PT LINE		public static function ptLineClosest(pt:Array,seg0:Array,seg1:Array, ... args):Array{			//The first element of args is a boolean, entireline			if(args.length != 0){var entireline = args[0]} else { entireline = false }			var vecAlong = [seg1[0] - seg0[0],seg1[1] - seg0[1]]			var magAlong = Math.sqrt(Math.pow(vecAlong[0],2) + Math.pow(vecAlong[1],2))			var unitAlong =[vecAlong[0] / magAlong, vecAlong[1]/ magAlong]			var unitPerp  =[-unitAlong[1] , unitAlong[0]]			var distPerp  =dotMultiply2D([pt[0] - seg0[0],pt[1] - seg0[1]],unitPerp)			var altitude  =[distPerp * unitPerp[0], distPerp * unitPerp[1]]			var intersect =[pt[0] - altitude[0],pt[1] - altitude[1]]			var xint = intersect[0]			var yint = intersect[1]									var segEndHit = -1			if(!entireline){				var pt = [xint,yint]				if(! ptInHemisphere(pt,seg0,unitAlong) ){segEndHit = 0; xint = seg0[0] ; yint = seg0[1]}				if(  ptInHemisphere(pt,seg1,unitAlong) ){segEndHit = 1; xint = seg1[0] ; yint = seg1[1]}			}						return [xint, yint,segEndHit]		}		public static function ptLineDist(pt:Array,seg0:Array,seg1:Array, ... args):Array{			if (args.length != 0){var entireLine = args[0] } else { entireLine = false} 						var d01 = Math.sqrt(Math.pow(seg0[0] - seg1[0],2) + Math.pow(seg0[1] - seg1[1],2))			var uAlong =[( seg1[0] - seg0[0])/d01,(seg1[1] - seg0[1] )/d01]			var uPerp  =[-uAlong[1],uAlong[0]]			var toPt   =[pt[0] - seg0[0], pt[1] - seg0[1]]			var dot = dotMultiply2D(uAlong,toPt)			if(!entireLine){				if(dot < 0){						var dist = Math.sqrt(Math.pow(toPt[0],2) + Math.pow(toPt[1],2))						var hasHit = 0					} else { if(dot > d01) {								dist = Math.sqrt(Math.pow(pt[0] - seg1[0],2) + Math.pow(pt[1] - seg1[1],2))								hasHit = 1								}						 else { 							dist = Math.abs(dotMultiply2D(toPt,uPerp))							hasHit = -1						}					}			} else {				dist = Math.abs(dotMultiply2D(toPt,uPerp))				hasHit = -1			}							return [dist, hasHit]		}		public static function ptLineAltitude(pt:Array,seg0:Array,seg1:Array, ... args):Array{			var d01 = Math.sqrt(Math.pow(seg0[0] - seg1[0],2) + Math.pow(seg0[1] - seg1[1],2))			var uAlong =[( seg1[0] - seg0[0])/d01,(seg1[1] - seg0[1] )/d01]			var uPerp  =[-uAlong[1],uAlong[0]]			var toPt   =[pt[0] - seg0[0], pt[1] - seg0[1]]			var dot = dotMultiply2D(uPerp,toPt)					var altitude = [uPerp[0] * dot, uPerp[1] * dot]			return altitude		}		public static function ptRayClosest(pt:Array,seg0:Array,segOnRay:Array):Array{			var vecAlong = [segOnRay[0] - seg0[0],segOnRay[1] - seg0[1]]			var magAlong = Math.sqrt(Math.pow(vecAlong[0],2) + Math.pow(vecAlong[1],2))			var unitAlong =[vecAlong[0] / magAlong, vecAlong[1]/ magAlong]			var unitPerp  =[-unitAlong[1] , unitAlong[0]]			var distPerp  =dotMultiply2D([pt[0] - seg0[0],pt[1] - seg0[1]],unitPerp)			var altitude  =[distPerp * unitPerp[0], distPerp * unitPerp[1]]			var intersect =[pt[0] - altitude[0],pt[1] - altitude[1]]			var xint = intersect[0]			var yint = intersect[1]									if(segOnRay[0] < seg0[0]){				if(xint > seg0[0]){					xint = seg0[0]					yint = seg0[1]				}			} else {				if(segOnRay[0] >seg0[0]){					if(xint < seg0[0]){						xint = seg0[0]						yint = seg0[1]					}				}			}						var segEndHit = -1			if(xint == seg0[0]){segEndHit = 0}						return [xint,yint,segEndHit]								}		public static function ptRayDist(pt:Array,seg0:Array,segOnRay:Array):Array{			var closestpt = ptRayClosest(pt,seg0,segOnRay)			return [Math.sqrt( Math.pow(closestpt[0] - pt[0],2) + Math.pow(closestpt[1] - pt[1],2)),closestpt[2]]									var d01 = Math.sqrt(Math.pow(seg0[0] - segOnRay[0],2) + Math.pow(seg0[1] - segOnRay[1],2))			var uAlong =[( segOnRay[0] - seg0[0])/d01,(segOnRay[1] - seg0[1] )/d01]			var uPerp  =[-uAlong[1],uAlong[0]]			var toPt   =[pt[0] - seg0[0], pt[1] - seg0[1]]			var dot = dotMultiply2D(uAlong,toPt)			if(dot < 0){				var dist = Math.sqrt(Math.pow(toPt[0],2) + Math.pow(toPt[1],2))				var hasHit = 0			}  else { 				dist = Math.abs(dotMultiply2D(toPt,uPerp))				hasHit = -1			}									return [dist, hasHit]				}				public static function ptInHemisphere(pt:Array, hemiPt:Array, hemiUnit:Array):Boolean{			var diff = [pt[0] - hemiPt[0],pt[1] - hemiPt[1]]			if(dotMultiply2D(diff,hemiUnit) > 0) {return true} else {return false}		}		public static function ptIsOnLine(pt:Array,linePt:Array,lineUnit:Array):Boolean{			var diff = [pt[0] - linePt[0],pt[1] - linePt[1]]			if(dotMultiply2D(diff,[-lineUnit[1],lineUnit[0]]) == 0){return true} else {return false}		}		public static function ptLineHeight(pt:Array,linePt:Array,lineUnit:Array):Number{			var diff = [pt[0] - linePt[0],pt[1] - linePt[1]]			return(dotMultiply2D(diff,[-lineUnit[1],lineUnit[0]]))		}				public static function pt3PtDistance(pt:Array,seg0:Array,seg1:Array,seg2:Array):Number{			var d1 = ptLineDist(pt,seg0,seg1)			var d2 = ptLineDist(pt,seg1,seg2)			return Math.min(d1[0],d2[0])		}		public static function dotMultiply2D(vector1:Array, vector2:Array):Number{						return vector1[0] * vector2[0] + vector1[1] * vector2[1]					}		public static function gradientAt(sfield:ScalarField2D,xat:Number, yat:Number):Array{			var xderiv =( sfield.valueAt(xat + gradDelta,yat) - sfield.valueAt(xat - gradDelta,yat)) / (2 * gradDelta)			var yderiv =( sfield.valueAt(xat,yat + gradDelta) - sfield.valueAt(xat,yat - gradDelta)) / (2 * gradDelta)			return [xderiv, yderiv]		}		public static function gradientAtExcluding(sfield:ScalarField2D,xat:Number, yat:Number,idxExclude):Array{			var xderiv =( sfield.valueAt(xat + gradDelta,yat,idxExclude) - sfield.valueAt(xat - gradDelta,yat,idxExclude)) / (2 * gradDelta)			var yderiv =( sfield.valueAt(xat,yat + gradDelta,idxExclude) - sfield.valueAt(xat,yat - gradDelta,idxExclude)) / (2 * gradDelta)			return [xderiv, yderiv]		}		public static function distance(v1:Array, v2:Array):Number{			return(Math.sqrt(Math.pow(v1[0] - v2[0],2) + Math.pow(v1[1] - v2[1],2)))		}		public static function vector1To2(v1:Array,v2:Array):Array{			return([v2[0] - v1[0], v2[1] - v1[1]])		}		public static function length(vector:Array):Number {			return Math.sqrt(Math.pow(vector[0],2) + Math.pow(vector[1],2))		}		public static function lineLineIntersect(segs1,segs2):Array{			var vA1 = [segs1[1][0] - segs1[0][0], segs1[1][1] - segs1[0][1]]			var mA1 = Math.sqrt(Math.pow(vA1[0],2) + Math.pow(vA1[1],2))				var uA1 =[vA1[0] / mA1, vA1[1]/ mA1]			var uP1 =[-uA1[1],uA1[0]]			var vA2 = [segs2[1][0] - segs2[0][0], segs2[1][1] - segs2[0][1]]			var mA2 = Math.sqrt(Math.pow(vA2[0],2) + Math.pow(vA2[1],2))				var uA2 =[vA2[0] / mA2, vA2[1]/ mA2]			var uP2 =[-uA2[1],uA2[0]]									var d0 = [segs2[0][0] - segs1[0][0],segs2[0][1] - segs1[0][1]]			var dAlong = dotMultiply2D(uA1,d0)			var seg1Above = [segs1[0][0] + uA1[0]*dAlong, segs1[0][1] + uA1[1]*dAlong]			var d1 = [segs2[0][0] - seg1Above[0],segs2[0][1] - seg1Above[1]]			var dotAlong = dotMultiply2D(uA2,uP1)			var dotDist = dotMultiply2D(uP1,d1)			if(dotAlong ==0){return null}			var distAlong = -dotDist / dotAlong						return [segs2[0][0] + uA2[0]* distAlong, segs2[0][1] + uA2[1]*distAlong]								}		public static function segSegDoesIntersect(segs1:Array,segs2:Array):Boolean{			var vA1 = [segs1[1][0] - segs1[0][0], segs1[1][1] - segs1[0][1]]			var mA1 = Math.sqrt(Math.pow(vA1[0],2) + Math.pow(vA1[1],2))				var uA1 =[vA1[0] / mA1, vA1[1]/ mA1]			var uP1 =[-uA1[1],uA1[0]]			var vA2 = [segs2[1][0] - segs2[0][0], segs2[1][1] - segs2[0][1]]			var mA2 = Math.sqrt(Math.pow(vA2[0],2) + Math.pow(vA2[1],2))				var uA2 =[vA2[0] / mA2, vA2[1]/ mA2]			var uP2 =[-uA2[1],uA2[0]]						var v21 = [segs2[0][0] - segs1[0][0],segs2[0][1] - segs1[0][1]]			var h21 = dotMultiply2D(v21,uP1)			var distAlong2 = - h21 / dotMultiply2D(uA2,uP1) 			if(distAlong2 >0 && distAlong2<mA2){				var v12 = [-v21[0],-v21[1]]				var h12 = dotMultiply2D(v12,uP2)				var distAlong1 = - h12 / dotMultiply2D(uA1,uP2)				if(distAlong1 > 0 && distAlong1 < mA1){					return true				}			}			return false											}		public static function segSegClosestPair(segs1:Array,segs2:Array):Array{						var vA1 = [segs1[1][0] - segs1[0][0], segs1[1][1] - segs1[0][1]]			var mA1 = Math.sqrt(Math.pow(vA1[0],2) + Math.pow(vA1[1],2))				var uA1 =[vA1[0] / mA1, vA1[1]/ mA1]			var uP1 =[-uA1[1],uA1[0]]			var vA2 = [segs2[1][0] - segs2[0][0], segs2[1][1] - segs2[0][1]]			var mA2 = Math.sqrt(Math.pow(vA2[0],2) + Math.pow(vA2[1],2))				var uA2 =[vA2[0] / mA2, vA2[1]/ mA2]			var uP2 =[-uA2[1],uA2[0]]								var intersect = lineLineIntersect(segs1,segs2)			var dist1 = ptLineDist(intersect,segs1[0],segs1[1])			var dist2 = ptLineDist(intersect,segs2[0],segs2[1])			var segEndHit = [-1,-1]			if( (dist1[0] < Math.pow(10,-2)) && (dist2[0] <Math.pow( 10,-2))){ return ([[intersect,intersect],[-1,-1]])}			if(dist1 > dist2){				if(dotMultiply2D(uA1,[intersect[0] - segs1[0][0], intersect[0] - segs1[0][0]] ) > 0){					segEndHit[0] = 1					var pt1 = segs1[1]				} else {					segEndHit[0] = 0					var pt1 = segs1[0]				}				var out = ptLineClosest(pt1,segs2[0],segs2[1])				var pt2 = [out[0],out[1]]				segEndHit[1] = out[2]																					   																								   			} else {				if(dotMultiply2D(uA2,[intersect[0] - segs2[0][0], intersect[0] - segs2[0][0]] ) > 0){					segEndHit[1] = 1					var pt2 = segs2[1]				} else {					segEndHit[1] = 0					var pt2 = segs2[0]				}				var out = ptLineClosest(pt2,segs1[0],segs1[1])				var pt1 = [out[0],out[1]]				segEndHit[0] = out[2]			}																					   						return [[pt1,pt2], segEndHit]		}		public static function segSegDistance(segs1:Array,segs2:Array):Number{			var out = segSegClosestPair(segs1,segs2)			var pts = out[0]			var dist = Math.sqrt(Math.pow(pts[1][0] - pts[0][0],2) + Math.pow(pts[1][1] - pts[0][1],2))			return dist		}				public static function segLineIntersect(segs:Array,lines:Array):Array{			var out = lineLineIntersect(segs,lines)						var xint = out[0]			var yint = out[1]			var unitAlong = getUnit([segs[1][0] - segs[0][0],segs[1][1] - segs[1][0]])						var segEndHit = -1			var pt = [xint,yint]			if(! ptInHemisphere(pt,segs[0],unitAlong) ){segEndHit = 0; xint = segs[0][0] ; yint = segs[0][1]}			if(  ptInHemisphere(pt,segs[1],unitAlong) ){segEndHit = 1; xint = segs[1][1] ; yint = segs[1][1]}									return [xint,yint,segEndHit]											}		public static function seg1IsAboveOrBelowSeg2(segs1:Array,segs2:Array,...args):Boolean{			if(args.length ==0){verbose = false} else{var verbose = args[0]}			var unitAlong = getUnit([segs2[1][0]-segs2[0][0],segs2[1][1] - segs2[0][1]])			var pt1In1 = ptInHemisphere(segs1[0],segs2[0],unitAlong)			var pt2In1 = ptInHemisphere(segs1[1],segs2[0],unitAlong)			if(verbose){trace(pt1In1,pt2In1,unitAlong)}			if(pt1In1 != pt2In1){				return true			} else {				if(!pt1In1 && !pt2In1){					return false				} else {					var pt1In2 = ptInHemisphere(segs1[0],segs2[1],unitAlong)					var pt2In2 = ptInHemisphere(segs1[1],segs2[1],unitAlong)							if(!pt1In2 || !pt2In2){						return true					} else {						return false					}				}			}					}		public static function rotate(vec:Array,angleRads:Number):Array{			return [Math.cos(angleRads)*vec[0] - Math.sin(angleRads)*vec[1],Math.cos(angleRads)*vec[1] + Math.sin(angleRads)*vec[0]]		}		public static function mVecByScalar(vector:Array,scalar:Number):Array{			return([vector[0] * scalar, vector[1] * scalar])		}		public static function sum(v1:Array,v2:Array):Array{			return([v1[0] + v2[0], v1[1] + v2[1]])		}		public static function getUnit(vec:Array):Array{			var magV = Math.sqrt(Math.pow(vec[0],2) + Math.pow(vec[1],2))			return([vec[0] /magV, vec[1] / magV])		}	}		}