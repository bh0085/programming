package math{		import Math	import math.ScalarField3D		public class VectorMath3D{				public static function dotMultiply3D(vector1:Array, vector2:Array):Number{						return vector1[0] * vector2[0] + vector1[1] * vector2[1] + vector1[2] *vector2[2]					}		public static function crossMultiply3D(vector1:Array,vector2:Array):Array{						var output = [0,0,0]						output[0] = vector1[1] * vector2[2] - vector1[2] * vector2[1]						output[1] = vector1[2] * vector2[0] - vector1[0] * vector2[2]						output[2] = vector1[0] * vector2[1] - vector1[1] * vector2[0]						return output		}				public static var gradDelta = 2				public static function gradientAt(sfield:ScalarField3D,xat:Number, yat:Number, zat:Number):Array{			var xderiv =( sfield.valueAt(xat + gradDelta,yat,zat) - sfield.valueAt(xat - gradDelta,yat,zat)) / (2 * gradDelta)			var yderiv =( sfield.valueAt(xat,yat + gradDelta,zat) - sfield.valueAt(xat,yat - gradDelta,zat)) / (2 * gradDelta)			var zderiv =( sfield.valueAt(xat,yat,zat + gradDelta) - sfield.valueAt(xat,yat,zat - gradDelta)) / (2 * gradDelta)						return [xderiv, yderiv, zderiv]					}				public static function gradientAtExcluding(sfield:ScalarField3D,xat:Number, yat:Number,zat:Number,idxExclude):Array{			var xderiv =( sfield.valueAt(xat + gradDelta,yat,zat,idxExclude) - sfield.valueAt(xat - gradDelta,yat,zat,idxExclude)) / (2 * gradDelta)			var yderiv =( sfield.valueAt(xat,yat + gradDelta,zat,idxExclude) - sfield.valueAt(xat,yat - gradDelta,zat,idxExclude)) / (2 * gradDelta)			var zderiv =( sfield.valueAt(xat,yat,zat + gradDelta,idxExclude) - sfield.valueAt(xat,yat,zat - gradDelta,idxExclude)) / (2 * gradDelta)			return [xderiv, yderiv, zderiv]		}				public static function length(vector:Array):Number {			return Math.sqrt(Math.pow(vector[0],2) + Math.pow(vector[1],2) + Math.pow(vector[2],2))		}			}}