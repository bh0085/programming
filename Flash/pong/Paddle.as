package pong{	import flash.display.Sprite	import flash.events.Event	import flash.display.Shape	import pong.graphics.Stretch1	 class Paddle extends Sprite {		var w = 20		var h = 50		var vy = 0		var vx = 0		var omega = 0		var resizeV = 0		var targetingCircle:Sprite,paddleShape:Sprite, paddleGraphic:Shape, paddleShapeGfx:Shape, targetingArc		var targetMask:Shape, shapeMask:Shape		var springInitialXY, springInitialRotation, springInitialScale, springChargedScale		var springHeld = false, springHeldSoFar:Number		var springRelease = false		var chargeTime = 8, dischargeTime = 2		var resetDelay = 10 , resetSoFar = 0, resetting = false		var defaultRotation = 0		var circleR0 = 90		var paddleMaxHeight = 100, paddleHalfWidth = 25		var defaultX = 0, springInitialX:Number,springStretchedX:Number		var stretch:Stretch1, sAlpha = .5		var flipped = false		var speedMultiplier = 1		var fixedX = true				var paddleTrail = false		var paddleStretch = 0		var paddleMax = 20				public function Paddle(){			stretch = new Stretch1()			stretch.alpha = 0			stretch.scaleX = .3			stretch.scaleY = .3						paddleShape = new Sprite()			paddleShapeGfx = new Shape()			paddleShape.addChild(paddleShapeGfx)			paddleShapeGfx.graphics.lineStyle(10)			paddleShapeGfx.graphics.drawCircle(0,0,circleR0)			paddleShape.visible = true						targetingCircle = new Sprite()			targetingArc = new Shape()			targetingArc.graphics.lineStyle(2)			targetingArc.graphics.drawCircle(0,0,circleR0)			targetingCircle.addChild(targetingArc)			targetingCircle.alpha = .6			var targetMask = new Shape()			targetMask.graphics.beginFill(0x000000)			targetMask.graphics.drawRect(-paddleMax -1,-paddleMaxHeight/2,2*paddleMax +2, paddleMaxHeight)				addChild(targetMask)			var shapeMask = new Shape()			shapeMask.graphics.beginFill(0x000000)			shapeMask.graphics.drawRect(-paddleHalfWidth,-paddleMaxHeight/2,paddleHalfWidth*2, paddleMaxHeight)			paddleShape.addChild(shapeMask)						targetingArc.mask = targetMask			targetingCircle.x = -circleR0			paddleShapeGfx.mask = shapeMask			paddleShapeGfx.x = - circleR0						addChild(stretch)			addChild(paddleShape)			addChild(targetingCircle)			addEventListener(Event.ENTER_FRAME,paddleNextFrame)		}		function flip(){			rotation = 180			defaultRotation = 180			flipped = true					}		function unflip(){			rotation = 0			defaultRotation = 0			flipped = false		}				function paddleNextFrame(e:Event){			var maxDist = 30			var maxTwist =50			if(springHeld ){				var sDist = [springInitialXY[0] - x, springInitialXY[1] - y]				var sTwist = springInitialRotation - rotation				var dist = Math.sqrt(Math.pow(sDist[0],2) + Math.pow(sDist[1],2))				if(dist < maxDist){var vDamp = (maxDist - dist)/(maxDist)} else { vDamp = 0 }				if(Math.abs(sTwist) <maxTwist){var wDamp = (maxTwist - Math.abs(sTwist))/(maxTwist)} else {wDamp = 0}				vx *= vDamp				vy *= vDamp				omega *= wDamp				springHeldSoFar++								trace(sTwist)				if(sTwist<-3){					if(stretch.scaleY >0){stretch.scaleY*=-1}					stretch.x = 0					stretch.y = paddleMaxHeight / 2					stretch.alpha = sAlpha*(-sTwist/50)				}				if(sTwist>3){					if(stretch.scaleY <0){stretch.scaleY*=-1}					stretch.x = 0					stretch.y = -paddleMaxHeight / 2					stretch.alpha = sAlpha*(sTwist/50)				}								var newStretch = paddleSeries(-springInitialX, chargeTime, springHeldSoFar)				resizeV = newStretch - paddleStretch				springStretchedX = paddleStretch							}						var k1 = 1			var k2 = 1			if(springRelease){				var sForce =  [k1 *( springInitialXY[0] - x), k1 * ( springInitialXY[1] - y) ]				 sTwist = k1* (springInitialRotation - rotation)				vx += sForce[0]				vy += sForce[1]				omega+= sTwist				resetting = true				springRelease = false			}			if(resetting){				sForce = [k2 *( springInitialXY[0] - x), k2 *( springInitialXY[1] - y)]				 sTwist = k2 * (springInitialRotation - rotation)				vx += sForce[0]				vy += sForce[1]				omega+= sTwist				resetSoFar += 1				if(resetSoFar <= 3){					stretch.alpha = sAlpha* (3 -resetSoFar)/3				}								newStretch = paddleSeries(-springStretchedX, dischargeTime, resetSoFar)				resizeV = newStretch - paddleStretch													if(resetSoFar >= resetDelay){resetting = false}				var dampen = (1 - (resetSoFar /resetDelay))								vx *= dampen				vy *= dampen			 	omega*= dampen							}						if(fixedX){			var xDiff = (defaultX - x)			if(Math.abs(xDiff) > 10) {vx += xDiff / 10}			}						y  += vy			vy *= .75			x += vx			vx *= .75						resizeV *=.75			paddleStretch += resizeV			if(paddleStretch >paddleMax){paddleStretch = paddleMax}			if(paddleStretch <-paddleMax){paddleStretch = -paddleMax}			paddleResize()						rotation += omega			omega *= .75		}		public function setSpring(){			springInitialXY = [x, y]			springInitialRotation  =rotation			springInitialX =paddleStretch			springHeld = true			springHeldSoFar = 0		}		public function releaseSpring(){			springHeld = false			springRelease = true			resetSoFar = 0					}				public function paddleVelocity(ball:Ball):Array{			var ballXY = [ ball.x - x, ball.y - y]			var paddleEnd = [- Math.sin(rotation * Math.PI / 180) * paddleMaxHeight/2, Math.cos(rotation * Math.PI / 180) * paddleMaxHeight/2]			var ballAlong = paddleEnd[0]/paddleMaxHeight*2 * ballXY[0] + paddleEnd[1]/paddleMaxHeight*2 * ballXY[1]			var magAlong = Math.abs(ballAlong)			if(magAlong > paddleMaxHeight/2){magAlong = paddleMaxHeight/2}			var apparentStretchV = resizeV * 1 - ((paddleMaxHeight/2 - magAlong)/(paddleMaxHeight/2))^2			var unitPerp = [Math.cos(rotation *Math.PI/180),Math.sin(rotation * Math.PI/180)]			var paddleVel = [vx - omega*(Math.PI/180)*(ball.y - y) +unitPerp[0]*apparentStretchV, vy + omega*(Math.PI/180)*(ball.x - x) +unitPerp[1]*apparentStretchV]			return paddleVel																							}				public function returnHome(){			omega += ( defaultRotation - rotation ) / 5			resizeV += (15 - paddleStretch) / 3 					}		public function paddleStretchRight(){resizeV +=6}		public function paddleStretchLeft(){resizeV -=6}		public function paddleSeries(finalPos:Number, numSteps:Number, step:Number):Number{			var frac = (step - numSteps/2)/(numSteps/2)			if(frac >1){frac = 1}			var posNow = frac * finalPos			return posNow		}		public function paddleResize(){						var radius = getRadius(paddleStretch)						targetingArc.graphics.clear()						targetingArc.graphics.lineStyle(2)						targetingArc.graphics.drawCircle(0,0,Math.abs(radius))						targetingCircle.x = - radius + paddleStretch						paddleShapeGfx.graphics.clear()						paddleShapeGfx.graphics.lineStyle(10)						paddleShapeGfx.graphics.drawCircle(0,0,radius)						paddleShapeGfx.x = - radius + paddleStretch		}		public function getScale(paddleEdgeOffset:Number){			var h = paddleMaxHeight/2			if((paddleEdgeOffset) > paddleHalfWidth){paddleEdgeOffset = paddleHalfWidth}			if((paddleEdgeOffset) < -paddleHalfWidth){paddleEdgeOffset = -paddleHalfWidth}			var slope = -h / Math.abs( paddleEdgeOffset ) 			var perp = -1 / slope			var pt = [-Math.abs(paddleEdgeOffset/2), h/2 ]			var xInt = - Math.abs(paddleEdgeOffset/2) - h/2/perp			var radius = Math.abs(xInt)			if(radius > 200){radius = 200}			var scl = radius/circleR0			if(paddleEdgeOffset <0){scl *= -1}			return scl					}		public function getRadius(paddleEdgeOffset:Number){			var h = paddleMaxHeight/2			if((paddleEdgeOffset) > paddleHalfWidth){paddleEdgeOffset = paddleHalfWidth}			if((paddleEdgeOffset) < -paddleHalfWidth){paddleEdgeOffset = -paddleHalfWidth}			var slope = -h / Math.abs( paddleEdgeOffset ) 			var perp = -1 / slope			var pt = [-Math.abs(paddleEdgeOffset/2), h/2 ]			var xInt = - Math.abs(paddleEdgeOffset/2) - h/2/perp			var radius = Math.abs(xInt)			if(radius > 500){radius = 500}			if(paddleEdgeOffset <0){radius *= -1}			return radius					}					public function moveUp(){vy -= speedMultiplier * 16} //if(!resetting){vy += 7*Math.cos(rotation / 180  * Math.PI); vx += -7 *Math.sin(rotation / 180 * Math.PI) }}		public function moveDown(){vy += speedMultiplier * 16} //if(!resetting){vy += -7*Math.cos(rotation / 180  * Math.PI); vx += 7 *Math.sin(rotation / 180 * Math.PI)}}				public function moveLeft(){}//{ if(!resetting){vy += -7*Math.sin(rotation / 180  * Math.PI); vx += -7 *Math.cos(rotation / 180 * Math.PI)}}		public function moveRight(){}//{ if(!resetting){vy += 7*Math.sin(rotation / 180  * Math.PI); vx += 7 *Math.cos(rotation / 180 * Math.PI)}}		public function twistCW() {omega += 10 }		public function twistCCW() {omega-= 10 }	}	}