package paths{	import flash.display.Shape	import flash.display.Sprite	import flash.display.DisplayObject	import flash.display.BlendMode	import flash.display.BitmapData	import flash.display.Bitmap	import flash.text.TextField	import flash.geom.Matrix	import flash.geom.Rectangle	import flash.geom.Point	import flash.geom.ColorTransform	import flash.utils.getTimer	import physics.objects.PhysObject	import physics.PhysUniverse		import mygraphics.ObjObj	import math.VectorMath2D		public class PhysOutline {		public var outline:CtdOutline		public var holes:Array				public function setObject(po:PhysObject){			outline.setObject(po)			for(var i = 0; i<holes.length; i++){				holes[i].setObject( po )			}		}		public static function sphereOutline(radius:Number,nPoints:Number,...args):PhysOutline{			if(args.length == 0){var midXY = [0,0]} else { midXY = args[0] }			var thisOutline = new PhysOutline()			var o = new CtdOutline()			var num = nPoints			for(var i = 0 ; i < num ; i++){				var angle = Math.PI * 2 * i / (num)				var nxy = [Math.cos(angle) * (radius ) + midXY[0], Math.sin(angle) * (radius) + midXY[1]]				var node = new Node(nxy[0],nxy[1])				o.pushNode(node)							}			thisOutline.setOutline(o)			thisOutline.outline.genFill()			thisOutline.outline.genOrientation()			thisOutline.outline.genSegments()			return thisOutline					}		public static function irregularSphereOutline(irregularity:Number,radius:Number,nPoints:Number,...args):PhysOutline{			if(args.length == 0){var midXY = [0,0]} else { midXY = args[0] }			var thisOutline = new PhysOutline()			var o = new CtdOutline()			var num = nPoints			for(var i = 0 ; i < num ; i++){				var angle = Math.PI * 2 * i / (num )				var nxy = [Math.cos(angle) * - (radius +radius*  Math.random() *irregularity) + midXY[0], Math.sin(angle) * (radius + radius *irregularity* Math.random()) + midXY[1]]				var node = new Node(nxy[0],nxy[1])				o.pushNode(node)							}			thisOutline.setOutline(o)			thisOutline.outline.genFill()			thisOutline.outline.genOrientation()			thisOutline.outline.genSegments()			return thisOutline					}		public function PhysOutline(){			holes = new Array()		}		public function setOutline(o:CtdOutline):void{			outline = o		}		public static function rectInsideRectOutside(f1:DisplayObject,f2:DisplayObject):Array{			f2.blendMode = BlendMode.ADD			var s = new Sprite			s.addChild(f1)			s.addChild(f2)			var b1 = f1.getBounds(s)			var b2 = f2.getBounds(s)			var b0 = b1.intersection(b2)			if(b0.height == 0){return null}			var data = new BitmapData(b0.width,b0.height,false,0x000000)			var mat = new Matrix(1,0,0,1,-b0.x,-b0.y)			data.draw(s,mat)			var outside = data.getColorBoundsRect(0xFFFFFF,0x00FF00)			var inside = data.getColorBoundsRect(0xFFFFFF,0xFFFF00)						return ([outside,inside])					}		public function intersect2(h:CtdOutline, eraIntUni:Number,...out):CtdOutline{			if(out.length != 0){var extra = out[0]}			var outlines = [outline,h]			var intersection = 	 CtdOutline.findIntersections(outline,h)			var pts = new Array()			var prodsOut = new Array()			var nodes = new Array()			for(var i = 0 ; i < intersection.length ; i++){				pts.push(intersection[i][1])				nodes.push(intersection[i][0])				prodsOut.push(intersection[i][2])			}						if(eraIntUni == 0){var searchIn = [-1,1]} 			else {				if(eraIntUni == 1){searchIn = [1,1]}				else {searchIn = [-1,-1]}			}						var n12 = [ outline.nodesInOrder(), h.nodesInOrder()]			var indicesOf = [new Array(), new Array()]			var sort = new Array()			for(var i = 0 ; i < 2 ; i++){				for (var j = 0 ; j < nodes.length; j++){					indicesOf[i].push(n12[i].indexOf(nodes[j][i]))				}				sort[i] = indicesOf[i].sort(8)			}			//positions of the elements of sort denote the relative positions of nodes in either outline									var intTally = new Array()			for(var i = 0 ; i < nodes.length ; i++){intTally[i] = 0}			var allArcs = new Array()			var makePaths = true			while(makePaths){				var currOutline = 1				var currInt = intTally.indexOf(0)				if(currInt == -1){ break }				var arcs = new Array()				var makeArcs = true				//arcs contains three entries: [starting node, last node[,[startingInt,finishingInt], direction				while(makeArcs){					if(searchIn[currOutline] * prodsOut[currInt][currOutline] < 0){var searchFwd =true} else {searchFwd = false}						var startNode = nodes[currInt][currOutline]					var idxPos = sort[currOutline].indexOf(currInt)											if(searchFwd){ var nextPos = idxPos + 1 } else {nextPos = idxPos -1}					if(nextPos == sort[currOutline].length){nextPos = 0}					if(nextPos == -1){nextPos = sort[currOutline].length - 1}										var nextInt = sort[currOutline][nextPos]					var finishNode = nodes[nextInt][currOutline]										arcs.push([[startNode,finishNode],[currInt,nextInt],searchFwd,currOutline])					intTally[currInt] += 1					intTally[nextInt] += 1					currOutline = 1 - currOutline					currInt = nextInt					if(intTally[currInt] > 1){makeArcs = false}				}				allArcs.push(arcs)			}						var outs = new Array()			for(var j = 0 ; j < allArcs.length ; j ++){				var newPath = new CtdOutline()				arcs = allArcs[j]				for(var i = 0 ; i < arcs.length ; i ++){					var searchForward = arcs[i][2]					if(searchForward){startNode = arcs[i][0][0].next} else {startNode = arcs[i][0][0]}					if(searchForward){finishNode= arcs[i][0][1]} else {finishNode= arcs[i][0][1].next}					if(newPath.first != null){var nodeAt = newPath.first.prev}					newPath.spliceAt(nodeAt,startNode,finishNode,startNode.thisCtdOutline,!searchForward)					var tempInt = arcs[i][1][1]					var intXY = pts[tempInt]					newPath.spliceOneAt(newPath.first.prev,new Node(intXY[0],intXY[1]))				}								outs.push(newPath)			}			outs = outs.sortOn("numNodes",2)			if(outs.length == 0){ return null }									if(extra != null) {extra.push(allArcs),extra.push(intersection)}			return outs[0]				}						public function cleanOutline():void{			outline.mergeNeighbors(20)		}				public function edgeInsideOf(other:PhysOutline):Rectangle{						var s1 = new Sprite()			s1.addChild(outline.drawFillExt(0xF00000,1))			s1.addChild(outline.drawOutlineExt(false,null,4,0x0F0000))			var s2 = new Sprite()			s2.addChild(other.outline.drawFillExt(0x00F000,1))			s2.addChild(other.outline.drawOutlineExt(false,null,4,0x000F00))			s2.blendMode = BlendMode.ADD			var s = new Sprite			s.addChild(s1)			s.addChild(s2)			var b1 = s1.getBounds(s)			var b2 = s2.getBounds(s)			var b0 = b1.intersection(b2)			if(b0.height == 0){return null}			var data = new BitmapData(b0.width,b0.height,false,0x000000)			var mat = new Matrix(1,0,0,1,-b0.x,-b0.y)			data.draw(s,mat)			var o1intf2 = data.getColorBoundsRect(0xFFFFFF,0x00FF00)			return o1intf2								}		public static function intersectionRectangle(po1:PhysOutline,po2:PhysOutline,...args):Rectangle{			if(args.length ==0){var padding = 0} else { padding = args[0] }			var o1 = po1.outline			var o2 = po2.outline			var s1 = new Sprite()			s1.addChild(o1.drawFillExt(0x000000,1,padding * 2))			var s2 = new Sprite()			s2.addChild(o2.drawFillExt(0x000000,1,padding * 2))			var s0 = new Sprite()			s0.addChild(s1)			s0.addChild(s2)				var rect = ObjObj.findIntersect(s1,s2,s0)									if(rect == null){rect = new Rectangle()}			return rect								}		public function drawShape(...args):Sprite{			if(args.length <1){var thick = 10} else {thick = args[0] }			if(args.length <2 ){var outlineColor = 0xCCCCCC} else {outlineColor = args[1]}			if(args.length <3){var fillColor = 0xFFFFFF} else {fillColor = args[2]}			if(args.length <4){var smooth = true} else {smooth = args[3]}			var out = new Sprite					if(smooth){				out.addChild(outline.drawSmoothOutline(thick,outlineColor,true,fillColor))			} else {				out.addChild(outline.simpleDraw(true,true,thick,outlineColor,fillColor))			}			return out		}				public function drawShapeExt(...args):Sprite{			if(args.length <1){var drawOutline = false} else {drawOutline = args[0]}			if(args.length <2){var drawFill = false} else { drawFill= args[1]}			if(args.length <3){var thick = 10} else {thick = args[2] }			if(args.length <4 ){var outlineColor = 0xCCCCCC} else {outlineColor = args[3]}			if(args.length <5){var fillColor = 0xFFFFFF} else {fillColor = args[4]}								var out = outline.simpleDraw(drawOutline,drawFill,thick,outlineColor,fillColor)			return out		}						public function addHole(h:CtdOutline):void{			holes.push(h)		}						public function getCollision(externalXY:Array):Array{			var localXY = outline.localCoords(externalXY)			var closestBit = outline.closest(localXY)			var closestUnits = outline.getUnits(closestBit)			var closestAltitude = closestBit.ptBitAltitude(localXY)			var height = math.VectorMath2D.dotMultiply2D(closestAltitude,[closestUnits[2],closestUnits[3]])			return([height,closestBit])																																															}			}}