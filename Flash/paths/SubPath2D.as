package paths{	import math.VectorMath2D		public class SubPath2D{		public var path:Path2D		public var pIndex:Number		public var num:Number		public var pathX:Array		public var pathY:Array		public var masses:Array				public function getMinMass():Number{			var minMass = -1			for (var i = 0 ; i<pathX.length; i++){				if(minMass == -1 || masses[i] < minMass){					minMass = masses[i]				}			}			return minMass		}				public function SubPath2D(p:Path2D, idx:Number,n:Number):void{			path = p			pIndex = idx			num = n			pathX = new Array()			pathY = new Array()			masses = new Array()						var i0 = pIndex			var i1 = pIndex + 1			if(i1 > path.pathX.length - 1){i1 = 0}			var seg0 = [path.pathX[i0],path.pathY[i0]]			var seg1 = [path.pathX[i1],path.pathY[i1]]			var xInc = (seg1[0] - seg0[0])/ (num + 1)			var yInc = (seg1[1] - seg0[1])/ (num + 1)			for(var i = 1; i <= num; i++){				pathX.push(xInc * i + seg0[0])				pathY.push(yInc * i + seg0[1])				masses.push(0)			}		}				public function closestSegment(ptX,ptY):Number{			var pt = [ptX,ptY]			var minDist = -1			var bestIDX = -1			var i1:Number			var bigS0 = [path.pathX[pIndex],path.pathY[pIndex]]			if(pIndex + 1 > path.pathX.length - 1 ){  i1 = 0 } else{ i1 = pIndex + 1}			var bigS1 =  [path.pathX[i1], path.pathY[i1]]											for(var i = -1 ; i<num ; i++){				if(i == -1){					var seg0 = bigS0					var seg1 = [pathX[i +1], pathY[i +1]]					} else {					if( i== num -1){						 seg0 = [pathX[i],pathY[i]]						 seg1 = bigS1										} else {						 seg0 = [pathX[i],pathY[i]]						 seg1 = [pathX[i +1], pathY[i +1]]					}				}				var dist = VectorMath2D.ptLineDist(pt,seg0,seg1,false)				if(dist[0] < minDist ||minDist ==-1){					minDist = dist[0]					bestIDX = i					var bS0 = seg0					var bS1 = seg1				}			}			return(bestIDX)		}		public function getUnits(segIdx:Number):Array{			var i = segIdx			if(i == -1){				var seg0 = 	[path.pathX[pIndex],path.pathY[pIndex]]				var seg1 =  [pathX[0],pathY[0]]			} else {				if ( i != num -1) {					seg0 = [pathX[i],pathY[i]]					seg1 = [pathX[i+1],pathY[i+1]]				} else {					seg0 = [pathX[i],pathY[i]]					var i1 = pIndex + 1					if( i1 >= path.pathX.length ){ i1 = i1 - path.pathX.length }					seg1 = 	[path.pathX[i1],path.pathY[i1]]									}			}			var vecAlong = [seg1[0] - seg0[0], seg1[1] - seg0[1]]			var magAlong = Math.sqrt(Math.pow(vecAlong[0],2) + Math.pow(vecAlong[1],2))			var unitAlong =[vecAlong[0] / magAlong, vecAlong[1] / magAlong]			var unitPerp = [ - unitAlong[1], unitAlong[0] ]			return( [unitAlong[0],unitAlong[1],unitPerp[0],unitPerp[1]] )		}				public function pushPt(ptX,ptY,mass):void{			var pt = [ptX,ptY]			var i1:Number			var bigS0 = [path.pathX[pIndex],path.pathY[pIndex]]			if(pIndex + 1 > path.pathX.length - 1 ){  i1 = 0 } else{ i1 = pIndex + 1}			var bigS1 =  [path.pathX[i1], path.pathY[i1]]				// For some reason, I cannot move the last point... Oh well.						var intersect = VectorMath2D.ptLineClosest(pt,bigS0,bigS1,false)					var bigDist = Math.sqrt(Math.pow(bigS0[0] - bigS1[0],2) + Math.pow(bigS0[1] - bigS1[1],2))			var iDist = Math.sqrt(Math.pow(intersect[0] - bigS0[0],2) + Math.pow(intersect[1] - bigS0[1],2))			var inc = Math.floor(iDist / bigDist * ( num + 1 ) )						var xInc = (bigS1[0] - bigS0[0])/ (num + 1)			var yInc = (bigS1[1] - bigS0[1])/ (num + 1)			var inc0 = [xInc * inc + bigS0[0], yInc * inc + bigS0[1] ]			var inc1 = [xInc * (inc + 1) + bigS0[0], yInc * (inc + 1) + bigS0[1] ]			var altitude = [ pt[0] - intersect[0] , pt[1] - intersect[1]]			var pt0 =  [inc0[0] + altitude[0],inc0[1] + altitude[1]]			var pt1 =  [inc1[0] + altitude[0],inc1[1] + altitude[1]]						var d0 = Math.sqrt(Math.pow(intersect[0] - inc0[0],2) + Math.pow(intersect[1] - inc0[1],2))			var d1 = Math.sqrt(Math.pow(intersect[0] - inc1[0],2) + Math.pow(intersect[1] - inc1[1],2))			var cof0 = d1/ (d0 + d1)			var cof1 = d0/ (d0 + d1)									var i0 = inc - 1 			 i1 = inc			 			if(inc == 0){				if( (masses[i1] + cof1 * mass) != 0){				pathX[i1] = (masses[i1]* pathX[i1] + cof1 * mass * pt1[0]) / (masses[i1] + cof1 * mass)				pathY[i1] = (masses[i1]* pathY[i1] + cof1 * mass * pt1[1]) / (masses[i1] + cof1 * mass)				masses[i1] += cof1 * mass 				}			} else {				if(inc == num){					if( (masses[i0] + cof0 * mass)  != 0 ){					pathX[i0] = (masses[i0]* pathX[i0] + cof0 * mass * pt0[0]) / (masses[i0] + cof0 * mass)					pathY[i0] = (masses[i0]* pathY[i0] + cof0 * mass * pt0[1]) / (masses[i0] + cof0 * mass)					masses[i0] += cof0 * mass 					}				} else { 					if(inc < num){						if((masses[i1] + cof1 * mass) != 0){						pathX[i1] = (masses[i1]* pathX[i1] + cof1 * mass * pt1[0]) / (masses[i1] + cof1 * mass)						pathY[i1] = (masses[i1]* pathY[i1] + cof1 * mass * pt1[1]) / (masses[i1] + cof1 * mass)						masses[i1] += cof1 * mass 						}						if((masses[i0] + cof0 * mass) != 0){						pathX[i0] = (masses[i0]* pathX[i0] + cof0 * mass * pt0[0]) / (masses[i0] + cof0 * mass)						pathY[i0] = (masses[i0]* pathY[i0] + cof0 * mass * pt0[1]) / (masses[i0] + cof0 * mass)						masses[i0] += cof0 * mass 						}						if(isNaN(pathX[i0] ) || isNaN(pathX[i1])){							trace("NAN")						}					}				}			}		}		}}