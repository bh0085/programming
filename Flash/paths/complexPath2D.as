package paths{	import math.VectorMath2D	import flash.display.Shape		public class complexPath2D extends Path2D{		public var lastSearched = 0		public var addKeypoints = true		public var subpathPtDensity  = 5				public function addKeypoint(ptX,ptY,mass,index):void{						subPaths.splice(index,0, new Path2D())						subPath[index].setMergeDistance(subpathPtDensity)						pathX.splice(index,0,ptX)						pathY.splice(index,0,ptY)						numAvgd.splice(index,0,mass)		}				public function tensionInsert(index:Number,ptX:Number, ptY:Number,mass:Number){			var pl = pathX.length			var insert = true			if((index == 0 || index >= pl)){				if(!isClosed) {					if(addKeypoints){						addKeypoint(ptX,ptY,mass,index)						insert = false					}				} 			}								if(insert){				var i0 = index-1				var i1 = index				if(i0 < 0){i0 = pathX.length -1}								var seg0 = [pathX[i0],pathY[i0]]				var seg1 = [pathX[i1],pathY[i1]]				var pt = [ptX,ptY]				var intersect = VectorMath2D.ptLineClosest(pt,seg0,seg1,false)				var delta = [ptX - intersect[0],ptY - intersect[1]]				var distanceToPrev = Math.sqrt(Math.pow(intersect[0] - seg0[0],2) + Math.pow(intersect[1] - seg0[1],2))				var distanceToNext = Math.sqrt(Math.pow(intersect[0] - seg1[0],2) + Math.pow(intersect[1] - seg1[1],2))				if(addKeypoints){					var attachTo = -1					if(distanceToPrev < mergeDist()){						attachTo = 0					} 					if (distanceToNext < mergeDist() && distanceToNext < distanceToPrev) {						attachTo = 1					}					if(attachTo == -1){						if(addKeypoints){							addKeypoint(ptX,ptY,mass,i1)							tensionMove(i1,delta[0],delta[1],mass) 						} else {													}					}					if(attachTo == 0){						var newX =( pathX[i0] *numAvgd[i0] + mass* ptX)/(numAvgd[i0]+mass )						var newY =( pathY[i0] *numAvgd[i0] + mass* ptY)/(numAvgd[i0]+mass )						var movement = [newX - pathX[i0],newY - pathY[i0]]						tensionMove(i0,movement[0],movement[1],mass)						numAvgd[i0] += mass					}					if(attachTo == 1){						var newX =( pathX[i1] *numAvgd[i1] + mass* ptX)/(numAvgd[i1]+mass )						var newY =( pathY[i1] *numAvgd[i1] + mass* ptY)/(numAvgd[i1]+mass )						var movement = [newX - pathX[i1],newY - pathY[i1]]						tensionMove(i1,movement[0],movement[1],mass)						numAvgd[i1] += mass					}				} else {					var attachTo = -1					if(distanceToPrev = 0){						attachTo = 0					} 					if (distanceToNext = 0) {						attachTo = 1					}					if(attachTo == -1){						if(addKeypoints){							subPaths[i0].addPt(ptX,ptY,mass)						}					}				}							}		}											 					}		}