package paths{	import math.VectorMath2D	import flash.display.Shape		public class Path2D{						public var isClosed = false 		public var closeDistance = 50		public var minCloseLength = 10		public var mDist = 20		public var fixedEnds = false				public var subPaths = new Array()		public var pathX = new Array()		public var pathY = new Array()		public var numAvgd = new Array()				public var orientation = 1		public var netOrientation = 0		public var sureOrientation = false		var orientationThreshold = 20		var subPathPtDensity = 20		var zeroTension = false		var addKeypoints = true				public function setOrientation(number:Number):void{			orientation = number		}		public function pushOrientation(number:Number):void{			if(!sureOrientation){				netOrientation += number				if(Math.abs(netOrientation) > orientationThreshold){sureOrientation = true}				if(netOrientation >= 0){setOrientation(1)} else{ setOrientation(-1) }			}		}		public function firstGuessOutPosOrientation():Array{			var seg0 = [pathX[0],pathY[0]]			var seg1 = [pathX[1],pathY[1]]			var vec = [seg1[0] - seg0[0],seg1[1] - seg0[1]]			var magVec = Math.sqrt(Math.pow(vec[0],2) + Math.pow(vec[1],2))			var unitVec = [vec[0] / magVec, vec[1] / magVec]			var unitOutPosOrientation = [-unitVec[1] , unitVec[0]]			return unitOutPosOrientation		}				public function getUnits(segIdx):Array{			var i0=segIdx, i1=segIdx + 1			if(segIdx == -1){i0 = pathX.length -1}			if(segIdx == pathX.length-1){i1 = 0}			var seg0 = [pathX[i0],pathY[i0]]			var seg1 = [pathX[i1],pathY[i1]]			var vec = [seg1[0] - seg0[0],seg1[1] - seg0[1]]			var magVec = Math.sqrt(Math.pow(vec[0],2) + Math.pow(vec[1],2))			var unitVec = [orientation * vec[0] / magVec,orientation * vec[1] / magVec]			var unitOut = [-unitVec[1] , unitVec[0]]						return([unitVec[0],unitVec[1],unitOut[0],unitOut[1]])		}				public function pushPt(ptX,ptY,...args){			var mass:Number			if(args.length == 0){mass = 1} else {mass = args[0]}						var lp = pathX.length			if(lp > 1){				if(! isClosed) {					var ptOnRay = [pathX[0] + pathX[0] - pathX[1],pathY[0] + pathY[0] - pathY[1]] 					var dist = VectorMath2D.ptRayDist([ptX,ptY],[pathX[0],pathY[0]], ptOnRay )					var minDist = dist[0]					var bestIDX = 0				} else {					seg0 = [pathX[pathX.length - 1], pathY[pathY.length -1]]					seg1 = [pathX[0],pathY[0]]					dist = VectorMath2D.ptLineDist([ptX,ptY],seg0,seg1,false )					minDist = dist[0]					bestIDX = 0				}									for(var i =0 ; i<lp - 1 ; i++){					var seg0 = [pathX[i],pathY[i]]					var seg1 = [pathX[i +1], pathY[i +1]]					var pt = [ptX,ptY]					dist = VectorMath2D.ptLineDist(pt,seg0,seg1,false)					if(dist[0] < minDist){						minDist = dist[0]						bestIDX = i + 1					}				}								if(! isClosed){					dist = VectorMath2D.ptRayDist([ptX,ptY],[pathX[lp-1],pathY[lp-1]], [pathX[lp-1] + pathX[lp-1] - pathX[lp - 2],pathY[lp-1] + pathY[lp -1] - pathY[lp - 2]]  )					if(dist[0] <minDist){						minDist = dist[0]						bestIDX = pathX.length					}				}				if( !fixedEnds || (bestIDX != 0 && bestIDX != pathX.length) ){					insertPt(bestIDX,ptX,ptY,mass)				}			} else{				insertPt(0,ptX,ptY,mass)			}		}		public function pushPts(ptsX,ptsY,... args):void{			if(args.length > 0){var masses = args[0]} else {masses = new Array()}			if(masses.length ==0){				masses = new Array(ptsX.length)				for(j = 0; j<ptsX.length ; j++){					masses[j] = 1				}			}			for(var j = 0; j< ptsX.length; j++){				pushPt(ptsX[j], ptsY[j], masses[j])			}		}		public function pushSubPts(ptsX,ptsY,masses):void{			for(var i = 0; i < ptsX.length ; i++){				pushSubPt(ptsX[i],ptsY[i],masses[i])			}		}		public function pushSubPt(ptX,ptY,mass):void{					var kptOrig = addKeypoints					addKeypoints = false					pushPt(ptX,ptY,mass)					addKeypoints = kptOrig										}				public function insertPt(index:Number, ptX:Number, ptY:Number,mass:Number):void{				tensionInsert(index,ptX,ptY,mass)						openClose()		}		public function insertPtAtEnd( ptX:Number, ptY:Number,mass:Number):void{				var index = pathX.length				tensionInsert(index,ptX,ptY,mass)						openClose()		}		public function splicePtBtwn( ptX:Number, ptY:Number, mass:Number, idxStart:Number, idxFinish:Number):void{				var numRemove = idxFinish - idxStart - 1				subPaths.splice(idxStart+ 1, numRemove, new Path2D())				pathX.splice(idxStart + 1,numRemove)				pathY.splice(idxStart + 1,numRemove)				numAvgd.splice(idxStart + 1, numRemove)								addKeypoint(ptX,ptY,mass,idxStart+1)		}				public function addKeypoint(ptX,ptY,mass,index):void{				subPaths.splice(index,0, new Path2D())				subPaths[index].setMergeDistance(subPathPtDensity)				subPaths[index].zeroTension = true				pathX.splice(index,0,ptX)				pathY.splice(index,0,ptY)				numAvgd.splice(index,0,mass)		}				public function zeroTensionInsert(index:Number,ptX:Number, ptY:Number,mass:Number):{			var pl = pathX.length				var i0 = index-1				var i1 = index				if(i0 < 0){i0 = pathX.length -1}								var seg0 = [pathX[i0],pathY[i0]]				var seg1 = [pathX[i1],pathY[i1]]				var pt = [ptX,ptY]				var intersect = VectorMath2D.ptLineClosest(pt,seg0,seg1,false)				var delta = [ptX - intersect[0],ptY - intersect[1]]				var distanceToPrev = Math.sqrt(Math.pow(intersect[0] - seg0[0],2) + Math.pow(intersect[1] - seg0[1],2))				var distanceToNext = Math.sqrt(Math.pow(intersect[0] - seg1[0],2) + Math.pow(intersect[1] - seg1[1],2))				if(addKeypoints){					var attachTo = -1					if(distanceToPrev < mergeDist()){						attachTo = 0					} 					if (distanceToNext < mergeDist() && distanceToNext < distanceToPrev) {						attachTo = 1					}					if(attachTo == -1){							addKeypoint(ptX,ptY,mass,i1)					}					if(attachTo == 1){						var newX =( pathX[i1] *numAvgd[i1] + mass* ptX)/(numAvgd[i1]+mass )						var newY =( pathY[i1] *numAvgd[i1] + mass* ptY)/(numAvgd[i1]+mass )						var movement = [newX - pathX[i1],newY - pathY[i1]]						tensionMove(i1,movement[0],movement[1],mass)						numAvgd[i1] += mass					}				} else {					var attachTo = -1					if(distanceToPrev = 0){						attachTo = 0					} 					if (distanceToNext = 0) {						attachTo = 1					}					if(attachTo == -1){						if(addKeypoints){							subPaths[i0].addPt(ptX,ptY,mass)						}					}				}									}				public function tensionInsert(index:Number,ptX:Number, ptY:Number,mass:Number){			var pl = pathX.length			var insert = true			if((index == 0 || index >= pl)){				if(!isClosed) {					if(addKeypoints){						addKeypoint(ptX,ptY,mass,index)						insert = false					}				} 			}			if(insert){				var i0 = index-1				var i1 = index				if(i0 < 0){i0 = pathX.length -1}								var seg0 = [pathX[i0],pathY[i0]]				var seg1 = [pathX[i1],pathY[i1]]				var pt = [ptX,ptY]				var intersect = VectorMath2D.ptLineClosest(pt,seg0,seg1,false)				var delta = [ptX - intersect[0],ptY - intersect[1]]				var distanceToPrev = Math.sqrt(Math.pow(intersect[0] - seg0[0],2) + Math.pow(intersect[1] - seg0[1],2))				var distanceToNext = Math.sqrt(Math.pow(intersect[0] - seg1[0],2) + Math.pow(intersect[1] - seg1[1],2))				if(addKeypoints){					var attachTo = -1					trace("M",mergeDist())					if(distanceToPrev < mergeDist()){						attachTo = 0					} 					if (distanceToNext < mergeDist() && distanceToNext < distanceToPrev) {						attachTo = 1					}					if(attachTo == -1){							addKeypoint(ptX,ptY,mass,i1)							tensionMove(i1,delta[0],delta[1],mass) 					}					if(attachTo == 0){						var newX =( pathX[i0] *numAvgd[i0] + mass* ptX)/(numAvgd[i0]+mass )						var newY =( pathY[i0] *numAvgd[i0] + mass* ptY)/(numAvgd[i0]+mass )						var movement = [newX - pathX[i0],newY - pathY[i0]]						tensionMove(i0,movement[0],movement[1],mass)						numAvgd[i0] += mass					}					if(attachTo == 1){						var newX =( pathX[i1] *numAvgd[i1] + mass* ptX)/(numAvgd[i1]+mass )						var newY =( pathY[i1] *numAvgd[i1] + mass* ptY)/(numAvgd[i1]+mass )						var movement = [newX - pathX[i1],newY - pathY[i1]]						tensionMove(i1,movement[0],movement[1],mass)						numAvgd[i1] += mass					}					trace(attachTo)				} else {					var attachTo = -1					if(distanceToPrev = 0){						attachTo = 0					} 					if (distanceToNext = 0) {						attachTo = 1					}					if(attachTo == -1){						if(addKeypoints){							subPaths[i0].addPt(ptX,ptY,mass)						}					}				}			}		}															public function setMergeDistance(num:Number){			mDist = num			setCloseDistance(mDist * 5)		}		public function mergeDist():Number{return mDist}		public function setCloseDistance(num:Number){closeDistance = num}		public function openClose():void{			var pt0 = [pathX[0] , pathY[0]]			var pt1 = [pathX[pathX.length -1], pathY[pathX.length -1]]			var dist = Math.sqrt(Math.pow(pt0[0]- pt1[0],2) + Math.pow(pt0[1] - pt1[1],2))			if(dist<closeDistance){isClosed = true} else { isClosed = false }			if(pathX.length < minCloseLength){isClosed = false}		}				public function calcTensionCof(dist:Number,maxDist:Number,thisDist:Number):Number{			return (.5* (1 - dist/maxDist) + .5) * ((1 - .5*thisDist / maxDist)) 		}		public function tensionMove(index:Number,moveX:Number, moveY:Number,mass:Number){			var pl = pathX.length			var doMove = true			if((index == 0 || index >= pl)){				if(!isClosed){					doMove = false				} 			}			if(doMove){				var neighbors = 10				var maxDist = mergeDist() * neighbors												var origX = pathX[index]				var origY = pathY[index]								var delta = [moveX,moveY]				pathX[index] += moveX				pathY[index] += moveY								var dist:Number,massFrac:Number				var searchLow = true, searchHigh = true				var lowLast = delta, highLast = delta				var origLowLast = [origX,origY]				var origHighLast = [origX,origY]				var lowMassLast = numAvgd[index], highMassLast = numAvgd[index]				for(var i = 0 ; i< neighbors; i++){					if(searchLow){						var idx = index - 1 - i						if(idx < 0){ if(isClosed) {idx = pathX.length + idx } else {searchLow = false} }						if(searchLow){							dist = Math.sqrt(Math.pow(pathX[idx] - origX,2) + Math.pow(pathY[idx] - origY,2))							if(dist < maxDist){								massFrac = Math.min(lowMassLast/numAvgd[idx],1)								lowMassLast = numAvgd[idx]																var dOldToLast = [pathX[idx] - origLowLast[0],pathY[idx] - origLowLast[1]]								var distToLast = Math.sqrt(Math.pow(dOldToLast[0],2) + Math.pow(dOldToLast[1],2))								var origLowLast = [pathX[idx],pathY[idx]]								var cof = calcTensionCof(dist,maxDist,distToLast)																lowLast = [massFrac* lowLast[0]*cof,massFrac*lowLast[1]*cof]								pathX[idx] += lowLast[0]								pathY[idx] += lowLast[1]								numAvgd[idx] += mass * dist / maxDist							} else {searchLow = false}						}					}					if(searchHigh){						var idx = index + 1 + i						if(idx > pathX.length - 1){ if(isClosed) {idx =idx - pathX.length } else {searchHigh = false} }						if(searchHigh){							dist = Math.sqrt(Math.pow(pathX[idx] - origX,2) + Math.pow(pathY[idx] - origY,2))							if(dist < maxDist){								massFrac = Math.min(highMassLast/numAvgd[idx],1)								highMassLast = numAvgd[idx]																 dOldToLast = [pathX[idx] - origHighLast[0],pathY[idx] - origHighLast[1]]								 distToLast = Math.sqrt(Math.pow(dOldToLast[0],2) + Math.pow(dOldToLast[1],2))								 var origHighLast = [pathX[idx],pathY[idx]]								 cof = calcTensionCof(dist,maxDist,distToLast)																highLast = [highLast[0]*massFrac*cof,massFrac*highLast[1]*cof]								pathX[idx] += highLast[0]								pathY[idx] += highLast[1]								numAvgd[idx] += mass * dist / maxDist							} else {searchHigh = false}						}					}				}			}		}				public static function merge(path1:Path2D,path2:Path2D):Path2D{			var newPath = path1.copyPath()			newPath.pushOrientation(path1.netOrientation)			newPath.pushPts(path2.pathX,path2.pathY,path2.numAvgd)			var dumped = path1.dumpPoints()			newPath.pushSubPts(dumped[0],dumped[1],dumped[2])			dumped = path2.dumpPoints()			newPath.pushSubPts(dumped[0],dumped[1],dumped[2])			return newPath		}		public  function pushPath(path:Path2D){			pushPts(path.pathX,path.pathY,path.numAvgd)		}				public function centerOfMass():Array{			var mass = 0			var xNet = 0			var yNet = 0			for( var i = 0 ; i < pathX.length ; i ++){				mass += numAvgd[i]				xNet += pathX[i] * numAvgd[i]				yNet += pathY[i] * numAvgd[i]			}			return ([xNet / mass, yNet/ mass, mass])		}				public function copyPath():Path2D{			var out = new Path2D()			for (var i = 0 ; i < pathX.length ; i++){				out.insertPtAtEnd(pathX[i],pathY[i],numAvgd[i])			}			return out		}				public function prune(minDistance:Number):void{			var lastGoodXY:Array,thisXY:Array			var spliceStart:Number, spliceFinish:Number			var splicedPath:Path2D			var isBad = false, hitBad = false, hitGood = false									lastGoodXY = [pathX[0] , pathY[0]]			for (var i = 1; i < pathX.length ; i++){				thisXY = [pathX[i],pathY[i]]				var magDiff = Math.sqrt(Math.pow(thisXY[0] - lastGoodXY[0],2) + Math.pow(thisXY[1] - lastGoodXY[1],2))								if(isBad){					if(magDiff < minDistance*2 && i != pathX.length - 1){						splicedPath.insertPtAtEnd(pathX[i],pathY[i],numAvgd[i])					} else {						var hitGood = true					}				}								if(!isBad){					if(magDiff < minDistance){						var hitBad = true					} else {						lastGoodXY = thisXY					}				} 								if(hitBad){					hitBad = false					isBad = true					spliceStart = i - 1					splicedPath = new Path2D()					splicedPath.insertPtAtEnd(pathX[i],pathY[i],numAvgd[i])									}				if(hitGood){										for( var i =spliceStart ; i < spliceFinish ; i++){						var dumped = subPaths[i].dumpPoints()						splicedPath.pushSubPts(dumped[0],dumped[1],dumped[2])					}										spliceFinish = i					isBad = false					hitGood = false					lastGoodXY = thisXY					var com = splicedPath.centerOfMass()					var comPt = [com[0],com[1]]					var massPt = com[2]					splicePtBtwn(comPt[0],comPt[1],massPt,spliceStart,spliceFinish)					subPaths[spliceStart] = new Path2D()					var dumped = splicedPath.dumpPoints()					//pushSubPts(dumped[0],dumped[1],dumped[2])										var numRemoved = spliceFinish - spliceStart - 1					i = i - numRemoved + 1									}			}		}			public function dumpPoints():Array{			var ptsX = new Array()			var ptsY = new Array()			var masses = new Array()			for(var i = 0 ; i<pathX.length ; i++){				ptsX.push(pathX[i])				ptsY.push(pathY[i])				masses.push(numAvgd[i])				for(var j = 0; j< subPaths[i].pathX.length ; j ++){					ptsX.push(subPaths[i].pathX[j])					ptsY.push(subPaths[i].pathY[j])					masses.push(subPaths[i].numAvgd[j])				}			}			return([ptsX,ptsY,masses])		}			public function getClosestPointOnSegment(pt:Array,index:Number):Array{				var i0 = index				var i1 = index + 1				if(index == -1){i0 = pathX.length -1}				if(index == pathX.length - 1){i1 = 0} 				var seg0 = [pathX[i0],pathY[i0]]				var seg1 = [pathX[i1],pathY[i1]]				var intersect = VectorMath2D.ptLineClosest(pt,seg0,seg1,false)						return intersect		}		public function closestSegmentToPoint(pt:Array):Array{				var bestDist = -1				var bestSegIDX = -1				if(isClosed){var kStart = -1} else { kStart = 0}				for(var k = kStart; k< pathX.length - 1 ; k ++){					if(k != -1){						var xy1 = [pathX[k],pathY[k]]					} else {						var xy1 = [pathX[pathX.length -1], pathY[pathX.length-1]]					}					var xy2 = [pathX[k +1],pathY[k + 1]]					var xy3 = [pt[0],pt[1]]					var dist = VectorMath2D.ptLineDist(pt,xy1,xy2,false)[0]					//if(k == -1){trace(1,xy1,2,xy2,3,xy3)}					var dist1 = Math.sqrt(Math.pow(xy1[0] - xy3[0], 2) + Math.pow(xy1[1] - xy3[1],2))					var dist2 = Math.sqrt(Math.pow(xy2[0] - xy3[0], 2) + Math.pow(xy2[1] - xy3[1],2))					//var dist = dist1+dist2					//if(k ==-1 ){trace("Tracing",dist)}					if( (bestDist== -1) || dist < bestDist){						bestDist = dist						bestSegIDX = k					}						}				//trace(bestDist,bestSegIDX)				return([bestDist,bestSegIDX])					}						public function toShape():Shape{			var shape = new Shape()/*			shape.graphics.lineStyle(1)					shape.graphics.moveTo(pathX[0],pathY[0])			for (var i = 0 ; i < pathX.length ; i++){				shape.graphics.lineStyle(1,50 * numAvgd[i] + 256 * 50 * numAvgd[i])				shape.graphics.lineTo(pathX[i],pathY[i])			}*/			shape.graphics.lineStyle(0,0x000000)			for( var i = 0 ; i<pathX.length ; i ++){				shape.graphics.drawCircle(pathX[i],pathY[i],5)			}			if(isClosed){				shape.graphics.lineStyle(0,0xFFFF00)				shape.graphics.drawCircle(pathX[0],pathY[0],20)				shape.graphics.drawCircle(pathX[pathX.length -1],pathY[pathX.length -1],8)			}			return shape 		}		public function averageMass(segIdx,numEitherSide){			var mass = 0			var num = 0			for(var i = 0; i < numEitherSide; i++){				var idxPlus = segIdx + 1 + i				var idxMinus = segIdx - i				if(isClosed){					if(idxPlus >= pathX.length){idxPlus = idxPlus - pathX.length}					if(idxMinus < 0){idxMinus = pathX.length + idxMinus}				}				if(idxPlus < pathX.length){					mass += numAvgd[idxPlus]					num += 1				}				if (idxMinus >= 0){					mass += numAvgd[idxMinus]					num += 1				}			}			if(num ==0) {return 0}			return mass / num							}		public function minMass(segIdx,numEitherSide){			var minMass = -1			var num = 0			for(var i = 0; i < numEitherSide; i++){				var idxPlus = segIdx + 1 + i				var idxMinus = segIdx - i				if(isClosed){					if(idxPlus >= pathX.length){idxPlus = idxPlus - pathX.length}					if(idxMinus < 0){idxMinus = pathX.length + idxMinus}				}				if(idxPlus < pathX.length){					num += 1					var thisMass = numAvgd[idxPlus]					if(thisMass < minMass || minMass == -1){						minMass = thisMass					}				} else {					trace("idxPlus > length")					return 0				}								if (idxMinus >= 0){					num += 1					var thisMass = numAvgd[idxMinus]					if(thisMass < minMass || minMass == -1){						minMass = thisMass					}				} else {					trace("idxMinus < 0")					return 0				}			}		//trace(num)		if(minMass == -1) {return 0}		return minMass		}		}}