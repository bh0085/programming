package paths{	import math.VectorMath2D	import physics.objects.PhysObject	import flash.display.Sprite	import flash.display.Shape	import flash.display.BitmapData	import flash.geom.Matrix	import flash.geom.ColorTransform	import flash.geom.Rectangle	import physics.PhysUniverse	import flash.geom.Point	import flash.utils.getTimer		public class CtdOutline {		public var segments:Array		public var fill:Shape		public var first:Node		public var object:PhysObject		public var numNodes = 0		var fillUpdated = false		var alteredNodes = new Array()		var autoUpdateIndividualSegments = false		var autoUpdateAfterGeneration = true		public var ort = 1		var carefulSearch = false		var circBounds:Array		public var bounds:Rectangle		public var bigNodes = new Array()				public function getCircBoundsExt():Array{			var eXY = externalCoords([circBounds[0],circBounds[1]])			return [eXY[0],eXY[1],circBounds[2]]		}		public function getBoundsExt():Rectangle{			return rectInExternalCoords(bounds)		}		public function pushBigNode(bigStart:Node,bigFinish:Node,includesFirst:Boolean):void{			var big = new BigNode(bigStart,bigFinish)			bigNodes.push(big)			big.includesFirst = includesFirst			bigStart.nextBig = big		}		public function clearBigNodes():void{			for(var i = 0; i < bigNodes.length; i++){				deleteBigNode(bigNodes[i])				bigNodes.splice(i,1)				i--			}					}		public function deleteBigNode(big:BigNode):void{			big.firstNode.nextBig = null		}		public function generateBigNodes(rect:Rectangle):void{			var localRect = rectInLocalCoords(rect)			var node = first						if(localRect.containsPoint(new Point(node.x,node.y))){				var isInside = true			} else {				isInside = false			}			var search = true			while (search) {				if(isInside){node = node.next} else{node = node.prev}				var wasInside = isInside				if(localRect.containsPoint(new Point(node.x,node.y))){					isInside = true				} else {					isInside = false				}				if(isInside != wasInside){					if(wasInside == true){						var firstOutside = node						search = false					} else {						var firstOutside = node.next						search = false					}				}				if(node == first){search = false}			}						if(firstOutside ==null){return}						var search = true			node = firstOutside.prev			var isInside = true						var movedInOut = false			var movedOutIn = false			var skipMoveIn = false			var skipMoveOut = false						var lastSwitched = false			while(search){				var wasInside = isInside				node = node.next				if(localRect.containsPoint(new Point(node.x,node.y))){					isInside = true				} else {					isInside = false				}												if(!isInside && !wasInside){					if(node == first){						var includesFirst = true					}				} 								if((!isInside) && wasInside){					var bigStart = node				}				if( isInside && (!wasInside)){					var bigFinish = node.prev					if(node.prev == first){includesFirst = false}					pushBigNode(bigStart,bigFinish,includesFirst)					includesFirst = false				}								skipMoveIn = false				skipMoveOut = false								if(node == firstOutside.prev){search = false}			}											}		public function rectInLocalCoords(rect:Rectangle):Rectangle{			var centerX = (rect.left + rect.right)/2			var centerY = (rect.top + rect.bottom)/2			var localCenter = localCoords([centerX,centerY])			var newH = Math.sqrt(Math.pow(rect.height,2) + Math.pow(rect.width,2))			var newW = newH			var localRect = new Rectangle(localCenter[0] - newW/2, localCenter[1] - newH/2,newW,newH )			return localRect		}		public function rectInExternalCoords(rect:Rectangle):Rectangle{			var centerX = (rect.left + rect.right)/2			var centerY = (rect.top + rect.bottom)/2			var externalCenter = externalCoords([centerX,centerY])			var newH = Math.sqrt(Math.pow(rect.height,2) + Math.pow(rect.width,2))			var newW = newH			var externalRect = new Rectangle(externalCenter[0] - newW/2, externalCenter[1] - newH/2,newW,newH )			return externalRect		}		public function spliceBetween(spliceStart:Node,spliceFinish:Node,...args){			if(args.length >0){var newFirst = args[0]}			if(args.length >1){var newLast = args[1]}			deleteBetween(spliceStart,spliceFinish)			var search = true			var node = newLast			while(search){				if(node == newFirst){search = false}				pushNode(node,spliceStart)				node = node.prev			}					}		public function spliceAt(spliceStart:Node,newFirst:Node,newLast:Node,...args){			if(args.length <1){var oldOutline = null} else {oldOutline = args[0]}			if(args.length <2){var reverse = false} else {reverse = args[1]}			var prev = spliceStart			var node = newFirst						var addNodes = true			while(addNodes){				if(node == newLast){addNodes = false}				if(oldOutline!= null){					var addXY = oldOutline.nodeExternalCoords(node)				} else {addXY =[node.x,node.y]}				var localXY = localCoords(addXY)				var newNode = new Node(localXY[0],localXY[1])				pushNode(newNode,prev)				prev = newNode				if(!reverse){node = node.next} else {node = node.prev}			}		}		public function spliceOneAt(spliceStart:Node,addNode:Node,...args){			if(args.length == 0){var oldOutline = null} else {oldOutline = args[0]}			var prev = spliceStart			var node = addNode			if(oldOutline!= null){				var addXY = oldOutline.nodeExternalCoords(node)			} else {addXY =[node.x,node.y]}			var localXY = localCoords(addXY)			var newNode = new Node(localXY[0],localXY[1])			pushNode(newNode,prev)					}		public function deleteBetween(deleteStart:Node,deleteFinish:Node){			var deleteNodes = true			while(deleteNodes){				var node = deleteStart.next				if(node != deleteFinish){					removeNode(node)				} else {					deleteNodes = false				}			}		}				//Bookeeping Methods				public function setObject(po:PhysObject):void{			object = po		}		public function angleCutoff(lvls:Number):Number{			if(lvls>1){				if(numNodes >10){return Math.PI/2} else {return Math.PI/1.5}			}			if(lvls==1){				if(numNodes > 10) {return Math.PI/6} else{ return Math.PI/2 }			} else {return 0}		}		public function segsUpdated():Boolean{			if(alteredNodes.length == 0){return true} else {return false}		}		public function nodeChanged(node):void{			fillUpdated = false			alteredNodes.push(node)			if(autoUpdateIndividualSegments){				while(alteredNodes.length > 0){					var update = alteredNodes.splice(0,1)[0]					var add = update.address					Segment.compute3Pts(segments,add)				}			}		}		public function nodesInOrder():Array{			if(first == null){return null}			var nIO = new Array()			var search = true			var node = first			while(search){				nIO.push(node)				node = node.next				if(node == first){search = false}			}			return nIO		}		public function genFill(...args):void{			if(args.length ==0){var color = 0xFFFFFF} else{ color = args[0]}			fill = new Shape()			fill.graphics.beginFill(color)			fill.graphics.moveTo(first.x,first.y)			var node = first			var search = true			while(search){				node = node.next				fill.graphics.lineTo(node.x,node.y)				if(node == first){					search = false				}			}			fillUpdated = true		}		public function genSegments(...args ):void{			if(args.length >0){var segLevels = args[0]} else{				if(numNodes <= 10){					segLevels = 1				} else {					if(numNodes <40){						segLevels = 2					} else {segLevels = 3}				}			}						if(args.length >1){var finalRes = args[1]} else{finalRes = 4}			var node = first			for(var i = 0; i < numNodes ; i++){ 								node.firstOf = new Array()				node.lastOf = new Array()				node = node.next			}			first.firstOf.push(this)						var pow = 1/(segLevels)			var sNum = (numNodes / finalRes)			var subdivision = (Math.pow(sNum, pow))			var segs = new Array()			var nPer = Math.ceil(numNodes / subdivision)						var segStart = first			var spawnSegments = true			var segSoFar = 0			var hitLast = false			while (spawnSegments){				var nextFirst = segStart				var uStart = getUnits(nextFirst)				 node = segStart				segStart = null				var search = true				var tally = 1				var xNet = node.x				var yNet = node.y								while(search) {					node.address = new Array()					node.address.push(segSoFar)					node = node.next					var units= getUnits(node) 					var delta = VectorMath2D.angle1To2([uStart[0],uStart[1]],[units[0],units[1]])																var dAbs = Math.abs(delta)	   					if(tally == Math.ceil(nPer + 1) || dAbs > angleCutoff(segLevels)) {						var nextLast = node						search = false						segStart = node					}					if(node == first){												nextLast = node						search = false						spawnSegments = false					}					if(!hitLast){						xNet += node.x						yNet += node.y						tally++					}				}				var seg = new Segment(nextFirst,nextLast,xNet/tally,yNet/tally,tally)				seg.segIdx = segSoFar				segSoFar++				segs.push(seg)			}			segments = segs				if(segLevels >1){				for( i = 0; i < segments.length ; i++){					segments[i].genSubSegments(segLevels -1 , finalRes)				}			}			alteredNodes = new Array()			genOrientation()			if(autoUpdateAfterGeneration){autoUpdateIndividualSegments = true}		}		public function setFirst(node:Node){			first = node			node.firstOf.push(this)		}		public function genOrientation(...args){			if(args.length >0){var color = args[0]} else{color = 0x000000}			var units = getUnits(first.next.next.next.next)			var unitOut = [units[2],units[3]]			var mid = getBitMidpoint(first.next.next.next.next)			var localTestOutside = [mid[0] + unitOut[0] * 5, mid[1] + unitOut[1] * 5]			var externalTestOutside = externalCoords(localTestOutside)			var isInside = ptIsInside(externalTestOutside)			if(isInside){ort *= -1}			if(object!= null){				//object.clearExtraGFX()				var uOut = new Sprite()				uOut.graphics.lineStyle(5, color)				uOut.graphics.drawCircle(mid[0],mid[1],25)				uOut.graphics.moveTo(mid[0],mid[1])				uOut.graphics.lineTo(mid[0] + unitOut[0] * 50, mid[1] + unitOut[1] * 50)				//object.extraGFX.addChild(uOut)			}		}		public function getBitMidpoint(node:Node):Array{			return ([ (node.x + node.next.x) / 2, (node.y + node.next.y) / 2])		}				function getUnits(node:Node, ...args):Array{			if(args.length >0){var searchYesNo = args[0]} else { searchYesNo = false }			if(searchYesNo){				var search = true				var nextNode = node.next				var prevNode = node.prev				if(object != null){					var maxDist = object.unitSpread					var nd = 0, pd = 0					while(search){						var nn = nextNode.next						var pn = prevNode.prev						 nd   += Math.sqrt(Math.pow(nn.x - nextNode.x,2) + Math.pow(nn.y - nextNode.y, 2))						 pd   += Math.sqrt(Math.pow(pn.x - prevNode.x,2) + Math.pow(pn.y - prevNode.y, 2))						if(nd < maxDist){							nextNode = nextNode.next						}						if(pd < maxDist){							prevNode = prevNode.prev						}						if(pd>maxDist && nd > maxDist){search = false}					}				}														var seg = [ort* (nextNode.x - prevNode.x), ort *(nextNode.y - prevNode.y)]			} else {				seg = [ort * (node.next.x - node.x), ort * (node.next.y - node.y)]			}			var mag = Math.sqrt(Math.pow(seg[0],2) + Math.pow(seg[1],2))			var unitAlong = [seg[0] / mag, seg[1] / mag]			var unitPerp = [-unitAlong[1],unitAlong[0]]			var units = [unitAlong[0],unitAlong[1], unitPerp[0],unitPerp[1]]						return units		}		public function getUnitsExt(node:Node, ...args):Array{			if(args.length >0){var searchYesNo = args[0]} else { searchYesNo = false }			var units = getUnits(node,searchYesNo)			var uAlong = VectorMath2D.rotate([units[0],units[1]],radOffset())			var uPerp = VectorMath2D.rotate([units[2],units[3]],radOffset())			return [uAlong[0],uAlong[1],uPerp[0],uPerp[1]]		}		public function smartGetUnitsExt(node:Node, ptExt:Array,lockDistance:Number):Array{			var ptRnd = [Math.round(ptExt[0]),Math.round(ptExt[1])]			var nExt = nodeExternalCoords(node)			var nRnd = [Math.round(nExt[0]),Math.round(nExt[1])]			var n2Ext = nodeExternalCoords(node.next)			var n2Rnd = [Math.round(n2Ext[0]),Math.round(n2Ext[1])]			var u0 = getUnitsExt(node.prev)			var u1 = getUnitsExt(node)			var u2 = getUnitsExt(node.next)			if(VectorMath2D.distance(ptRnd,nExt)<lockDistance){				var a01 = VectorMath2D.angle1To2(u0,u1)				return(VectorMath2D.rotate([u0[0],u0[1]],a01/2).concat(VectorMath2D.rotate([u0[2],u0[3]],a01/2)))			} else { 			if(VectorMath2D.distance(ptRnd,n2Ext)<lockDistance){				var a12 = VectorMath2D.angle1To2(u1,u2)				return(VectorMath2D.rotate([u1[0],u1[1]],a12/2).concat(VectorMath2D.rotate([u1[2],u1[3]],a12/2)))			} else {				return u1			}}		}		public function findKinks(kinkAngle:Number):Array{			var lastTangent:Array			var thisTangent:Array			var node = first			var lastUnit = getUnits(node)			lastTangent = [lastUnit[0],lastUnit[1]]			var kinks = new Array()			var stopNext = false			var search = true			while(search){				if(stopNext){search = false}				var thisUnit = getUnits(node)				thisTangent = [thisUnit[0],thisUnit[1]]				var dot = math.VectorMath2D.dotMultiply2D(thisTangent,lastTangent)				var angle = Math.acos(dot)				if(angle > kinkAngle){					node.isKink = true					kinks.push(node)				} else {node.isKink = false}				lastTangent = thisTangent				node = node.next				if(node == first){stopNext = true}							}			return kinks		}		public function deleteKinks(kinkAngle:Number):void{			var kinks = findKinks(kinkAngle)			for(var i = 0; i<kinks.length ; i++){				removeNode(kinks[i])			}		}		public function mergeNeighbors(mergeRadius):void{			var search = true			var node = first			while(search){				var nn = node.next				var dn = Math.sqrt(Math.pow(nn.x - node.x, 2) + Math.pow(nn.y - node.y,2))				if(dn < mergeRadius){					var s2 = true					var temp = new CtdOutline()					var n0 = node					var n0prev = n0.prev					removeNode(node)					temp.pushNode(node)					node = nn					while(s2){						nn = node.next						removeNode(node)						temp.pushNode(node)						if(Math.sqrt(Math.pow(nn.x - n0.x,2) + Math.pow(nn.y - n0.y,2)) > mergeRadius){							s2 = false						}						node = nn						if(node == first){search = false ; s2 = false}					}					var newCOM = temp.getCOM()					var newNode = new Node(newCOM[0],newCOM[1])					pushNode(newNode,n0prev)				} else {					node = nn				}				if(node ==first){search = false}							}		}		//Methods to compare the outline to other points						function xOffset():Number{			if(object != null){return object.getX()} else{return 0}		}		function yOffset():Number{			if(object != null){return object.getY()} else{return 0}		}		public function radOffset():Number{			if(object != null){return object.angle} else{return 0}		}		public function objCMat():Matrix{return object.transform.concatenatedMatrix}		public function externalCoords(localXY:Array){			var out:Array			if(object != null){				var angle = radOffset()				var externalX = localXY[0] * Math.cos(angle) +  - localXY[1] * Math.sin(angle) + object.getX()				var externalY = localXY[0] * Math.sin(angle) +    localXY[1] * Math.cos(angle) + object.getY()				out = [externalX,externalY]} else {out = localXY}			return out					}		public function nodeExternalCoords(node:Node){			return(externalCoords([node.x, node.y]))		}		public function localCoords(objXY:Array):Array{			var out:Array			if(object != null){				var angle = radOffset()				var localX = ( objXY[0] - object.getX()) * Math.cos(angle) +   ( objXY[1] - object.getY()) * Math.sin(angle) 				var localY =-( objXY[0] - object.getX()) * Math.sin(angle) +   ( objXY[1] - object.getY()) * Math.cos(angle)				out = [localX,localY]} else {out = objXY}			return out		}		public function closest(ptXY:Array):Node{			//if(args.length > 0){findSeg = args[0]} else {findSeg = true}			var findSeg = true			var type = 2			var nums = new Array()			if(!carefulSearch){						if(segments == null){genSegments()}				var localXY = localCoords(ptXY)				var search = true				var loops = 0				var bottom = new Array()				while(search){					if(loops == 0){						var s = segments					} else {						s = new Array()						var test = [0,1,2]						for(i = 0 ; i < qualified[0].length ; i++){													if(qualified[0][i].subSegments!=null){								var c = qualified[0][i].subSegments								s = s.concat(c)															} else {															bottom.push(qualified[0][i])							}						}					}					if(s.length != 0){						var sMaxMin = -1						var qualified = [new Array(), new Array()]						for(var i = 0 ; i < s.length ; i++){							var out = VectorMath2D.ptRectMinMaxDist(localXY,s[i].bounds,true)							if(sMaxMin == -1 || out[1] < sMaxMin){								sMaxMin = out[1]							}							if(out[0] <= sMaxMin){								qualified[0].push(s[i])								qualified[1].push(out[0])							}						}						nums.push(qualified[0].length)						for(i = 0 ; i < qualified[0].length ; i++){							if(qualified[1][i] > sMaxMin){								qualified[0].splice(i,1)								qualified[1].splice(i,1)								i--							}						}						nums.push(qualified[0].length)					} else {						var minDist = -1						var bestNode:Node						for( i = 0 ; i < bottom.length ; i++){							var nodeDist = bottom[i].closestNode(localXY,findSeg)							if(nodeDist[1] < minDist || minDist == -1){								bestNode = nodeDist[0]								minDist = nodeDist[1]							}						}						search = false					}					loops ++				}								return bestNode			} else {				var searchNodes = true				localXY = localCoords(ptXY)				 minDist = -1				var minNode = null				var node = first				while(searchNodes){					var dist = node.ptBitDistance(localXY)					if(minNode == null || dist<minDist){						minNode = node						minDist = dist					}					node = node.next					if(node ==first){searchNodes = false}				}				out = minNode			} // In case creful search is turn on			return out		}					public static function findIntersections(o1:CtdOutline,o2:CtdOutline):Array{			var s1 = o1.segments			var s2 = o2.segments			var qpairs = new Array()			for(var i = 0 ; i < s1.length ; i++){				for(var j = 0 ; j< s2.length ; j++){					var c1 = s1[i].getCircBoundsExt()					var c2 = s2[j].getCircBoundsExt()					var vec = [c1[0] - c2[0], c1[1] - c2[1]]					var abs = Math.sqrt(Math.pow(vec[0],2) + Math.pow(vec[1],2))					if(abs <= c1[2] + c2[2]){						qpairs.push([s1[i],s2[j]])					}				}			}			var finalPairs = new Array			while(qpairs.length > 0){				var sub1 = qpairs[0][0].subSegments				var sub2 = qpairs[0][1].subSegments								if(sub1 == null && sub2 != null){					s1 = qpairs[0][0]					for(var i = 0 ; i < sub2.length ; i++){						var s2 = sub2[i]						var c1 = s1.getCircBoundsExt()						var c2 = s2.getCircBoundsExt()						var vec = [c1[0] - c2[0], c1[1] - c2[1]]						var abs = Math.sqrt(Math.pow(vec[0],2) + Math.pow(vec[1],2))						if(abs <= c1[2] + c2[2]){							qpairs.push([s1,s2])						}											}				}				if(sub2 == null && sub1 != null){					s2 = qpairs[0][1]					for(var i = 0 ; i < sub1.length ; i++){						var s1 = sub1[i]						var c1 = s1.getCircBoundsExt()						var c2 = s2.getCircBoundsExt()						var vec = [c1[0] - c2[0], c1[1] - c2[1]]						var abs = Math.sqrt(Math.pow(vec[0],2) + Math.pow(vec[1],2))						if(abs <= c1[2] + c2[2]){							qpairs.push([s1,s2])						}											}				}				if(sub1 != null && sub2 != null){					for(var j = 0 ; j < sub1.length ; j++){						for(var i = 0 ; i < sub2.length ; i++){							var s1 = sub1[j]							var s2 = sub2[i]							var c1 = s1.getCircBoundsExt()							var c2 = s2.getCircBoundsExt()							var vec = [c1[0] - c2[0], c1[1] - c2[1]]							var abs = Math.sqrt(Math.pow(vec[0],2) + Math.pow(vec[1],2))							if(abs <= c1[2] + c2[2]){								qpairs.push([s1,s2])							}												}					}				}				if(sub1 == null && sub2 == null){					var n1 = qpairs[0][0].nodesInOrder()					var n2 = qpairs[0][1].nodesInOrder()					for(var i = 0 ; i < n1.length ; i++){						for(var j = 0 ; j < n2.length ; j++){							var segs1 = [n1[i].getXY(),n1[i].next.getXY()]							var segs2 = [n2[j].getXY(),n2[j].next.getXY()]							if(VectorMath2D.segSegDoesIntersect(segs1,segs2)){								var u1 = n1[i].getUnitsExt(false)								var u2 = n2[j].getUnitsExt(false)																var intersectPoint = VectorMath2D.lineLineIntersect(segs1,segs2)								var nextProdOut1 = n1[i].thisCtdOutline.ort * VectorMath2D.dotMultiply2D([u1[0],u1[1]],[u2[2],u2[3]])								var nextProdOut2 = n2[j].thisCtdOutline.ort * VectorMath2D.dotMultiply2D([u2[0],u2[1]],[u1[2],u1[3]])								finalPairs.push([[n1[i],n2[j]],intersectPoint,[nextProdOut1,nextProdOut2]])															}						}					}				}				qpairs.splice(0,1)			}			return finalPairs						}		public static function eraIntUni(o1:CtdOutline, o2:CtdOutline, eraIntUni:Number,...out):Array{			if(out.length != 0){var extra = out[0]}			var outlines = [o1,o2]			var intersection = 	 CtdOutline.findIntersections(o1,o2)			var pts = new Array()			var prodsOut = new Array()			var nodes = new Array()			for(var i = 0 ; i < intersection.length ; i++){				pts.push(intersection[i][1])				nodes.push(intersection[i][0])				prodsOut.push(intersection[i][2])			}						if(eraIntUni == 0){var searchIn = [-1,1]} 			else {				if(eraIntUni == 1){searchIn = [1,1]}				else {searchIn = [-1,-1]}			}						var n12 = [ outlines[0].nodesInOrder(), outlines[1].nodesInOrder()]			var indicesOf = [new Array(), new Array()]			var sort = new Array()			for(var i = 0 ; i < 2 ; i++){				for (var j = 0 ; j < nodes.length; j++){					indicesOf[i].push(n12[i].indexOf(nodes[j][i]))				}				sort[i] = indicesOf[i].sort(8)			}			//positions of the elements of sort denote the relative positions of nodes in either outline									var intTally = new Array()			for(var i = 0 ; i < nodes.length ; i++){intTally[i] = 0}			var allArcs = new Array()			var makePaths = true			var colorCodes = new Array()			colorCodes[0] = 0			while(makePaths){				var currOutline = 1				var currInt = intTally.indexOf(0)				if(currInt == -1){ break }				var arcs = new Array()				var makeArcs = true				//arcs contains three entries: [starting node, last node[,[startingInt,finishingInt], direction				while(makeArcs){					if(searchIn[currOutline] * prodsOut[currInt][currOutline] < 0){var searchFwd =true} else {searchFwd = false}						var startNode = nodes[currInt][currOutline]					var idxPos = sort[currOutline].indexOf(currInt)											if(searchFwd){ var nextPos = idxPos + 1 } else {nextPos = idxPos -1}					if(nextPos == sort[currOutline].length){nextPos = 0}					if(nextPos == -1){nextPos = sort[currOutline].length - 1}										var nextInt = sort[currOutline][nextPos]					var finishNode = nodes[nextInt][currOutline]										arcs.push([[startNode,finishNode],[currInt,nextInt],searchFwd,currOutline])					intTally[currInt] += 1					intTally[nextInt] += 1					currOutline = 1 - currOutline					currInt = nextInt					if(intTally[currInt] > 1){makeArcs = false}				}				allArcs.push(arcs)			}						var junctions = new Array()			var outs = new Array()			var pathData = new Array()						for(var j = 0 ; j < allArcs.length ; j ++){				var newPath = new CtdOutline()				pathData[j] = new Array()				junctions[j] = new Array()				arcs = allArcs[j]				for(var i = 0 ; i < arcs.length ; i ++){					var searchForward = arcs[i][2]										var tempInt = arcs[i][1][0]					var intXY = pts[tempInt]					if(newPath.numNodes != 0){						newPath.spliceOneAt(newPath.first.prev,new Node(intXY[0],intXY[1]))						junctions[j].push(newPath.first.prev)					} else {						newPath.pushNode(new Node(intXY[0],intXY[1]))						junctions[j].push(newPath.first)					}										if(searchForward){startNode = arcs[i][0][0].next} else {startNode = arcs[i][0][0]}					if(searchForward){finishNode= arcs[i][0][1]} else {finishNode= arcs[i][0][1].next}					if(newPath.first != null){var nodeAt = newPath.first.prev}					var n0 = newPath.numNodes					if(arcs[i][0][0] != arcs[i][0][1]){						newPath.spliceAt(nodeAt,startNode,finishNode,startNode.thisCtdOutline,!searchForward)					}					pathData[j].push([startNode.thisCtdOutline,i])					if(!searchForward){colorCodes[0]  = 0x00FF00}				}								outs.push(newPath)			}				var idxs = outs.sortOn("numNodes",2|8)			var newOuts = new Array()			var newPathData = new Array()			var newJunctions = new Array()			var newAllArcs = new Array()			for(var i = 0 ; i < outs.length ; i++){				newOuts[i] = outs[idxs[i]]				newPathData[i] = pathData[idxs[i]]				newJunctions[i] = junctions[idxs[i]]				newAllArcs[i] = allArcs[idxs[i]]			}			if(outs.length == 0){ return null }									if(extra != null) {extra.push(newAllArcs),extra.push(intersection),extra.push(colorCodes),extra.push(newJunctions),extra.push(newPathData)}			return newOuts				}				public static  function getDeepestPair(o1,o2,...args):Number{						if(args.length == 0 ){ var input = new Array() } else { input = args[0] }			// right now, work under the assumption that only one intersected path exists...						var t0 = flash.utils.getTimer()						var extra = new Array()			var pOut = eraIntUni(o1,o2,1,extra)			if(pOut == null){return -1}			var allArcs = extra[0]			var intData = extra[1]			var colorCodes = extra[2]			var junctions = extra[3]			var pathData = extra[4]						var path = pOut[0]			var pt = path.externalCoords(path.getCOM())			var v1  = o1.object.getVel(pt)			var v2  = o2.object.getVel(pt)			var vAvg = [(v1[0] + v2[0])/2,(v1[1] + v2[1])/2]			var u1 = [v1[0] - vAvg[0],v1[1] - vAvg[1]]			var u2 = [v2[0] - vAvg[0],v2[1] - vAvg[1]]			var mag1 = Math.sqrt(Math.pow(u1[0],2) + Math.pow(u1[1],2))			var unitU1 = [u1[0]/mag1, u1[1] / mag1]			var axisPerp =[ [0,0],[-1 * unitU1[1], unitU1[0]]]						var trySimpleUnit = false			if(junctions[0].length == 2){				if(trySimpleUnit){					var xy1 = junctions[0][0].getXY()					var xy2 = junctions[0][1].getXY()					var vec = [xy2[0] - xy1[0], xy2[1] - xy1[1]]					var mag = Math.sqrt(Math.pow(vec[0],2) + Math.pow(vec[1],2))					axisPerp = [[0,0,],[vec[0] / mag, vec[1] / mag]]				}								var node = junctions[0][0]				var firstOutline = pathData[0][0][0]				var arcNum = pathData[0][0][1]								var arc = allArcs[arcNum]				var search = true				if(firstOutline.object == o1.object ){ var idx = 0 } else {idx = 1}				var nodes1 = new Array()				var nodes2 = new Array()				PhysUniverse.universe.wSet(2)				PhysUniverse.universe.wClear()				while(search){					if(node == junctions[0][1]){idx = 1-idx}					if(idx == 0) { nodes1.push(node) }					if(idx == 1) { nodes2.push(node) }					var node = node.next					if(node == junctions[0][0]){search = false}					var s = new Sprite()					if(idx == 0){s.graphics.lineStyle(0,0xFF0000)}					if(idx == 1){s.graphics.lineStyle(2,0x0000FF)}					s.graphics.moveTo(node.prev.getXY()[0],node.prev.getXY()[1])					s.graphics.lineTo(node.getXY()[0],node.getXY()[1])					PhysUniverse.universe.wAdd(s)				}												var maxDist = -1				var maxIDXs = [-1,-1]				for(var i = 0; i < nodes1.length; i++){					var seg1 = [nodes1[i].getXY(),nodes1[i].next.getXY()]					for(var j = 0 ;j < nodes2.length ; j++) {						var seg2 = [nodes2[j].getXY(),nodes2[j].next.getXY()]						var pair = new Array()						var dist = VectorMath2D.segSegDistAcrossAxis(seg1,seg2,axisPerp,false,pair)						if(dist > maxDist){							maxIDXs = [i,j]							maxDist = dist							var bestPair = pair[0]						}					}				s = new Sprite()				s.graphics.lineStyle(1,0x000000)				s.graphics.drawCircle(seg1[0][0],seg1[0][1],10)				PhysUniverse.universe.wAdd(s)				}				 			} else {return -1 }						input.push(bestPair)			input.push(maxDist)			input.push([junctions[0][0].getXY(),junctions[0][1].getXY()])			input.push(path)			var v1 = o1.object.getVel(bestPair[0])			var v2 = o2.object.getVel(bestPair[1])			var d1 = VectorMath2D.dotMultiply2D(v1,[- axisPerp[1][1], axisPerp[1][0]])			var d2 = VectorMath2D.dotMultiply2D(v2,[ -axisPerp[1][1], axisPerp[1][0]])			var v1dIn = d1 - d2			var timeIn = maxDist / Math.abs(v1dIn)			//neglects the possibility that velocities could be seperating the objects																			   //			var magVIn = Math.sqrt(Math.pow(v1[0] - v2[0],2) + Math.pow(v1[1] - v2[1],2))//			var timeIn = Math.abs(maxDist / magVIn)			return timeIn								}				public function nodesInRect(rect:Rectangle):Array{			var findSeg = true			var type = 2			var localRect = rectInLocalCoords(rect)				if(segments == null){genSegments()}				var search = true				var loops = 0				var bottom = new Array()				while(search){					if(loops == 0){						var s = segments					} else {						s = new Array()							for(i = 0 ; i < qualified.length ; i++){														if(qualified[i].subSegments!=null){								var c = qualified[i].subSegments								s = s.concat(c)															} else {															bottom.push(qualified[i])							}						}					}					if(s.length != 0){						var qualified = new Array()						for(var i = 0 ; i < s.length ; i++){							var intersect = localRect.intersection(s[i].bounds)							if(intersect.width != 0){								qualified.push(s[i])							}						}					} else {						var nodesFinal = new Array()						for( i = 0 ; i < bottom.length ; i++){							var nodes = bottom[i].nodesInRect(localRect)							nodesFinal = nodesFinal.concat(nodes)						}						search = false					}										loops ++				}				return nodesFinal			return out		}					public function nodesInRadius(pt:Array, radius:Number):Array{			var findSeg = true			var type = 2			var localXY = localCoords(pt)				if(segments == null){genSegments()}				var search = true				var loops = 0				var bottom = new Array()				while(search){					if(loops == 0){						var s = segments					} else {						s = new Array()						for(i = 0 ; i < qualified.length ; i++){													if(qualified[i].subSegments!=null){								var c = qualified[i].subSegments								s = s.concat(c)															} else {															bottom.push(qualified[i])							}						}					}					if(s.length != 0){						var qualified = new Array()						for(var i = 0 ; i < s.length ; i++){							var dist = VectorMath2D.ptRectMinDist(localXY,s[i].bounds)							if(dist < radius){								qualified.push(s[i])							}						}					} else {						var nodesFinal = new Array()						for( i = 0 ; i < bottom.length ; i++){							var nodes = bottom[i].nodesInRadius(localXY,radius)							nodesFinal = nodesFinal.concat(nodes)						}						search = false					}					loops ++				}								return nodesFinal			return out		}					public function closestNearSeed(externalXY:Array, seed:Node, radius:Number){			var localXY = localCoords(externalXY)						var search = true			var minNode = null			var minDist = 0			var node = seed			while(search){				var dist = node.ptBitDistance(localXY)				if(dist > radius){					search = false				} else {					if(minNode == null || dist < minDist){						minNode = node						minDist = dist					}				}				node = node.prev				if(node == seed){search = false}			}			search = true			node = seed.next			while(search){				var dist = node.ptBitDistance(localXY)				if(dist > radius){					search = false				} else {					if(minNode == null || dist < minDist){						minNode = node						minDist = dist					}				}				node = node.next				if(node == seed){search = false}							}			return(minNode)		}		public function closestMonotonic(externalXY:Array,seed:Node){			var localXY = localCoords(externalXY)						var search = true			var minNode = null			var minDist = 0			var node = seed			while(search){				var dist = node.ptBitDistance(localXY)				if(minNode == null || dist < minDist){					minNode = node					minDist = dist				} else {					search = false				}				node = node.prev				if(node == seed){search = false}			}			search = true			node = seed.next			while(search){				var dist = node.ptBitDistance(localXY)				if(minNode == null || dist < minDist){					minNode = node					minDist = dist				} else {					search = false				}				node = node.next				if(node == seed){search = false}							}			return(minNode)				}				public function closestUnitsMonotonic(unitOut:Array,seed:Node){						var search = true			var minNode = null			var minAngle = 0			var node = seed			while(search){				var units = getUnitsExt(node)				var angleStartToThis = VectorMath2D.angle1To2(unitOut,[units[2],units[3]])				if(minNode == null || Math.abs(angleStartToThis) < minAngle){					minNode = node					minAngle = Math.abs(angleStartToThis)				} else {					search = false				}				node = node.prev				if(node == seed){search = false}			}			search = true			node = seed.next			while(search){				 units = getUnitsExt(node)				 angleStartToThis = VectorMath2D.angle1To2(unitOut,[units[2],units[3]])				if(minNode == null || Math.abs(angleStartToThis) < minAngle){					minNode = node					minAngle = Math.abs(angleStartToThis)				} else {					search = false				}				node = node.next				if(node == seed){search = false}							}			return(minNode)				}				public function findDepths(node:Node,unitIn:Array,segEnds:Array):Array{			var n0 = node			var seg0Ext = segEnds[0]			var seg0Local =localCoords(seg0Ext) 						var seg1Ext = segEnds[1]			var seg1Local =localCoords(seg1Ext) 						var depthsFwd = new Array(), depthsBkwd = new Array()			var ptsFwd = new Array(), ptsBkwd = new Array()			var nodesFwd = new Array(), nodesBkwd = new Array()			var hitEnd = new Array(2)						var searchForward = true			var loops = 0			while(searchForward){				loops++				if(loops >10){searchForward = false}				var closest = VectorMath2D.ptLineClosest([node.x,node.y],seg0Local,seg1Local)				if(closest[2] == 0 || closest[2] == 1){					hitEnd[0] = closest[2]					searchForward = false					var segA = [node.x,node.y]					var segB = [node.prev.x,node.prev.y]										if(closest[2] == 0){						var segC = seg0Local						var segD = [segC[0] + unitIn[0]*100,segC[1] + unitIn[1]*100]					} else {						var segC = seg1Local						var segD = [segC[0] + unitIn[0]*100,segC[1] + unitIn[1]* 100]											}					var intersect = VectorMath2D.segLineIntersect([segA,segB],[segC,segD])															var pt = intersect					if(intersect == null){						depth = Number.NaN					} else {						var d0 = [intersect[0] - seg0Local[0],intersect[1] - seg0Local[1]]						var depth = VectorMath2D.dotMultiply2D(d0,unitIn)					}									} else {					pt = [node.x,node.y]					d0 = [node.x - seg0Local[0],node.y - seg0Local[1]]					depth = VectorMath2D.dotMultiply2D(d0,unitIn)				}				nodesFwd.push(node)				depthsFwd.push(depth)				ptsFwd.push(externalCoords(pt))				node = node.next			}			var searchBackward = true			loops = 0			node = n0 			while(searchBackward){								loops++				if(loops >10){searchBackward = false}				var closest = VectorMath2D.ptLineClosest([node.x,node.y],seg0Local,seg1Local)								if(closest[2] == 0 || closest[2] == 1){					hitEnd[0] = closest[2]					searchBackward = false					var segA = [node.x,node.y]					var segB = [node.next.x,node.next.y]					if(closest[2] == 0){						var segC = seg0Local						var segD = [segC[0] + unitIn[0],segC[1] + unitIn[1]]					} else {												var segC = seg1Local						var segD = [segC[0] + unitIn[0],segC[1] + unitIn[1]]											}					var intersect = VectorMath2D.segLineIntersect([segA,segB],[segC,segD])					var pt = intersect					if(intersect == null){						depth = Number.NaN					} else {						var d0 = [intersect[0] - seg0Local[0],intersect[1] - seg0Local[1]]						var depth = VectorMath2D.dotMultiply2D(d0,unitIn)					}				} else {					pt = [node.x,node.y]					d0 = [node.x - seg0Local[0],node.y - seg0Local[1]]					depth = VectorMath2D.dotMultiply2D(d0,unitIn)				}				nodesBkwd.push(node)				depthsBkwd.push(depth)				ptsBkwd.push(externalCoords(pt))				node = node.prev			}			return([[ptsFwd,ptsBkwd],[depthsFwd,depthsBkwd],[nodesFwd,nodesBkwd]])					}				public function ptIsInside(ptXY:Array):Boolean{			if(!fillUpdated){genFill()}			var localXY = localCoords(ptXY)			var d = new BitmapData(2,1,false,0x000000)			var mat = new Matrix(1,0,0,1,-localXY[0],-localXY[1])			d.draw( fill,mat,new ColorTransform(1,1,1,1,255,-255,-255,255))			var rect = d.getColorBoundsRect(0xFFFFFF,0xFF0000,true)			if(rect.width == 0){return false} else {return true}		}		public function getCOM():Array{			var nodes = nodesInOrder()			var COM = [0,0]			for(var i = 0 ; i < nodes.length ; i++){				COM[0] += nodes[i].x				COM[1] += nodes[i].y			}			COM[0] *= (1/nodes.length)			COM[1] *= (1/nodes.length)			return COM		}		//Methods to modify the outline wrt external points		public function pushPt(ptXY:Array,...args):void{			if(args.length > 0){var oldNode = args[0]} else {oldNode = null}			var localXY = localCoords(ptXY)			var node = new Node(localXY[0],localXY[1])			node.oldNode = oldNode			pushNode(node)		}		public function pushNode(node:Node, ...args):void{			var prev:Node						if(first == null){				setFirst( node )				first.next = first				first.prev = first			} else {			if(args.length ==0 ){prev = first.prev} else { prev = args[0] }				node.address = prev.address				node.prev = prev				node.next = prev.next				prev.next.prev = node				prev.next = node			}			if(bounds == null){				bounds = new Rectangle(node.x,node.y)				circBounds = [node.x,node.y, 0]			}			if(node.x < bounds.left){bounds.left = node.x}			if(node.x > bounds.right){bounds.right = node.x}			if(node.y <bounds.top){bounds.top = node.y}			if(node.y >bounds.bottom){bounds.bottom = node.y}			circBounds = circleIncludePoint(circBounds,[node.x,node.y])			numNodes ++			nodeChanged(node)			node.thisCtdOutline = this		}		public function circleIncludePoint(circle:Array,ptXY:Array):Array{			var vec = [ptXY[0] - circle[0], ptXY[1] - circle[1]]			var l = Math.sqrt(Math.pow(vec[0],2) + Math.pow(vec[1],2))			if(l <= circle[2]){ return circle}			var diff = l - circle[2]			var unitVec = [vec[0] / l, vec[1] / l]			var newRad = circle[2] + diff/2			var newCenter = [circle[0] + unitVec[0] * diff/2, circle[1] + unitVec[1] *diff/2]			return [newCenter[0],newCenter[1],newRad]																							}		public function removeNode(node:Node):void{			node.flush()			numNodes --			nodeChanged(node)		}						//Purely Cosmetic Methods		public function drawSmoothOutline(...args){			if(args.length >0){var thick = args[0]} else {thick = 1}			if(args.length >1){var color = args[1]} else {color = 0xCCCCCC}			if(args.length >2){var drawFill = args[2]} else {drawFill = true}			if(args.length >3){var fillColor = args[3]} else {fillColor = 0xFFFFFF}			var badSegs = new Array()			var goodSegs = new Array()			for(var i = 0; i<segments.length;i++){				badSegs.push(segments[i])			}			while(badSegs.length >0){				var seg = badSegs.pop()				if(seg.subSegments != null){					badSegs = badSegs.concat(seg.subSegments)				} else {					goodSegs.push(seg)				}			}			goodSegs = goodSegs.reverse()			var s = new Sprite()			s.graphics.lineStyle(thick,color)			if(drawFill){s.graphics.beginFill(fillColor)}			s.graphics.moveTo(goodSegs[0].first.x,goodSegs[0].first.y)			for(i = 0; i < goodSegs.length ; i++){				s.graphics.curveTo(goodSegs[i].controlPoint[0],goodSegs[i].controlPoint[1],goodSegs[i].last.x,goodSegs[i].last.y)			}			return s					}		public function simpleDrawNoBigs(...args){			if(args.length>0){var drawOutline = args[0]} else {drawOutline = false}			if(args.length>1){var drawFill = args[1]} else {drawFill = false}			if(args.length>2){var thick = args[2]} else {thick = 5}			if(args.length>3){var outlineColor = args[3]} else {outlineColor = 0x444444}			if(args.length>4){var fillColor = args[4]} else {fillColor = 0xCCCCCC}			if(args.length>5){var external = args[5]} else {external = false}			var s = new Sprite()			if(drawFill){s.graphics.beginFill(fillColor)}			if(drawOutline){s.graphics.lineStyle(thick,outlineColor)}			var search = true			if(external){var coord = externalCoords([first.x,first.y]) } else { coord = [first.x,first.y]}			s.graphics.moveTo(coord[0],coord[1])			var node = first.next						var count = 0			while(search){				if(node ==first ){search = false}								if(external){coord = externalCoords([node.x,node.y]) } else { coord = [node.x,node.y]}				s.graphics.lineTo(coord[0],coord[1])				if(drawOutline){s.graphics.lineStyle(thick,outlineColor)}								if(node.nextBig == null){					node = node.next				} else {					var big = node.nextBig					node = big.lastNode					if(big.includesFirst){search = false}					s.graphics.lineStyle()				}				count++				if(count >numNodes){search = false; trace(bigNodes[0].includesFirst,"COUNTOVERRUN")}			}			return s					}		public function simpleDraw(...args){			if(args.length>0){var drawOutline = args[0]} else {drawOutline = false}			if(args.length>1){var drawFill = args[1]} else {drawFill = false}			if(args.length>2){var thick = args[2]} else {thick = 5}			if(args.length>3){var outlineColor = args[3]} else {outlineColor = 0x444444}			if(args.length>4){var fillColor = args[4]} else {fillColor = 0xCCCCCC}			if(args.length>5){var external = args[5]} else {external = false}			var s = new Sprite()			if(drawFill){s.graphics.beginFill(fillColor)}			if(drawOutline){s.graphics.lineStyle(thick,outlineColor)}			var search = true			if(external){var coord = externalCoords([first.x,first.y]) } else { coord = [first.x,first.y]}			s.graphics.moveTo(coord[0],coord[1])			var node = first.next						var count = 0			while(search){				if(node ==first ){search = false}								if(external){coord = externalCoords([node.x,node.y]) } else { coord = [node.x,node.y]}				s.graphics.lineTo(coord[0],coord[1])				if(drawOutline){s.graphics.lineStyle(thick,outlineColor)}				node = node.next							}			return s					}		public function simpleDrawGradient(...args){			if(args.length>0){var drawOutline = args[0]} else {drawOutline = false}			if(args.length>1){var drawFill = args[1]} else {drawFill = false}			if(args.length>2){var thick = args[2]} else {thick = 5}			if(args.length>3){var outlineColor = args[3]} else {outlineColor = 0x444444}			if(args.length>4){var fillColor = args[4]} else {fillColor = 0xCCCCCC}			if(args.length>5){var external = args[5]} else {external = false}			var s = new Sprite()			if(drawFill){s.graphics.beginFill(fillColor)}			if(drawOutline){s.graphics.lineStyle(thick,outlineColor)}			var search = true			if(external){var coord = externalCoords([first.x,first.y]) } else { coord = [first.x,first.y]}			s.graphics.moveTo(coord[0],coord[1])			var node = first.next						var count = 0			var tally = 0			while(search){				tally++				if(node ==first ){search = false}								if(external){coord = externalCoords([node.x,node.y]) } else { coord = [node.x,node.y]}				s.graphics.lineTo(coord[0],coord[1])				if(drawOutline){s.graphics.lineStyle(thick,255 * tally / numNodes,.5)}				node = node.next							}			return s					}		public function drawSmoothOutlineExt(...args){			if(args.length >0){var thick = args[0]} else {thick = 1}			if(args.length >1){var color = args[1]} else {color = 0xCCCCCC}			if(args.length >2){var drawFill = args[2]} else {drawFill = true}			if(args.length >3){var fillColor = args[3]} else {fillColor = 0xFFFFFF}			var badSegs = new Array()			var goodSegs = new Array()			for(var i = 0; i<segments.length;i++){				badSegs.push(segments[i])			}			while(badSegs.length >0){				var seg = badSegs.pop()				if(seg.subSegments != null){					badSegs = badSegs.concat(seg.subSegments)				} else {					goodSegs.push(seg)				}			}			goodSegs = goodSegs.reverse()			var s = new Sprite()			s.graphics.lineStyle(thick,color)			if(drawFill){s.graphics.beginFill(fillColor)}			var coord = externalCoords([goodSegs[0].first.x,goodSegs[0].first.y])			s.graphics.moveTo(coord[0],coord[1])			for(i = 0; i < goodSegs.length ; i++){				var cont = externalCoords([goodSegs[i].controlPoint[0],goodSegs[i].controlPoint[1]])				var anch = externalCoords([goodSegs[i].last.x,goodSegs[i].last.y])				s.graphics.curveTo(cont[0],cont[1],anch[0],anch[1])			}			return s					}		public function drawOutline(...args):Sprite{			var outline = new Sprite()			if(args.length > 0){var useCurves = args[0]} else {useCurves = false}			if(args.length > 1){var address = args[1]} else {address = null}			if(args.length > 2){var thick = args[2]} else {thick = 5}			if(args.length > 3){var color = args[3]} else {color = 0x000000}			if(args.length > 4){var alpha = args[4]} else {alpha = 1}			outline.graphics.lineStyle(thick,color,alpha)						if(address == null){				if(useCurves){					for(var i = 0 ; i < segments.length ; i++){						outline.addChild(segments[i].drawCurves())					}				} else {					var search = true					var node = first					outline.graphics.moveTo(node.x,node.y)					while(search){						node = node.next						outline.graphics.lineTo(node.x,node.y)						if(node == first){search = false}					}				}			}else{								outline.graphics.moveTo(segments[0].xAvg,segments[0].yAvg)				for( i = 1 ; i < segments.length ; i++){					outline.graphics.lineTo(segments[i].xAvg,segments[i].yAvg)				}				var seg = segments[address[0]]				if(useCurves){					outline.addChild(seg.drawCurves(address,1))				} else {					outline.addChild(seg.drawSegs(address,1))									}			}			return outline		}		public function drawOutlineExt(...args):Sprite{			var outline = new Sprite()			if(args.length > 0){var useCurves = args[0]} else {useCurves = false}			if(args.length > 1){var address = args[1]} else {address = null}			if(args.length > 2){var thick = args[2]} else {thick = 5}			if(args.length > 3){var color = args[3]} else {color = 0x000000}			if(args.length > 4){var alpha = args[4]} else {alpha = 1}			outline.graphics.lineStyle(thick,color,alpha)						if(address == null){				if(useCurves){					for(var i = 0 ; i < segments.length ; i++){						outline.addChild(segments[i].drawCurves())					}				} else {					var search = true					var node = first					var nXY = nodeExternalCoords(node)					outline.graphics.moveTo(nXY[0],nXY[1])					while(search){						node = node.next						 nXY = nodeExternalCoords(node)						outline.graphics.lineTo(nXY[0],nXY[1])						if(node == first){search = false}					}				}			}else{								var avgXY = externalCoords([segments[0].xAvg,segments[0].yAvg])				outline.graphics.moveTo(avgXY[0],avgXY[1])				for( i = 1 ; i < segments.length ; i++){					avgXY = externalCoords([segments[i].xAvg,segments[i].yAvg])					outline.graphics.lineTo(segments[i].xAvg,segments[i].yAvg)				}				var seg = segments[address[0]]				if(useCurves){					outline.addChild(seg.drawCurves(address,1))				} else {					outline.addChild(seg.drawSegs(address,1))									}			}			return outline		}		public function drawSegEnds():Sprite{			var outline = new Sprite			outline.graphics.lineStyle(0)			for(var i = 0; i< segments.length ; i++){				outline.graphics.drawCircle(segments[i].first.x,segments[i].first.y,20)				outline.addChild(segments[i].drawSegEnds(.6))			}			return outline		}		public function drawFill(...args):Shape{			if(args.length <1){var color = 0x000000} else{ color = args[0]}			if(args.length >1){var alpha = args[1]} else {alpha = 1}			var f = new Shape()			f.graphics.beginFill(color,alpha)			f.graphics.moveTo(first.x,first.y)			var node = first			var search = true			while(search){				node = node.next				f.graphics.lineTo(node.x,node.y)				if(node == first){					search = false				}			}			return f		}		public function circleAndConnectNodes(thick:Number, rad:Number, color:uint):Shape{			var nodes = nodesInOrder()			var s = new Shape()			s.graphics.lineStyle(thick, color,1)			s.graphics.moveTo(nodes[0].x,nodes[0].y)			for(var i = 0 ; i < nodes.length; i++){				s.graphics.lineTo(nodes[i].x, nodes[i].y)				s.graphics.drawCircle(nodes[i].x,nodes[i].y,rad)				s.graphics.moveTo(nodes[i].x,nodes[i].y)			}			return(s)		}		public function drawFillExt(...args):Shape{			if(args.length <1){var color = 0x000000} else{ color = args[0]}			if(args.length >1){var alpha = args[1]} else {alpha = 1}			if(args.length >2){var thick = args[2]} else {thick = 0}			var f = new Shape()			if(thick > 0){f.graphics.lineStyle(thick,color)}			f.graphics.beginFill(color,alpha)			var fXY = nodeExternalCoords(first)			f.graphics.moveTo(fXY[0],fXY[1])			var node = first			var search = true			while(search){				node = node.next				var nXY = nodeExternalCoords(node)				f.graphics.lineTo(nXY[0],nXY[1])				if(node == first){					search = false				}			}			return f		}	}	}