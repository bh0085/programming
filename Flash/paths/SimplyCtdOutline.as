package paths{	import physics.PhysObject	import flash.display.Sprite	import flash.display.Shape	import flash.display.BitmapData	import flash.geom.Matrix	import flash.geom.ColorTransform		public class CtdOutline implements Outline{		public var segments:Array		public var fill:Shape		public var first:Node		var object:PhysObject		var numNodes = 0		var fillUpdated = false		var alteredNodes = new Array()		var autoUpdateIndividualSegments = false		var autoUpdateAfterGeneration = true		var ort = 1				//Bookeeping Methods		public function segsUpdated():Boolean{			if(alteredNodes.length == 0){return true} else {return false}		}		public function nodeChanged(node):void{			fillUpdated = false			alteredNodes.push(node)			if(autoUpdateIndividualSegments){				while(alteredNodes.length > 0){					var update = alteredNodes.splice(0,1)[0]					var add = update.address					Segment.compute3Pts(segments,add)				}			}		}		public function nodesInOrder():Array{			if(first == null){return null}			var nIO = new Array()			var search = true			var node = first			while(search){				nIO.push(node)				node = node.next				if(node == first){search = false}			}			return nIO		}		public function genFill(...args):void{			if(args.length ==0){var color = 0xFFFFFF} else{ color = args[0]}			fill = new Shape()			fill.graphics.beginFill(color)			fill.graphics.moveTo(first.x,first.y)			var node = first			var search = true			while(search){				node = node.next				fill.graphics.lineTo(node.x,node.y)				if(node == first){					search = false				}			}			fillUpdated = true		}		public function genSegments(segLevels:Number, finalRes:Number):void{			var node = first			for(var i = 0; i < numNodes ; i++){								node.firstOf = new Array()				node.lastOf = new Array()				node = node.next			}			first.firstOf.push(this)						var pow = 1/(segLevels)			var sNum = (numNodes / finalRes)			var subdivision = (Math.pow(sNum, pow))			var segs = new Array()			var nPer = Math.ceil(numNodes / subdivision)						var segStart = first			var spawnSegments = true			var segSoFar = 0			if(segStart == null){ segments = null }			while (spawnSegments){				var nextFirst = segStart				 node = segStart				segStart = null				var search = true				var tally = 1				var xNet = node.x				var yNet = node.y				while(search) {					node.address = new Array()					node.address.push(segSoFar)					node = node.next					if(tally == Math.ceil(nPer + 1)) {						var nextLast = node						search = false						segStart = node					}					if(node == first){						nextLast = node						search = false						spawnSegments = false					}					xNet += node.x					yNet += node.y					tally++				}				var seg = new Segment(nextFirst,nextLast,xNet/tally,yNet/tally,tally)				seg.segIdx = segSoFar				segSoFar++				segs.push(seg)			}			segments = segs				if(segLevels >1){				for( i = 0; i < segments.length ; i++){					segments[i].genSubSegments(segLevels -1 , finalRes)				}			}			alteredNodes = new Array()			getOrientation()			if(autoUpdateAfterGeneration){autoUpdateIndividualSegments = true}		}		public function setFirst(node:Node){			first = node			node.firstOf.push(this)		}		public function getOrientation(){			var unitOut = getUnits(first)[1]			var mid = getBitMidpoint(first)			var localTestOutside = [mid[0] + unitOut[0] * 2, mid[1] + unitOut[1] * 2]			var externalTestOutside = externalCoords(localTestOutside)			var isOutside = ptIsInside(externalTestOutside)			if(!isOutside){ort *= -1}		}		public function getBitMidpoint(node:Node):Array{			return ([ (node.x + node.next.x) / 2, (node.y + node.next.y) / 2])		}		public function getUnits(node:Node):Array{			var seg = [ort* (node.next.x - node.x), ort *(node.next.y - node.y)]			var mag = Math.sqrt(Math.pow(seg[0],2) + Math.pow(seg[1],2))			var unitAlong = [seg[0] / mag, seg[1] / mag]			var unitPerp = [-unitAlong[1],unitAlong[0]]			var units = [unitAlong, unitPerp]			return units		}		//Methods to compare the outline to other points				public function xOffset():Number{			if(object != null){return object.getX()} else{return 0}		}		public function yOffset():Number{			if(object != null){return object.getY()} else{return 0}		}		public function externalCoords(localXY:Array){			var out:Array			if(object != null){out = [localXY[0] + object.getX(),localXY[1] + object.getY()]} else {out = localXY}			return out					}		public function localCoords(objXY:Array):Array{			var out:Array			if(object != null){out = [objXY[0] - object.getX(),objXY[1] - object.getY()]} else {out = objXY}			return out		}		public function closest(ptXY:Array, ...args):Node{			if(args.length ==0){var type = 2} else {type = args[0]}			if(args.length <2){var findSeg = true} else {findSeg = false}			if(segments == null){genSegments(3,15)}			var localXY = localCoords(ptXY)			var leastDist:Number			var leastIDX:Number			for(var i = 0 ; i < segments.length ; i++){				var dist = segments[i].metric(localXY,type)				if( i == 0 || dist < leastDist ){					leastDist = dist					leastIDX = i				}			}			var out = segments[leastIDX].closest(localXY,type,findSeg)			return out		}				public function ptIsInside(ptXY:Array):Boolean{			if(!fillUpdated){genFill()}			var localXY = localCoords(ptXY)			var d = new BitmapData(2,1,false,0x000000)			var mat = new Matrix(1,0,0,1,-localXY[0],-localXY[1])			d.draw( fill,mat,new ColorTransform(1,1,1,1,255,-255,-255,255))			var rect = d.getColorBoundsRect(0xFFFFFF,0xFF0000,true)			if(rect.width == 0){return false} else {return true}		}		//Methods to modify the outline wrt external points		public function pushPt(ptXY:Array):void{			var node = new Node(ptXY[0],ptXY[1])			pushNode(node, closest(ptXY))		}		public function pushNode(node:Node, ...args):void{			var prev:Node			if(args.length ==0 ){prev = first} else { prev = args[0] }						if(first == null){				setFirst( node )				first.next = first				first.prev = first			} else {				node.address = prev.address				node.prev = prev				node.next = prev.next				prev.next.prev = node				prev.next = node			}			numNodes ++			nodeChanged(node)		}		public function removeNode(node:Node):void{			node.flush()			numNodes --			nodeChanged(node)		}						//Purely Cosmetic Methods		public function drawOutline(...args):Sprite{			var outline = new Sprite()			if(args.length > 0){var useCurves = args[0]} else {useCurves = false}			if(args.length > 1){var address = args[1]} else {address = null}			if(args.length > 2){var thick = args[2]} else {thick = 5}			if(args.length > 3){var color = args[3]} else {color = 0x000000}			if(args.length > 4){var alpha = args[4]} else {alpha = 1}			outline.graphics.lineStyle(thick,color,alpha)						if(address == null){				if(useCurves){					for(var i = 0 ; i < segments.length ; i++){						outline.addChild(segments[i].drawCurves())					}				} else {					var search = true					var node = first					outline.graphics.moveTo(node.x,node.y)					while(search){						node = node.next						outline.graphics.lineTo(node.x,node.y)						if(node == first){search = false}					}				}			}else{								outline.graphics.moveTo(segments[0].xAvg,segments[0].yAvg)				for( i = 1 ; i < segments.length ; i++){					outline.graphics.lineTo(segments[i].xAvg,segments[i].yAvg)				}				var seg = segments[address[0]]				if(useCurves){					outline.addChild(seg.drawCurves(address,1))				} else {					outline.addChild(seg.drawSegs(address,1))									}			}			return outline		}		public function drawSegEnds():Sprite{			var outline = new Sprite			outline.graphics.lineStyle(0)			for(var i = 0; i< segments.length ; i++){				outline.graphics.drawCircle(segments[i].first.x,segments[i].first.y,20)				outline.addChild(segments[i].drawSegEnds(.6))			}			return outline		}		public function drawFill():Shape{			if(args.length >0){var color = 0x000000} else{ color = args[0]}			if(args.length >1){var alpha = args[1]} else {alpha = 1}			f = new Shape()			f.graphics.beginFill(color,alpha)			f.graphics.moveTo(first.x,first.y)			var node = first			var search = true			while(search){				node = node.next				f.graphics.lineTo(node.x,node.y)				if(node == first){					search = false				}			}			return f		}	}	}