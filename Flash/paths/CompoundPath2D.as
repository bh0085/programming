package paths{	import flash.display.Sprite		public class CompoundPath2D{			public var myPaths = new Array()				public function pushPath(path:Path2D):void{			myPaths.push(path)		}				public function prune(minDistance:Number):void{			for (var i = 0; i< myPaths.length ; i++){				myPaths[i].prune(minDistance)			}		}		public function setMergeDistance(mergeDistance:Number):void{			for (var i = 0; i< myPaths.length ; i++){				myPaths[i].setMergeDistance(mergeDistance)			}		}				public function toSprite():Sprite{			var sprite = new Sprite			for (var i = 0 ; i <myPaths.length ; i++){				sprite.addChild(myPaths[i].toShape())			}			return sprite		}				public function mergePairwise(maxDistance:Number):void{			var dArray = distances()			var hasMerged = new Array(myPaths.length)			var newPaths = new Array()			for(var i = 0 ; i < myPaths.length ; i++){				for(var j = 0; j< i; j++){					if(hasMerged[i] == null && hasMerged[j] == null)					if(dArray[i][j]<maxDistance){						var temp = Path2D.mergePaths(myPaths[i],myPaths[j])						newPaths.push(temp)						hasMerged[i] = true						hasMerged[j] = true					}				}			}			var pl = myPaths.length			for(i = 0; i<pl; i++){				if (hasMerged[ pl - 1 - i ] != null){					myPaths.splice(myPaths.length - 1 - i,1)				}			}			for(i = 0; i<newPaths.length ; i++){				myPaths.push(newPaths[i])			}		}				public function distances():Array{			var pl = myPaths.length			var out = new Array(pl)			for (var i = 0; i<pl ; i ++){				out[i] = new Array(pl)				for (var j = 0; j<i ; j++){					out[i][j] = minPtwiseDist(i,j)					out[j][i] = out[i][j]				}				out[i][i] = -1			}			return out		}				public function hasPaths():Boolean{			if(myPaths.length != 0){ return true } else {return(false)}		}				public function distancesToPath(path:Path2D){			var pl = myPaths.length			var out = new Array(pl)			for (var i = 0 ; i< pl ; i++){				out[i] = -1				for(var j = 0; j < path.pathX.length ; j++){					for(var k = 0; k< myPaths[i].pathX.length ; k ++){						var xy1 = [myPaths[i].pathX[k],myPaths[i].pathY[k]]						var xy2 = [path.pathX[j],path.pathY[j]]						var dist = Math.sqrt(Math.pow(xy1[0] - xy2[0], 2) + Math.pow(xy1[1] - xy2[1],2))						if( (out[i] == -1) || dist < out[i]){out[i] = dist}							}				}			}			return out		}				public function closestSegmentToPt(pt):Array{			var pl = myPaths.length			var bestDist = -1			var bestPathIDX = -1			var bestSegIDX = -1			for (var i = 0 ; i< pl ; i++){				var bestDistIDX = myPaths[i].closestSegmentToPoint(pt)				var dist = bestDistIDX[0]					if( (bestDist== -1) || dist < bestDist){						bestDist = dist						bestPathIDX = i						bestSegIDX = bestDistIDX[1]											}							}			return [bestPathIDX,bestSegIDX]		}				public function minPtwiseDist(idx1:Number, idx2:Number):Number{			var minDist = -1						for(var i = 0; i<myPaths[idx1].pathX.length ; i++){				for(var j = 0 ; j< myPaths[idx2].pathX.length; j++){					var xy1 = [myPaths[idx1].pathX[i],myPaths[idx1].pathY[i]]					var xy2 = [myPaths[idx2].pathX[j],myPaths[idx2].pathY[j]]					var dist = Math.sqrt(Math.pow(xy1[0] - xy2[0], 2) + Math.pow(xy1[1] - xy2[1],2))					if( (i== 0 && j==0) || dist < minDist){minDist = dist}				}			}			return minDist		}				}	}