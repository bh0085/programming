package paths{	import flash.display.Sprite	import math.VectorMath2D	import flash.geom.Rectangle	import flash.geom.Point	public class Segment {		var first:Node		var last:Node		var xAvg:Number		var yAvg:Number		var numNodes:Number		var subSegments:Array		var midPoint:Array		var controlPoint:Array		var segIdx:Number		var bounds:Rectangle		var circBounds:Array						//either seg.last and seg.numNodes may both become outdated as nodes are added and subtracted from the outline. 		//For the time being, there is nothing to do about this.		public function getCircBoundsExt():Array{			var eXY = first.thisCtdOutline.externalCoords([circBounds[0],circBounds[1]])			return [eXY[0],eXY[1],circBounds[2]]		}				public function Segment(f:Node,l:Node,xa:Number,ya:Number,tal:Number):void{			setFirst(f)			setLast(l)			xAvg = xa			yAvg = ya			numNodes = tal			var altitude = math.VectorMath2D.ptLineAltitude([xAvg,yAvg],[first.x,first.y],[last.x,last.y])			midPoint = [xAvg + .5 *altitude[0], yAvg + .5*  altitude[1]]			controlPoint=[xAvg + altitude[0] * 2, yAvg + altitude[1] *2]			var node = first			bounds = new Rectangle()			circBounds = [midPoint[0],midPoint[1],0]			var search = true			while(search){				if(node.x < bounds.left){					bounds.left = node.x				}				if(node.x > bounds.right){					bounds.right = node.x				}				if(node.y < bounds.top){					bounds.top = node.y				}				if(node.y > bounds.bottom){					bounds.bottom = node.y				}				circBounds = node.thisCtdOutline.circleIncludePoint(circBounds,[node.x,node.y])				if(node == last){search = false}				node = node.next			}		}		public function nodesInRect(rect:Rectangle):Array{			var nodes = new Array			var search = true			var node = first			while(search){				var x = Math.min(node.x,node.next.x)				var y = Math.min(node.y,node.next.y)				var w = Math.abs(node.x - node.next.x)				var h = Math.abs(node.y - node.next.y)				var nodeRect = new Rectangle(x,y,w,h)				if(rect.intersection(nodeRect).width != 0 ){					nodes.push(node)				}				node = node.next				if(node == last){search = false}			}			return nodes		}		public function nodesInRadius(localXY:Array, radius:Number):Array{			var nodes = new Array			var search = true			var node = first			while(search){				if(VectorMath2D.distance([node.x,node.y],localXY) < radius){					nodes.push(node)				}				node = node.next				if(node == last){search = false}			}			return nodes		}		public function nodesInOrder():Array{			var search = true			var out = new Array()			var node = first			while(search){				if(node != last){					out.push(node)					node = node.next				} else {					search = false				}			}			return out		}				public function genSubSegments(segLevels:Number, finalRes:Number):void{			if(segLevels ==1){var cBuild = true} else{cBuild = false}						var pow = 1/(segLevels)			var sNum = (numNodes / finalRes)			var subdivision = (Math.pow(sNum, pow))			var segs = new Array()			var nPer = Math.ceil(numNodes / subdivision)												var segStart = first			var spawnSegments = true			var segSoFar = 0			if(segStart == null){ segs = null }			while (spawnSegments){				var nextFirst = segStart				var uStart = nextFirst.thisCtdOutline.getUnits(nextFirst)				var node = segStart				segStart = null				var search = true				var tally = 1				var xNet = node.x				var yNet = node.y				while(search) {					node.address.push(segSoFar)					node = node.next					var units= node.thisCtdOutline.getUnits(node) 					var delta = VectorMath2D.angle1To2([uStart[0],uStart[1]],[units[0],units[1]])																var dAbs = Math.abs(delta)	   					if(tally == Math.ceil(nPer + 1) || dAbs > node.thisCtdOutline.angleCutoff(segLevels)) {						segStart = node						var nextLast = node						search = false					}					if(node == last){						nextLast = node						search = false						spawnSegments = false					}					xNet += node.x					yNet += node.y					tally++				}				var seg = new Segment(nextFirst,nextLast,xNet/tally,yNet/tally,tally)				seg.segIdx = segSoFar				segSoFar++				segs.push(seg)			}			subSegments = segs				if(segLevels >1){				for(var i = 0; i < subSegments.length ; i++){					subSegments[i].genSubSegments(segLevels -1 , finalRes )				}			}		}		public function setFirst(node:Node):void{			node.firstOf.push(this)			first = node		}		public function setLast(node:Node):void{			last = node			node.lastOf.push(this)		}				public function metric(localXY:Array,...args):Number{			if(args.length == 0){var type = 2} else {type = args[0]}			if(type == 0){				var dist = Math.sqrt(Math.pow(localXY[0] - xAvg,2) + Math.pow( localXY[1] - yAvg,2))			} else {				if( type == 1 ) {					dist = math.VectorMath2D.ptLineDist(localXY,[first.x,first.y],[last.x,last.y])[0]				} else {					dist = math.VectorMath2D.pt3PtDistance(localXY,[first.x,first.y],midPoint,[last.x,last.y])				}			}			return dist		}		public function closestNode(localXY:Array,findSeg:Boolean):Array{			var node = first			var bestNode:Node			var search = true 			while(search){				if(findSeg){					var dist = node.ptBitDistance(localXY)				} else {					dist = Math.sqrt(Math.pow(localXY[0] - node.x,2) + Math.pow(localXY[1] - node.y,2))				}				if(node == first || dist < leastDist){					bestNode = node					var leastDist = dist				}				if(node == last){search = false}				node = node.next			}			return([bestNode,leastDist])		}		public function closest(localXY:Array,searchType:Number,findSeg):Node{			if(subSegments != null){				var leastDist:Number				var leastIDX:Number				for(var i = 0 ; i < subSegments.length ; i++){ 					var dist = subSegments[i].metric(localXY,searchType)					if( i == 0 || dist < leastDist ){						leastDist = dist						leastIDX = i					}				}				var out = subSegments[leastIDX].closest(localXY,searchType,findSeg)				return out			} else {							var node = first				var bestNode:Node				var search = true 				while(search){					if(findSeg){						dist = node.ptBitDistance(localXY)					} else {						dist = Math.sqrt(Math.pow(localXY[0] - node.x,2) + Math.pow(localXY[1] - node.y,2))					}					if(node == first || dist < leastDist){						bestNode = node						leastDist = dist					}					if(node == last){search = false}					node = node.next				}				return(bestNode)			}		}		public function drawSegs(...args):Sprite{			var curve = new Sprite			curve.graphics.lineStyle(0)			if(args.length == 0){				var node = first				curve.graphics.moveTo(node.x,node.y)				var search = true				for(var i = 0 ; i < numNodes ; i++){					node = node.next					curve.graphics.lineTo(node.x,node.y)				}			} else {				var address = args[0]				var index = args[1]				if(subSegments != null){					curve.graphics.moveTo(subSegments[0].xAvg,subSegments[0].yAvg)					for( i = 1 ; i<subSegments.length ; i++){						curve.graphics.lineTo(subSegments[i].xAvg,subSegments[i].yAvg)					}				}				var newIndex = index + 1				if(newIndex < address.length){					curve.addChild(subSegments[address[index]].drawSegs(address,newIndex))				} else {					node = first					curve.graphics.moveTo(node.x,node.y)					search = true					for( i = 0 ; i < numNodes ; i++){						node = node.next						curve.graphics.lineTo(node.x,node.y)					}									}			}			return curve		}		public function drawCurves(...args):Sprite{			var curve = new Sprite			curve.graphics.lineStyle(0)			curve.graphics.moveTo(first.x,first.y)			var altitude = math.VectorMath2D.ptLineAltitude([xAvg,yAvg],[first.x,first.y],[last.x,last.y])			curve.graphics.curveTo(controlPoint[0],controlPoint[1],last.x,last.y)			curve.graphics.moveTo(first.x,first.y)			curve.graphics.lineStyle(0,0xFF0000)			curve.graphics.lineTo(midPoint[0],midPoint[1])			curve.graphics.lineTo(last.x,last.y)			if(args.length != 0){				var address = args[0]				var index = args[1]				var newIndex = index + 1				if(newIndex < address.length){					curve.addChild(subSegments[address[index]].drawCurves(address,newIndex))				}			}			return curve					}		public function drawSegEnds(multiplier:Number):Sprite{			var outline = new Sprite			if(subSegments != null){				outline.graphics.lineStyle(0)				for(var i = 0; i< subSegments.length ; i++){					outline.graphics.drawCircle(subSegments[i].first.x,subSegments[i].first.y,20 * multiplier)					outline.addChild(subSegments[i].drawSegEnds(multiplier * .6))				}			}			return outline					}				public function reInitialize(xa:Number,ya:Number,tal:Number){			xAvg = xa			yAvg = ya			numNodes = tal			var altitude = math.VectorMath2D.ptLineAltitude([xAvg,yAvg],[first.x,first.y],[last.x,last.y])			midPoint = [xAvg + .5 *altitude[0], yAvg + .5*  altitude[1]]			controlPoint=[xAvg + altitude[0] * 2, yAvg + altitude[1] *2]		}		public static function compute3Pts(segArray:Array, address:Array){			for(var i = 0; i<address.length ; i++){				if(i == 0){var segment = segArray[address[i]]} else {segment = segment.subSegments[address[i]]}				var search = true				var tally = 0				var xNet = 0				var yNet = 0				var node = segment.first				while(search){					tally++					xNet += node.x					yNet += node.y					if(node == segment.last){search = false}					node = node.next					if(tally > 100){ search = false }				}				segment.reInitialize(xNet/tally,yNet/tally,tally)			}		}	}	}